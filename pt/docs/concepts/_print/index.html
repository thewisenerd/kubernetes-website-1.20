<!doctype html><html lang=pt class=no-js><head><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-36037335-10"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','UA-36037335-10')</script><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/><link rel=alternate hreflang=zh href=https://kubernetes.io/zh/docs/concepts/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/><link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/concepts/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/><link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/concepts/><link rel=alternate hreflang=pl href=https://kubernetes.io/pl/docs/concepts/><link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/concepts/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.82.0"><link rel=canonical type=text/html href=https://kubernetes.io/pt/docs/concepts/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Conceitos | Kubernetes</title><meta property="og:title" content="Conceitos"><meta property="og:description" content="Orquestração de contêineres em nível de produção"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/pt/docs/concepts/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Conceitos"><meta itemprop=description content="Orquestração de contêineres em nível de produção"><meta name=twitter:card content="summary"><meta name=twitter:title content="Conceitos"><meta name=twitter:description content="Orquestração de contêineres em nível de produção"><link rel=preload href=/scss/main.min.aeea2a074ae7ac3d467a0d6f52e45894b49452cbb3f0f410c268ec7280c5a653.css as=style><link href=/scss/main.min.aeea2a074ae7ac3d467a0d6f52e45894b49452cbb3f0f410c268ec7280c5a653.css rel=stylesheet integrity><script src=/js/jquery-3.3.1.min.js integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin=anonymous></script><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png"}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="A seção de Conceitos irá te ajudar a aprender mais sobre as partes do ecossistema Kubernetes e as abstrações que o Kubernetes usa para representar seu cluster.
Ela irá lhe ajudar a obter um entendimento mais profundo sobre como o Kubernetes funciona."><meta property="og:description" content="A seção de Conceitos irá te ajudar a aprender mais sobre as partes do ecossistema Kubernetes e as abstrações que o Kubernetes usa para representar seu cluster.
Ela irá lhe ajudar a obter um entendimento mais profundo sobre como o Kubernetes funciona."><meta name=twitter:description content="A seção de Conceitos irá te ajudar a aprender mais sobre as partes do ecossistema Kubernetes e as abstrações que o Kubernetes usa para representar seu cluster.
Ela irá lhe ajudar a obter um entendimento mais profundo sobre como o Kubernetes funciona."><meta property="og:url" content="https://kubernetes.io/pt/docs/concepts/"><meta property="og:title" content="Conceitos"><meta name=twitter:title content="Conceitos"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/script.js></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/pt/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/pt/docs/>Documentação</span></a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/pt/blog/>Kubernetes Blog</span></a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/pt/partners/>Parceiros</span></a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/pt/community/>Comunidade</span></a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/pt/case-studies/>Casos de estudo</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versions</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=https://kubernetes.io/pt/docs/concepts/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/pt/docs/concepts/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/pt/docs/concepts/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/pt/docs/concepts/>v1.21</a>
<a class=dropdown-item href=https://v1-20.docs.kubernetes.io/pt/docs/concepts/>v1.20</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Português</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/>English</a>
<a class=dropdown-item href=/zh/docs/concepts/>中文 Chinese</a>
<a class=dropdown-item href=/ko/docs/concepts/>한국어 Korean</a>
<a class=dropdown-item href=/ja/docs/concepts/>日本語 Japanese</a>
<a class=dropdown-item href=/fr/docs/concepts/>Français</a>
<a class=dropdown-item href=/it/docs/concepts/>Italiano</a>
<a class=dropdown-item href=/de/docs/concepts/>Deutsch</a>
<a class=dropdown-item href=/es/docs/concepts/>Español</a>
<a class=dropdown-item href=/id/docs/concepts/>Bahasa Indonesia</a>
<a class=dropdown-item href=/ru/docs/concepts/>Русский</a>
<a class=dropdown-item href=/pl/docs/concepts/>Polski</a>
<a class=dropdown-item href=/uk/docs/concepts/>Українська</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"></div><div class="d-none d-xl-block col-xl-2 td-toc d-print-none"></div><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/pt/docs/concepts/>Return to the regular view of this page</a>.</p></div><h1 class=title>Conceitos</h1><ul><li>1: <a href=#pg-0554ac387412eaf4e6e89b2f847dacde>Visão Geral</a></li><ul><li>1.1: <a href=#pg-45bdca6129cf540121623e903c18ba46>O que é Kubernetes?</a></li><li>1.2: <a href=#pg-13b0f1dbe89228e3d76d2ac231e245f1>Componentes do Kubernetes</a></li><li>1.3: <a href=#pg-110f33530cf761140cb1dab536baef04>Objetos do Kubernetes</a></li><ul><li>1.3.1: <a href=#pg-f37749a83c2916b63279ea60f3cfe53e>Nomes</a></li></ul></ul><li>2: <a href=#pg-2bf36ccd6b3dbeafecf87c39761b07c7>Arquitetura do Kubernetes</a></li><ul><li>2.1: <a href=#pg-c0251def6da29b30afebfb04549f1703>Comunicação entre Nó e Control Plane</a></li><li>2.2: <a href=#pg-bc804b02614d67025b4c788f1ca87fbc>Conceitos sobre Cloud Controller Manager</a></li><li>2.3: <a href=#pg-ca8819042a505291540e831283da66df>Controladores</a></li></ul><li>3: <a href=#pg-a5f7383c83ab9eb9cd0e3c4c020b3ae6>Contêineres</a></li><ul><li>3.1: <a href=#pg-16042b4652ad19e565c7263824029a43>Imagens</a></li><li>3.2: <a href=#pg-643212488f778acf04bebed65ba34441>Ambiente de Contêiner</a></li><li>3.3: <a href=#pg-a858027489648786a3b16264e451272b>Classes de execução</a></li><li>3.4: <a href=#pg-e6941d969d81540208a3e78bc56f43bc>Hooks de Ciclo de Vida do Contêiner</a></li></ul><li>4: <a href=#pg-275bea454e1cf4c5adeca4058b5af988>Configuração</a></li><ul><li>4.1: <a href=#pg-ab6d20f33ad930a67ee7ef57bff6c75e>Organizando o acesso ao cluster usando arquivos kubeconfig</a></li></ul><li>5: <a href=#pg-712cb3c03ff14a39e5a83a6d9b71d203>Segurança</a></li><ul><li>5.1: <a href=#pg-04eeb110d75afc8acb2cf7a3db743985>Visão Geral da Segurança Cloud Native</a></li></ul><li>6: <a href=#pg-c21d05f31057c5bcd2ebdd01f4e62a0e>Escalonamento</a></li><ul><li>6.1: <a href=#pg-598f36d691ab197f9d995784574b0a12>Escalonador do Kubernetes</a></li><li>6.2: <a href=#pg-da22fe2278df236f71efbe672f392677>Sobrecarga de Pod</a></li></ul><li>7: <a href=#pg-285a3785fd3d20f437c28d87ca4dadca>Administração de Cluster</a></li><ul><li>7.1: <a href=#pg-fb494ea3b1874bd753dcd11c3f35c2dc>Visão Geral da Administração de Cluster</a></li><li>7.2: <a href=#pg-2bf9a93ab5ba014fb6ff70b22c29d432>Certificates</a></li><li>7.3: <a href=#pg-d649067a69d8d5c7e71564b42b96909e>Conectividade do Cluster</a></li><li>7.4: <a href=#pg-c4b1e87a84441f8a90699a345ce48d68>Arquitetura de Log</a></li><li>7.5: <a href=#pg-2e05a56491965ae320c2662590b2ca18>Configurando o Garbage Collection do kubelet</a></li><li>7.6: <a href=#pg-85d633ae590aa20ec024f1b7af1d74fc>Instalando Addons</a></li></ul><li>8: <a href=#pg-7e0d97616b15e2c383c6a0a96ec442cb>Extendendo o Kubernetes</a></li><ul><li>8.1: <a href=#pg-0af41d3bd7c785621b58b7564793396a>Extendendo a API do Kubernetes</a></li><ul><li>8.1.1: <a href=#pg-1ea4977c0ebf97569bf54a477faa7fa5>Extendendo a API do Kubernetes com a camada de agregação</a></li></ul><li>8.2: <a href=#pg-c8937cdc9df96f3328becf04f8211292>Extensões de Computação, armazenamento e redes</a></li><ul><li>8.2.1: <a href=#pg-1ac2260db9ecccbf0303a899bc27ce6d>Plugins de rede</a></li></ul><li>8.3: <a href=#pg-3131452556176159fb269593c1a52012>Padrão Operador</a></li></ul></ul><div class=content><p>A seção de Conceitos irá te ajudar a aprender mais sobre as partes do ecossistema Kubernetes e as abstrações que o Kubernetes usa para representar seu <a class=glossary-tooltip title="Um conjunto de servidores de processamento, também chamados de nós, que executam aplicações containerizadas. Todo cluster possui ao menos um servidor de processamento (worker node)." data-toggle=tooltip data-placement=top href="/pt/docs/reference/glossary/?all=true#term-cluster" target=_blank aria-label=cluster>cluster</a>.</p><p>Ela irá lhe ajudar a obter um entendimento mais profundo sobre como o Kubernetes funciona.</p></div></div><div class=td-content style=page-break-before:always><h1 id=pg-0554ac387412eaf4e6e89b2f847dacde>1 - Visão Geral</h1><div class=lead>Obtenha uma visão em alto-nível do Kubernetes e dos componentes a partir dos quais ele é construído.</div></div><div class=td-content><h1 id=pg-45bdca6129cf540121623e903c18ba46>1.1 - O que é Kubernetes?</h1><div class=lead>Kubernetes é um plataforma de código aberto, portável e extensiva para o gerenciamento de cargas de trabalho e serviços distribuídos em contêineres, que facilita tanto a configuração declarativa quanto a automação. Ele possui um ecossistema grande, e de rápido crescimento. Serviços, suporte, e ferramentas para Kubernetes estão amplamente disponíveis.</div><p>Essa página é uma visão geral do Kubernetes.</p><p>Kubernetes é um plataforma de código aberto, portável e extensiva para o gerenciamento de cargas de trabalho e serviços distribuídos em contêineres, que facilita tanto a configuração declarativa quanto a automação. Ele possui um ecossistema grande, e de rápido crescimento. Serviços, suporte, e ferramentas para Kubernetes estão amplamente disponíveis.</p><p>O Google tornou Kubernetes um projeto de código-aberto em 2014. O Kubernetes combina <a href=/blog/2015/04/borg-predecessor-to-kubernetes/>mais de 15 anos de experiência do Google</a> executando cargas de trabalho produtivas em escala, com as melhores idéias e práticas da comunidade.</p><p>O nome <strong>Kubernetes</strong> tem origem no Grego, significando <em>timoneiro</em> ou <em>piloto</em>. <strong>K8s</strong> é a abreviação derivada pela troca das oito letras "ubernete" por "8", se tornado <em>K"8"s</em>.</p><h2 id=voltando-no-tempo>Voltando no tempo</h2><p>Vamos dar uma olhada no porque o Kubernetes é tão útil, voltando no tempo.</p><p><img src=/images/docs/Container_Evolution.svg alt="Evolução das implantações"></p><p><strong>Era da implantação tradicional:</strong> No início, as organizações executavam aplicações em servidores físicos. Não havia como definir limites de recursos para aplicações em um mesmo servidor físico, e isso causava problemas de alocação de recursos. Por exemplo, se várias aplicações fossem executadas em um mesmo servidor físico, poderia haver situações em que uma aplicação ocupasse a maior parte dos recursos e, como resultado, o desempenho das outras aplicações seria inferior. Uma solução para isso seria executar cada aplicação em um servidor físico diferente. Mas isso não escalava, pois os recursos eram subutilizados, e se tornava custoso para as organizações manter muitos servidores físicos.</p><p><strong>Era da implantação virtualizada:</strong> Como solução, a virtualização foi introduzida. Esse modelo permite que você execute várias máquinas virtuais (VMs) em uma única CPU de um servidor físico. A virtualização permite que as aplicações sejam isoladas entre as VMs, e ainda fornece um nível de segurança, pois as informações de uma aplicação não podem ser acessadas livremente por outras aplicações.</p><p>A virtualização permite melhor utilização de recursos em um servidor físico, e permite melhor escalabilidade porque uma aplicação pode ser adicionada ou atualizada facilmente, reduz os custos de hardware e muito mais. Com a virtualização, você pode apresentar um conjunto de recursos físicos como um cluster de máquinas virtuais descartáveis.</p><p>Cada VM é uma máquina completa que executa todos os componentes, incluindo seu próprio sistema operacional, além do hardware virtualizado.</p><p><strong>Era da implantação em contêineres:</strong> Contêineres são semelhantes às VMs, mas têm propriedades de isolamento flexibilizados para compartilhar o sistema operacional (SO) entre as aplicações. Portanto, os contêineres são considerados leves. Semelhante a uma VM, um contêiner tem seu próprio sistema de arquivos, compartilhamento de CPU, memória, espaço de processo e muito mais. Como eles estão separados da infraestrutura subjacente, eles são portáveis entre nuvens e distribuições de sistema operacional.</p><p>Contêineres se tornaram populares porque eles fornecem benefícios extra, tais como:</p><ul><li>Criação e implantação ágil de aplicações: aumento da facilidade e eficiência na criação de imagem de contêiner comparado ao uso de imagem de VM.</li><li>Desenvolvimento, integração e implantação contínuos: fornece capacidade de criação e de implantação de imagens de contêiner de forma confiável e frequente, com a funcionalidade de efetuar reversões rápidas e eficientes (devido à imutabilidade da imagem).</li><li>Separação de interesses entre Desenvolvimento e Operações: crie imagens de contêineres de aplicações no momento de construção/liberação em vez de no momento de implantação, desacoplando as aplicações da infraestrutura.</li><li>A capacidade de observação (Observabilidade) não apenas apresenta informações e métricas no nível do sistema operacional, mas também a integridade da aplicação e outros sinais.</li><li>Consistência ambiental entre desenvolvimento, teste e produção: funciona da mesma forma em um laptop e na nuvem.</li><li>Portabilidade de distribuição de nuvem e sistema operacional: executa no Ubuntu, RHEL, CoreOS, localmente, nas principais nuvens públicas e em qualquer outro lugar.</li><li>Gerenciamento centrado em aplicações: eleva o nível de abstração da execução em um sistema operacional em hardware virtualizado à execução de uma aplicação em um sistema operacional usando recursos lógicos.</li><li>Microserviços fracamente acoplados, distribuídos, elásticos e livres: as aplicações são divididas em partes menores e independentes e podem ser implantados e gerenciados dinamicamente - não uma pilha monolítica em execução em uma grande máquina de propósito único.</li><li>Isolamento de recursos: desempenho previsível de aplicações.</li><li>Utilização de recursos: alta eficiência e densidade.</li></ul><h2 id=why-you-need-kubernetes-and-what-can-it-do>Por que você precisa do Kubernetes e o que ele pode fazer</h2><p>Os contêineres são uma boa maneira de agrupar e executar suas aplicações. Em um ambiente de produção, você precisa gerenciar os contêineres que executam as aplicações e garantir que não haja tempo de inatividade. Por exemplo, se um contêiner cair, outro contêiner precisa ser iniciado. Não seria mais fácil se esse comportamento fosse controlado por um sistema?</p><p>É assim que o Kubernetes vem ao resgate! O Kubernetes oferece uma estrutura para executar sistemas distribuídos de forma resiliente. Ele cuida do escalonamento e do recuperação à falha de sua aplicação, fornece padrões de implantação e muito mais. Por exemplo, o Kubernetes pode gerenciar facilmente uma implantação no método canário para seu sistema.</p><p>O Kubernetes oferece a você:</p><ul><li><strong>Descoberta de serviço e balanceamento de carga</strong>
O Kubernetes pode expor um contêiner usando o nome DNS ou seu próprio endereço IP. Se o tráfego para um contêiner for alto, o Kubernetes pode balancear a carga e distribuir o tráfego de rede para que a implantação seja estável.</li><li><strong>Orquestração de armazenamento</strong>
O Kubernetes permite que você monte automaticamente um sistema de armazenamento de sua escolha, como armazenamentos locais, provedores de nuvem pública e muito mais.</li><li><strong>Lançamentos e reversões automatizadas</strong>
Você pode descrever o estado desejado para seus contêineres implantados usando o Kubernetes, e ele pode alterar o estado real para o estado desejado em um ritmo controlada. Por exemplo, você pode automatizar o Kubernetes para criar novos contêineres para sua implantação, remover os contêineres existentes e adotar todos os seus recursos para o novo contêiner.</li><li><strong>Empacotamento binário automático</strong>
Você fornece ao Kubernetes um cluster de nós que pode ser usado para executar tarefas nos contêineres. Você informa ao Kubernetes de quanta CPU e memória (RAM) cada contêiner precisa. O Kubernetes pode encaixar contêineres em seus nós para fazer o melhor uso de seus recursos.</li><li><strong>Autocorreção</strong>
O Kubernetes reinicia os contêineres que falham, substitui os contêineres, elimina os contêineres que não respondem à verificação de integridade definida pelo usuário e não os anuncia aos clientes até que estejam prontos para servir.</li><li><strong>Gerenciamento de configuração e de segredos</strong>
O Kubernetes permite armazenar e gerenciar informações confidenciais, como senhas, tokens OAuth e chaves SSH. Você pode implantar e atualizar segredos e configuração de aplicações sem reconstruir suas imagens de contêiner e sem expor segredos em sua pilha de configuração.</li></ul><h2 id=o-que-o-kubernetes-não-é>O que o Kubernetes não é</h2><p>O Kubernetes não é um sistema PaaS (plataforma como serviço) tradicional e completo. Como o Kubernetes opera no nível do contêiner, e não no nível do hardware, ele fornece alguns recursos geralmente aplicáveis comuns às ofertas de PaaS, como implantação, escalonamento, balanceamento de carga, e permite que os usuários integrem suas soluções de <em>logging</em>, monitoramento e alerta. No entanto, o Kubernetes não é monolítico, e essas soluções padrão são opcionais e conectáveis. O Kubernetes fornece os blocos de construção para a construção de plataformas de desenvolvimento, mas preserva a escolha e flexibilidade do usuário onde é importante.</p><p>Kubernetes:</p><ul><li>Não limita os tipos de aplicações suportadas. O Kubernetes visa oferecer suporte a uma variedade extremamente diversa de cargas de trabalho, incluindo cargas de trabalho sem estado, com estado e de processamento de dados. Se uma aplicação puder ser executada em um contêiner, ele deve ser executado perfeitamente no Kubernetes.</li><li>Não implanta código-fonte e não constrói sua aplicação. Os fluxos de trabalho de integração contínua, entrega e implantação (CI/CD) são determinados pelas culturas e preferências da organização, bem como pelos requisitos técnicos.</li><li>Não fornece serviços em nível de aplicação, tais como middleware (por exemplo, barramentos de mensagem), estruturas de processamento de dados (por exemplo, Spark), bancos de dados (por exemplo, MySQL), caches, nem sistemas de armazenamento em cluster (por exemplo, Ceph), como serviços integrados. Esses componentes podem ser executados no Kubernetes e/ou podem ser acessados por aplicações executadas no Kubernetes por meio de mecanismos portáteis, como o <a href=https://openservicebrokerapi.org/>Open Service Broker</a>.</li><li>Não dita soluções de <em>logging</em>, monitoramento ou alerta. Ele fornece algumas integrações como prova de conceito e mecanismos para coletar e exportar métricas.</li><li>Não fornece nem exige um sistema/idioma de configuração (por exemplo, Jsonnet). Ele fornece uma API declarativa que pode ser direcionada por formas arbitrárias de especificações declarativas.</li><li>Não fornece nem adota sistemas abrangentes de configuração de máquinas, manutenção, gerenciamento ou autocorreção.</li><li>Adicionalmente, o Kubernetes não é um mero sistema de orquestração. Na verdade, ele elimina a necessidade de orquestração. A definição técnica de orquestração é a execução de um fluxo de trabalho definido: primeiro faça A, depois B e depois C. Em contraste, o Kubernetes compreende um conjunto de processos de controle independentes e combináveis que conduzem continuamente o estado atual em direção ao estado desejado fornecido. Não importa como você vai de A para C. O controle centralizado também não é necessário. Isso resulta em um sistema que é mais fácil de usar e mais poderoso, robusto, resiliente e extensível.</li></ul><h2 id=what-s-next>What's next</h2><ul><li>Dê uma olhada em <a href=/docs/concepts/overview/components/>Componentes do Kubernetes</a>.</li><li>Pronto para <a href=/docs/setup/>Iniciar</a>?</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-13b0f1dbe89228e3d76d2ac231e245f1>1.2 - Componentes do Kubernetes</h1><div class=lead>Um cluster Kubernetes consiste de componentes que representam a camada de gerenciamento, e um conjunto de máquinas chamadas nós.</div><p>Ao implantar o Kubernetes, você obtém um cluster.<p><p>Um cluster Kubernetes consiste em um conjunto de servidores de processamento, chamados <a class=glossary-tooltip title="Um Nó é uma máquina de trabalho no Kubernetes." data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=nós>nós</a>, que executam aplicações containerizadas. Todo cluster possui ao menos um servidor de processamento (<em>worker node</em>).</p></p><p>O servidor de processamento hospeda os <a class=glossary-tooltip title="O menor e mais simples objeto Kubernetes. Um Pod representa um conjunto de contêineres em execução no seu cluster." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pods>Pods</a> que são componentes de uma aplicação. O <a class=glossary-tooltip title="A camada de gerenciamento de contêiner que expõe a API e as interfaces para definir, implantar e gerenciar o ciclo de vida dos contêineres." data-toggle=tooltip data-placement=top href="/pt/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label="ambiente de gerenciamento">ambiente de gerenciamento</a> gerencia os nós de processamento e os Pods no cluster. Em ambientes de produção, o ambiente de gerenciamento geralmente executa em múltiplos computadores e um cluster geralmente executa em múltiplos nós (<em>nodes</em>) , provendo tolerância a falhas e alta disponibilidade.</p></p><p>Este documento descreve os vários componentes que você precisa ter para implantar um cluster Kubernetes completo e funcional.</p><p>Esse é o diagrama de um cluster Kubernetes com todos os componentes interligados.</p><p><img src=/images/docs/components-of-kubernetes.svg alt="Componentes do Kubernetes"></p><h2 id=componentes-da-camada-de-gerenciamento>Componentes da camada de gerenciamento</h2><p>Os componentes da camada de gerenciamento tomam decisões globais sobre o cluster (por exemplo, agendamento de <em>pods</em>), bem como detectam e respondem aos eventos do cluster (por exemplo, iniciando um novo <em><a class=glossary-tooltip title="O menor e mais simples objeto Kubernetes. Um Pod representa um conjunto de contêineres em execução no seu cluster." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=pod>pod</a></em> quando o campo <code>replicas</code> de um <em>Deployment</em> não está atendido).</p><p>Os componentes da camada de gerenciamento podem ser executados em qualquer máquina do cluster. Contudo, para simplificar, os <em>scripts</em> de configuração normalmente iniciam todos os componentes da camada de gerenciamento na mesma máquina, e não executa contêineres de usuário nesta máquina. Veja <a href=/docs/admin/high-availability/>Construindo clusters de alta disponibilidade</a> para um exemplo de configuração de múltiplas VMs para camada de gerenciamento (<em>multi-main-VM</em>).</p><h3 id=kube-apiserver>kube-apiserver</h3><p>O servidor de API é um componente da <a class=glossary-tooltip title="A camada de gerenciamento de contêiner que expõe a API e as interfaces para definir, implantar e gerenciar o ciclo de vida dos contêineres." data-toggle=tooltip data-placement=top href="/pt/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label="Camada de gerenciamento">Camada de gerenciamento</a> do Kubernetes que expõe a API do Kubernetes.
O servidor de API é o <em>front end</em> para a camada de gerenciamento do Kubernetes.</p><p>A principal implementação de um servidor de API do Kubernetes é <a href=/docs/reference/generated/kube-apiserver/>kube-apiserver</a>.
O kube-apiserver foi projetado para ser escalonado horizontalmente — ou seja, ele pode ser escalado com a implantação de mais instâncias.
Você pode executar várias instâncias do kube-apiserver e balancear (balanceamento de carga, etc) o tráfego entre essas instâncias.</p><h3 id=etcd>etcd</h3><p>Armazenamento do tipo Chave-Valor consistente e em alta-disponibilidade usado como repositório de apoio do Kubernetes para todos os dados do cluster.</p><p>Se o seu cluster Kubernetes usa <strong>etcd</strong> como seu armazenamento de apoio, certifique-se de ter um plano de <a href=/docs/tasks/administer-cluster/configure-upgrade-etcd/#backing-up-an-etcd-cluster>back up</a> para seus dados.</p><p>Você pode encontrar informações detalhadas sobre o etcd na seção oficial da <a href=https://etcd.io/docs/>documentação</a>.</p><h3 id=kube-scheduler>kube-scheduler</h3><p>Componente da camada de gerenciamento que observa os <em><a class=glossary-tooltip title="O menor e mais simples objeto Kubernetes. Um Pod representa um conjunto de contêineres em execução no seu cluster." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=pods>pods</a></em> recém-criados sem nenhum <a class=glossary-tooltip title="Um Nó é uma máquina de trabalho no Kubernetes." data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=nó>nó</a> atribuído, e seleciona um nó para executá-los.</p><p>Os fatores levados em consideração para as decisões de agendamento incluem:
requisitos de recursos individuais e coletivos, hardware/software/política de restrições, especificações de afinidade e antiafinidade, localidade de dados, interferência entre cargas de trabalho, e prazos.</p><h3 id=kube-controller-manager>kube-controller-manager</h3><p>Componente da camada de gerenciamento que executa os processos de <a class=glossary-tooltip title="Um ciclo de controle que observa o estado partilhado do cluster através do API Server e efetua mudanças tentando mover o estado atual em direção ao estado desejado." data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controlador>controlador</a>.</p><p>Logicamente, cada <em><a class=glossary-tooltip title="Um ciclo de controle que observa o estado partilhado do cluster através do API Server e efetua mudanças tentando mover o estado atual em direção ao estado desejado." data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controlador>controlador</a></em> está em um processo separado, mas para reduzir a complexidade, eles todos são compilados num único binário e executam em um processo único.</p><p>Alguns tipos desses controladores são:</p><ul><li>Controlador de nó: responsável por perceber e responder quando os nós caem.</li><li>Controlador de <em>Job</em>: Observa os objetos <em>Job</em> que representam tarefas únicas e, em seguida, cria <em>pods</em> para executar essas tarefas até a conclusão.</li><li>Controlador de <em>endpoints</em>: preenche o objeto <em>Endpoints</em> (ou seja, junta os Serviços e os <em>pods</em>).</li><li>Controladores de conta de serviço e de <em>token</em>: crie contas padrão e <em>tokens</em> de acesso de API para novos <em>namespaces</em>.</li></ul><h3 id=cloud-controller-manager>cloud-controller-manager</h3>Um componente da <a class=glossary-tooltip title="A camada de gerenciamento de contêiner que expõe a API e as interfaces para definir, implantar e gerenciar o ciclo de vida dos contêineres." data-toggle=tooltip data-placement=top href="/pt/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label="camada de gerenciamento">camada de gerenciamento</a> do Kubernetes
que incorpora a lógica de controle específica da nuvem. O gerenciador de controle de nuvem permite que você vincule seu
<em>cluster</em> na API do seu provedor de nuvem, e separar os componentes que interagem com essa plataforma de nuvem a partir de componentes que apenas interagem com seu cluster.<p>O cloud-controller-manager executa apenas controladores que são específicos para seu provedor de nuvem.
Se você estiver executando o Kubernetes em suas próprias instalações ou em um ambiente de aprendizagem dentro de seu
próprio PC, o cluster não possui um gerenciador de controlador de nuvem.</p><p>Tal como acontece com o kube-controller-manager, o cloud-controller-manager combina vários ciclos de controle logicamente independentes em um binário único que você executa como um processo único. Você pode escalar horizontalmente (exectuar mais de uma cópia) para melhorar o desempenho ou para auxiliar na tolerância a falhas.</p><p>Os seguintes controladores podem ter dependências de provedor de nuvem:</p><ul><li>Controlador de nó: para verificar junto ao provedor de nuvem para determinar se um nó foi excluído da nuvem após parar de responder.</li><li>Controlador de rota: para configurar rotas na infraestrutura de nuvem subjacente.</li><li>Controlador de serviço: Para criar, atualizar e excluir balanceadores de carga do provedor de nuvem.</li></ul><h2 id=node-components>Node Components</h2><p>Os componentes de nó são executados em todos os nós, mantendo os <em>pods</em> em execução e fornecendo o ambiente de execução do Kubernetes.</p><h3 id=kubelet>kubelet</h3><p>Um agente que é executado em cada <a class=glossary-tooltip title="Um Nó é uma máquina de trabalho no Kubernetes." data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=node>node</a> no cluster. Ele garante que os <a class=glossary-tooltip title="A lightweight and portable executable image that contains software and all of its dependencies." data-toggle=tooltip data-placement=top href=/docs/concepts/containers/ target=_blank aria-label=contêineres>contêineres</a> estejam sendo executados em um <a class=glossary-tooltip title="O menor e mais simples objeto Kubernetes. Um Pod representa um conjunto de contêineres em execução no seu cluster." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>.</p><p>O kubelet utiliza um conjunto de PodSpecs que são fornecidos por vários mecanismos e garante que os contêineres descritos nesses PodSpecs estejam funcionando corretamente. O kubelet não gerencia contêineres que não foram criados pelo Kubernetes.</p><h3 id=kube-proxy>kube-proxy</h3><p>kube-proxy é um <em>proxy</em> de rede executado em cada <a class=glossary-tooltip title="Um Nó é uma máquina de trabalho no Kubernetes." data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=nó>nó</a> no seu <em>cluster</em>,
implementando parte do conceito de <a class=glossary-tooltip title="A way to expose an application running on a set of Pods as a network service." data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label=serviço>serviço</a> do Kubernetes.</p><p><a href=/docs/reference/command-line-tools-reference/kube-proxy/>kube-proxy</a>
mantém regras de rede nos nós. Estas regras de rede permitem a comunicação de rede com seus <em>pods</em> a partir de sessões de rede dentro ou fora de seu <em>cluster</em>.</p><p>kube-proxy usa a camada de filtragem de pacotes do sistema operacional se houver uma e estiver disponível. Caso contrário, o kube-proxy encaminha o tráfego ele mesmo.</p><h3 id=container-runtime>Container runtime</h3><p>O agente de execução (<em>runtime</em>) de contêiner é o software responsável por executar os contêineres.</p><p>O Kubernetes suporta diversos agentes de execução de contêineres: <a class=glossary-tooltip title="Docker is a software technology providing operating-system-level virtualization also known as containers." data-toggle=tooltip data-placement=top href=https://docs.docker.com/engine/ target=_blank aria-label=Docker>Docker</a>, <a class=glossary-tooltip title="Um agente de execução de contêiner com enfase em simplicidade, robustez e portabilidade" data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a>, <a class=glossary-tooltip title="Um agente de execução leve de contêineres criado especificamente para o Kubernetes" data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a>, e qualquer implementação do <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>Kubernetes CRI (Container Runtime Interface)</a>.</p><h2 id=addons>Addons</h2><p>Complementos (<em>addons</em>) usam recursos do Kubernetes (<a class=glossary-tooltip title="Ensures a copy of a Pod is running across a set of nodes in a cluster." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a>, <a class=glossary-tooltip title="Manages a replicated application on your cluster." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>, etc) para implementar funcionalidades do cluster. Como fornecem funcionalidades em nível do cluster, recursos de <em>addons</em> que necessitem ser criados dentro de um <em>namespace</em> pertencem ao <em>namespace</em> <code>kube-system</code>.</p><p>Alguns <em>addons</em> selecionados são descritos abaixo; para uma lista estendida dos <em>addons</em> disponíveis, por favor consulte <a href=/docs/concepts/cluster-administration/addons/>Addons</a>.</p><h3 id=dns>DNS</h3><p>Embora os outros complementos não sejam estritamente necessários, todos os clusters do Kubernetes devem ter um <a href=/docs/concepts/services-networking/dns-pod-service/>DNS do cluster</a>, já que muitos exemplos dependem disso.</p><p>O DNS do cluster é um servidor DNS, além de outros servidores DNS em seu ambiente, que fornece registros DNS para serviços do Kubernetes.</p><p>Os contêineres iniciados pelo Kubernetes incluem automaticamente esse servidor DNS em suas pesquisas DNS.</p><h3 id=web-ui-dashboard>Web UI (Dashboard)</h3><p><a href=/docs/tasks/access-application-cluster/web-ui-dashboard/>Dashboard</a> é uma interface de usuário Web, de uso geral, para clusters do Kubernetes. Ele permite que os usuários gerenciem e solucionem problemas de aplicações em execução no cluster, bem como o próprio cluster.</p><h3 id=monitoramento-de-recursos-do-contêiner>Monitoramento de recursos do contêiner</h3><p><a href=/docs/tasks/debug-application-cluster/resource-usage-monitoring/>Monitoramento de recursos do contêiner</a> registra métricas de série temporal genéricas sobre os contêineres em um banco de dados central e fornece uma interface de usuário para navegar por esses dados.</p><h3 id=logging-a-nivel-do-cluster>Logging a nivel do cluster</h3><p>Um mecanismo de <a href=/docs/concepts/cluster-administration/logging/><em>logging</em> a nível do cluster</a> é responsável por guardar os <em>logs</em> dos contêineres em um armazenamento central de <em>logs</em> com um interface para navegação/pesquisa.</p><h2 id=what-s-next>What's next</h2><ul><li>Aprenda sobre <a href=/docs/concepts/architecture/nodes/>Nós</a>.</li><li>Aprenda sobre <a href=/docs/concepts/architecture/controller/>Controladores</a>.</li><li>Aprenda sobre <a href=/docs/concepts/scheduling-eviction/kube-scheduler/>kube-scheduler</a>.</li><li>Leia a <a href=https://etcd.io/docs/>documentação</a> oficial do <strong>etcd</strong>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-110f33530cf761140cb1dab536baef04>1.3 - Objetos do Kubernetes</h1></div><div class=td-content><h1 id=pg-f37749a83c2916b63279ea60f3cfe53e>1.3.1 - Nomes</h1><p>Cada objeto em um cluster possui um Nome que é único para aquele tipo de recurso.
Todo objeto do Kubernetes também possui um UID que é único para todo o cluster.</p><p>Por exemplo, você pode ter apenas um Pod chamado "myapp-1234", porém você pode ter um Pod
e um Deployment ambos com o nome "myapp-1234".</p><p>Para atributos não únicos providenciados por usuário, Kubernetes providencia <a href=/docs/concepts/overview/working-with-objects/labels/>labels</a> e <a href=/docs/concepts/overview/working-with-objects/annotations/>annotations</a>.</p><h2 id=nomes>Nomes</h2><p>Recursos Kubernetes podem ter nomes com até 253 caracteres. Os caracteres permitidos em nomes são: dígitos (0-9), letras minúsculas (a-z), <code>-</code>, e <code>.</code>.</p><p>A seguir, um exemplo para um Pod chamado <code>nginx-demo</code>.</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.7.9<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div><blockquote class="note callout"><div><strong>Note:</strong> Alguns tipos de recursos possuem restrições adicionais em seus nomes.</div></blockquote><h2 id=uids>UIDs</h2><p>Kubernetes UIDs são identificadores únicos universais (também chamados de UUIDs).
UUIDs utilizam padrões ISO/IEC 9834-8 e ITU-T X.667.</p><h2 id=what-s-next>What's next</h2><ul><li>Leia sobre <a href=/docs/concepts/overview/working-with-objects/labels/>labels</a> em Kubernetes.</li><li>Consulte o documento de design <a href=https://git.k8s.io/community/contributors/design-proposals/architecture/identifiers.md>Identificadores e Nomes em Kubernetes</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-2bf36ccd6b3dbeafecf87c39761b07c7>2 - Arquitetura do Kubernetes</h1></div><div class=td-content><h1 id=pg-c0251def6da29b30afebfb04549f1703>2.1 - Comunicação entre Nó e Control Plane</h1><p>Este documento cataloga os caminhos de comunicação entre o control plane (o
apiserver) e o cluster Kubernetes. A intenção é permitir que os usuários
personalizem sua instalação para proteger a configuração de rede
então o cluster pode ser executado em uma rede não confiável (ou em IPs totalmente públicos em um
provedor de nuvem).</p><h2 id=nó-para-o-control-plane>Nó para o Control Plane</h2><p>Todos os caminhos de comunicação do cluster para o control plane terminam no
apiserver (nenhum dos outros componentes do control plane são projetados para expor
Serviços remotos). Em uma implantação típica, o apiserver é configurado para escutar
conexões remotas em uma porta HTTPS segura (443) com uma ou mais clientes <a href=/docs/reference/access-authn-authz/authentication/>autenticação</a> habilitado.
Uma ou mais formas de <a href=/docs/reference/access-authn-authz/authorization/>autorização</a>
deve ser habilitado, especialmente se <a href=/docs/reference/access-authn-authz/authentication/#anonymous-requests>requisições anônimas</a>
ou <a href=/docs/reference/access-authn-authz/authentication/#service-account-tokens>tokens da conta de serviço</a>
são autorizados.</p><p>Os nós devem ser provisionados com o certificado root público para o cluster
de tal forma que eles podem se conectar de forma segura ao apiserver junto com o cliente válido
credenciais. Por exemplo, em uma implantação padrão do GKE, as credenciais do cliente
fornecidos para o kubelet estão na forma de um certificado de cliente. Vejo
<a href=/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>bootstrapping TLS do kubelet</a>
para provisionamento automatizado de certificados de cliente kubelet.</p><p>Os pods que desejam se conectar ao apiserver podem fazê-lo com segurança, aproveitando
conta de serviço para que o Kubernetes injetará automaticamente o certificado raiz público
certificado e um token de portador válido no pod quando ele é instanciado.
O serviço <code>kubernetes</code> (no namespace <code>default</code>) é configurado com um IP virtual
endereço que é redirecionado (via kube-proxy) para o endpoint com HTTPS no
apiserver.</p><p>Os componentes do control plane também se comunicam com o apiserver do cluster através da porta segura.</p><p>Como resultado, o modo de operação padrão para conexões do cluster
(nodes e pods em execução nos Nodes) para o control plane é protegido por padrão
e pode passar por redes não confiáveis ​​e/ou públicas.</p><h2 id=control-plane-para-o-nó>Control Plane para o nó</h2><p>Existem dois caminhos de comunicação primários do control plane (apiserver) para os nós.
O primeiro é do apiserver para o processo do kubelet que é executado em
cada nó no cluster. O segundo é do apiserver para qualquer nó, pod,
ou serviço através da funcionalidade de proxy do apiserver.</p><h3 id=apiserver-para-o-kubelet>apiserver para o kubelet</h3><p>As conexões do apiserver ao kubelet são usadas para:</p><ul><li>Buscar logs para pods.</li><li>Anexar (através de kubectl) pods em execução.</li><li>Fornecer a funcionalidade de encaminhamento de porta do kubelet.</li></ul><p>Essas conexões terminam no endpoint HTTPS do kubelet. Por padrão,
o apiserver não verifica o certificado de serviço do kubelet,
o que torna a conexão sujeita a ataques man-in-the-middle, o que o torna
<strong>inseguro</strong> para passar por redes não confiáveis ​​e / ou públicas.</p><p>Para verificar essa conexão, use a flag <code>--kubelet-certificate-authority</code> para
fornecer o apiserver com um pacote de certificado raiz para usar e verificar o
certificado de serviço da kubelet.</p><p>Se isso não for possível, use o <a href=/docs/concepts/architecture/master-node-communication/#ssh-tunnels>SSH túnel</a>
entre o apiserver e kubelet se necessário para evitar a conexão ao longo de um
rede não confiável ou pública.</p><p>Finalmente, <a href=/docs/admin/kubelet-authentication-authorization/>Autenticação e/ou autorização do Kubelet</a>
deve ser ativado para proteger a API do kubelet.</p><h3 id=apiserver-para-nós-pods-e-serviços>apiserver para nós, pods e serviços</h3><p>As conexões a partir do apiserver para um nó, pod ou serviço padrão para simples
conexões HTTP não são autenticadas nem criptografadas. Eles
podem ser executados em uma conexão HTTPS segura prefixando <code>https:</code> no nó,
pod, ou nome do serviço no URL da API, mas eles não validarão o certificado
fornecido pelo ponto de extremidade HTTPS, nem fornece credenciais de cliente, enquanto
a conexão será criptografada, não fornecerá nenhuma garantia de integridade.
Estas conexões <strong>não são atualmente seguras</strong> para serem usados por redes não confiáveis ​​e/ou públicas.</p><h3 id=ssh-túnel>SSH Túnel</h3><p>O Kubernetes suporta túneis SSH para proteger os caminhos de comunicação do control plane para os nós. Nesta configuração, o apiserver inicia um túnel SSH para cada nó
no cluster (conectando ao servidor ssh escutando na porta 22) e passa
todo o tráfego destinado a um kubelet, nó, pod ou serviço através do túnel.
Este túnel garante que o tráfego não seja exposto fora da rede aos quais
os nós estão sendo executados.</p><p>Atualmente, os túneis SSH estão obsoletos, portanto, você não deve optar por usá-los, a menos que saiba o que está fazendo. O serviço Konnectivity é um substituto para este canal de comunicação.</p><h3 id=konnectivity-service>Konnectivity service</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code></div><p>Como uma substituição aos túneis SSH, o serviço Konnectivity fornece proxy de nível TCP para a comunicação do control plane para o cluster. O serviço Konnectivity consiste em duas partes: o servidor Konnectivity na rede control plane e os agentes Konnectivity na rede dos nós. Os agentes Konnectivity iniciam conexões com o servidor Konnectivity e mantêm as conexões de rede. Depois de habilitar o serviço Konnectivity, todo o tráfego do control plane para os nós passa por essas conexões.</p><p>Veja a <a href=docs/tasks/extend-kubernetes/setup-konnectivity/>tarefa do Konnectivity</a> para configurar o serviço Konnectivity no seu cluster.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-bc804b02614d67025b4c788f1ca87fbc>2.2 - Conceitos sobre Cloud Controller Manager</h1><p>O conceito do Cloud Controller Manager (CCM) (não confundir com o binário) foi originalmente criado para permitir que o código específico de provedor de nuvem e o núcleo do Kubernetes evoluíssem independentemente um do outro. O Cloud Controller Manager é executado junto com outros componentes principais, como o Kubernetes controller manager, o servidor de API e o scheduler. Também pode ser iniciado como um addon do Kubernetes, caso em que é executado em cima do Kubernetes.</p><p>O design do Cloud Controller Manager é baseado em um mecanismo de plug-in que permite que novos provedores de nuvem se integrem facilmente ao Kubernetes usando plug-ins. Existem planos para integrar novos provedores de nuvem no Kubernetes e para migrar provedores de nuvem que estão utilizando o modelo antigo para o novo modelo de CCM.</p><p>Este documento discute os conceitos por trás do Cloud Controller Manager e fornece detalhes sobre suas funções associadas.</p><p>Aqui está a arquitetura de um cluster Kubernetes sem o Cloud Controller Manager:</p><p><img src=/images/docs/pre-ccm-arch.png alt="Pre CCM Kube Arch"></p><h2 id=projeto-de-arquitetura-design>Projeto de Arquitetura (Design)</h2><p>No diagrama anterior, o Kubernetes e o provedor de nuvem são integrados através de vários componentes diferentes:</p><ul><li>Kubelet</li><li>Kubernetes controller manager</li><li>Kubernetes API server</li></ul><p>O CCM consolida toda a lógica que depende da nuvem dos três componentes anteriores para criar um único ponto de integração com a nuvem. A nova arquitetura com o CCM se parece com isso:</p><p><img src=/images/docs/post-ccm-arch.png alt="CCM Kube Arch"></p><h2 id=componentes-do-ccm>Componentes do CCM</h2><p>O CCM separa algumas das funcionalidades do KCM (Kubernetes Controller Manager) e o executa como um processo separado. Especificamente, isso elimina os controladores no KCM que dependem da nuvem. O KCM tem os seguintes loops de controlador dependentes de nuvem:</p><ul><li>Node controller</li><li>Volume controller</li><li>Route controller</li><li>Service controller</li></ul><p>Na versão 1.9, o CCM executa os seguintes controladores da lista anterior:</p><ul><li>Node controller</li><li>Route controller</li><li>Service controller</li></ul><blockquote class="note callout"><div><strong>Note:</strong> O Volume Controller foi deliberadamente escolhido para não fazer parte do CCM. Devido à complexidade envolvida e devido aos esforços existentes para abstrair a lógica de volume específica do fornecedor, foi decidido que o Volume Controller não será movido para o CCM.</div></blockquote><p>O plano original para suportar volumes usando o CCM era usar volumes Flex para suportar volumes plugáveis. No entanto, um esforço concorrente conhecido como CSI está sendo planejado para substituir o Flex.</p><p>Considerando essas dinâmicas, decidimos ter uma medida de intervalo intermediário até que o CSI esteja pronto.</p><h2 id=funções-do-ccm>Funções do CCM</h2><p>O CCM herda suas funções de componentes do Kubernetes que são dependentes de um provedor de nuvem. Esta seção é estruturada com base nesses componentes.</p><h3 id=1-kubernetes-controller-manager>1. Kubernetes Controller Manager</h3><p>A maioria das funções do CCM é derivada do KCM. Conforme mencionado na seção anterior, o CCM executa os seguintes ciclos de controle:</p><ul><li>Node Controller</li><li>Route Controller</li><li>Service Controller</li></ul><h4 id=node-controller>Node Controller</h4><p>O Node Controller é responsável por inicializar um nó obtendo informações sobre os nós em execução no cluster do provedor de nuvem. O Node Controller executa as seguintes funções:</p><ol><li>Inicializar um node com labels de região/zona específicos para a nuvem.</li><li>Inicialize um node com detalhes de instância específicos da nuvem, por exemplo, tipo e tamanho.</li><li>Obtenha os endereços de rede e o nome do host do node.</li><li>No caso de um node não responder, verifique a nuvem para ver se o node foi excluído da nuvem.
Se o node foi excluído da nuvem, exclua o objeto Node do Kubernetes.</li></ol><h4 id=route-controller>Route Controller</h4><p>O Route Controller é responsável por configurar as rotas na nuvem apropriadamente, de modo que os contêineres em diferentes nodes no cluster do Kubernetes possam se comunicar entre si. O Route Controller é aplicável apenas para clusters do Google Compute Engine.</p><h4 id=service-controller>Service controller</h4><p>O Service controller é responsável por ouvir os eventos de criação, atualização e exclusão do serviço. Com base no estado atual dos serviços no Kubernetes, ele configura os balanceadores de carga da nuvem (como o ELB, o Google LB ou o Oracle Cloud Infrastrucutre LB) para refletir o estado dos serviços no Kubernetes. Além disso, garante que os back-ends de serviço para balanceadores de carga da nuvem estejam atualizados.</p><h3 id=2-kubelet>2. Kubelet</h3><p>O Node Controller contém a funcionalidade dependente da nuvem do kubelet. Antes da introdução do CCM, o kubelet era responsável por inicializar um nó com detalhes específicos da nuvem, como endereços IP, rótulos de região / zona e informações de tipo de instância. A introdução do CCM mudou esta operação de inicialização do kubelet para o CCM.</p><p>Nesse novo modelo, o kubelet inicializa um nó sem informações específicas da nuvem. No entanto, ele adiciona uma marca (taint) ao nó recém-criado que torna o nó não programável até que o CCM inicialize o nó com informações específicas da nuvem. Em seguida, remove essa mancha (taint).</p><h2 id=mecanismo-de-plugins>Mecanismo de plugins</h2><p>O Cloud Controller Manager usa interfaces Go para permitir implementações de qualquer nuvem a ser conectada. Especificamente, ele usa a Interface CloudProvider definida<a href=https://github.com/kubernetes/cloud-provider/blob/9b77dc1c384685cb732b3025ed5689dd597a5971/cloud.go#L42-L62>aqui</a>.</p><p>A implementação dos quatro controladores compartilhados destacados acima, e algumas estruturas que ficam junto com a interface compartilhada do provedor de nuvem, permanecerão no núcleo do Kubernetes. Implementações específicas para provedores de nuvem serão construídas fora do núcleo e implementarão interfaces definidas no núcleo.</p><p>Para obter mais informações sobre o desenvolvimento de plug-ins, consulte<a href=/docs/tasks/administer-cluster/developing-cloud-controller-manager/>Desenvolvendo o Cloud Controller Manager</a>.</p><h2 id=autorização>Autorização</h2><p>Esta seção divide o acesso necessário em vários objetos da API pelo CCM para executar suas operações.</p><h3 id=node-controller-1>Node Controller</h3><p>O Node Controller só funciona com objetos Node. Ele requer acesso total para obter, listar, criar, atualizar, corrigir, assistir e excluir objetos Node.</p><p>v1/Node:</p><ul><li>Get</li><li>List</li><li>Create</li><li>Update</li><li>Patch</li><li>Watch</li><li>Delete</li></ul><h3 id=rote-controller>Rote Controller</h3><p>O Rote Controller escuta a criação do objeto Node e configura as rotas apropriadamente. Isso requer acesso a objetos Node.</p><p>v1/Node:</p><ul><li>Get</li></ul><h3 id=service-controller-1>Service Controller</h3><p>O Service Controller escuta eventos de criação, atualização e exclusão de objeto de serviço e, em seguida, configura pontos de extremidade para esses serviços de forma apropriada.</p><p>Para acessar os Serviços, é necessário listar e monitorar o acesso. Para atualizar os Serviços, ele requer patch e atualização de acesso.</p><p>Para configurar endpoints para os Serviços, é necessário acesso para criar, listar, obter, assistir e atualizar.</p><p>v1/Service:</p><ul><li>List</li><li>Get</li><li>Watch</li><li>Patch</li><li>Update</li></ul><h3 id=outros>Outros</h3><p>A implementação do núcleo do CCM requer acesso para criar eventos e, para garantir a operação segura, requer acesso para criar ServiceAccounts.</p><p>v1/Event:</p><ul><li>Create</li><li>Patch</li><li>Update</li></ul><p>v1/ServiceAccount:</p><ul><li>Create</li></ul><p>O RBAC ClusterRole para o CCM se parece com isso:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- events<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- nodes<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- nodes/status<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- services<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- serviceaccounts<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- persistentvolumes<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- endpoints<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></code></pre></div><h2 id=implementações-de-provedores-de-nuvem>Implementações de Provedores de Nuvem</h2><p>Os seguintes provedores de nuvem implementaram CCMs:</p><ul><li><a href=https://github.com/digitalocean/digitalocean-cloud-controller-manager>Digital Ocean</a></li><li><a href=https://github.com/oracle/oci-cloud-controller-manager>Oracle</a></li><li><a href=https://github.com/kubernetes/cloud-provider-azure>Azure</a></li><li><a href=https://github.com/kubernetes/cloud-provider-gcp>GCP</a></li><li><a href=https://github.com/kubernetes/cloud-provider-aws>AWS</a></li><li><a href=https://github.com/baidu/cloud-provider-baiducloud>BaiduCloud</a></li><li><a href=https://github.com/linode/linode-cloud-controller-manager>Linode</a></li></ul><h2 id=administração-de-cluster>Administração de Cluster</h2><p>Voce vai encontrar instruções completas para configurar e executar o CCM
<a href=/docs/tasks/administer-cluster/running-cloud-controller/#cloud-controller-manager>aqui</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-ca8819042a505291540e831283da66df>2.3 - Controladores</h1><p>Em robótica e automação um <em>control loop</em>, ou em português <em>ciclo de controle</em>, é
um ciclo não terminado que regula o estado de um sistema.</p><p>Um exemplo de ciclo de controle é um termostato de uma sala.</p><p>Quando você define a temperatura, isso indica ao termostato
sobre o seu <em>estado desejado</em>. A temperatura ambiente real é o
<em>estado atual</em>. O termostato atua de forma a trazer o estado atual
mais perto do estado desejado, ligando ou desligando o equipamento.</p>No Kubernetes, controladores são ciclos de controle que observam o estado do seu
<a class=glossary-tooltip title="Um conjunto de servidores de processamento, também chamados de nós, que executam aplicações containerizadas. Todo cluster possui ao menos um servidor de processamento (worker node)." data-toggle=tooltip data-placement=top href="/pt/docs/reference/glossary/?all=true#term-cluster" target=_blank aria-label=cluster>cluster</a>, e então fazer ou requisitar
mudanças onde necessário.
Cada controlador tenta mover o estado atual do cluster mais perto do estado desejado.<h2 id=padrão-controlador-controller-pattern>Padrão Controlador (Controller pattern)</h2><p>Um controlador rastreia pelo menos um tipo de recurso Kubernetes.
Estes <a href=/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects>objetos</a>
têm um campo <em>spec</em> que representa o <em>estado desejado</em>.
O(s) controlador(es) para aquele recurso são responsáveis por trazer o <em>estado atual</em>
mais perto do <em>estado desejado</em>.</p><p>O controlador pode executar uma ação ele próprio, ou,
o que é mais comum, no Kubernetes, o controlador envia uma mensagem para o
<a class=glossary-tooltip title="O componente da camada de gerenciamento que serve a API do Kubernetes." data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label="API server">API server</a> (servidor de API) que tem
efeitos colaterais úteis. Você vai ver exemplos disto abaixo.</p><h3 id=controlador-via-api-server>Controlador via API server</h3><p>O controlador <a class=glossary-tooltip title="A finite or batch task that runs to completion." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Job>Job</a> é um exemplo de um
controlador Kubernetes embutido. Controladores embutidos gerem estados através da
interação com o <em>cluster API server</em>.</p><p><em>Job</em> é um recurso do Kubernetes que é executado em um
<em><a class=glossary-tooltip title="O menor e mais simples objeto Kubernetes. Um Pod representa um conjunto de contêineres em execução no seu cluster." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a></em>, ou talvez vários <em>Pods</em>, com o objetivo de
executar uma tarefa e depois parar.</p><p>(Uma vez <a href=/docs/concepts/scheduling/>agendado</a>, objetos <em>Pod</em> passam a fazer parte
do <em>estado desejado</em> para um kubelet.</p><p>Quando o controlador <em>Job</em> observa uma nova tarefa ele garante que,
algures no seu <em>cluster</em>, os kubelets num conjunto de nós (<em>Nodes</em>) estão correndo o número
correto de <em>Pods</em> para completar o trabalho.
O controlador <em>Job</em> não corre <em>Pods</em> ou <em>containers</em> ele próprio.
Em vez disso, o controlador <em>Job</em> informa o <em>API server</em> para criar ou remover <em>Pods</em>.
Outros componentes do plano de controle
(<a class=glossary-tooltip title="A camada de gerenciamento de contêiner que expõe a API e as interfaces para definir, implantar e gerenciar o ciclo de vida dos contêineres." data-toggle=tooltip data-placement=top href="/pt/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label="control plane">control plane</a>)
atuam na nova informação (existem novos <em>Pods</em> para serem agendados e executados),
e eventualmente o trabalho é feito.</p><p>Após ter criado um novo <em>Job</em>, o <em>estado desejado</em> é que esse Job seja completado.
O controlador <em>Job</em> faz com que o <em>estado atual</em> para esse <em>Job</em> esteja mais perto do seu
<em>estado desejado</em>: criando <em>Pods</em> que fazem o trabalho desejado para esse <em>Job</em> para que
o <em>Job</em> fique mais perto de ser completado.</p><p>Controladores também atualizam os objetos que os configuram.
Por exemplo: assim que o trabalho de um <em>Job</em> está completo,
o controlador <em>Job</em> atualiza esse objeto <em>Job</em> para o marcar como <code>Finished</code> (terminado).</p><p>(Isto é um pouco como alguns termostatos desligam uma luz para
indicar que a temperatura da sala está agora na temperatura que foi introduzida).</p><h3 id=controle-direto>Controle direto</h3><p>Em contraste com <em>Job</em>, alguns controladores necessitam de efetuar
mudanças fora do <em>cluster</em>.</p><p>Por exemplo, se usar um ciclo de controle para garantir que existem
<em><a class=glossary-tooltip title="Um Nó é uma máquina de trabalho no Kubernetes." data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=Nodes>Nodes</a></em> suficientes
no seu <em>cluster</em>, então esse controlador necessita de algo exterior ao
<em>cluster</em> atual para configurar novos <em>Nodes</em> quando necessário.</p><p>Controladores que interagem com estados externos encontram o seu estado desejado
a partir do <em>API server</em>, e então comunicam diretamente com o sistema externo para
trazer o <em>estado atual</em> mais próximo do desejado.</p><p>(Existe um controlador que escala horizontalmente nós no seu <em>cluster</em>.
Veja <a href=/docs/tasks/administer-cluster/cluster-management/#cluster-autoscaling>Escalamento automático do cluster</a>)</p><h2 id=desired-vs-current>Estado desejado versus atual</h2><p>Kubernetes tem uma visão <em>cloud-native</em> de sistemas e é capaz de manipular
mudanças constantes.</p><p>O seu <em>cluster</em> pode mudar em qualquer momento à medida que as ações acontecem e
os ciclos de controle corrigem falhas automaticamente. Isto significa que,
potencialmente, o seu <em>cluster</em> nunca atinge um estado estável.</p><p>Enquanto os controladores no seu <em>cluster</em> estiverem rodando e forem capazes de
fazer alterações úteis, não importa se o estado é estável ou se é instável.</p><h2 id=design>Design</h2><p>Como um princípio do seu desenho, o Kubernetes usa muitos controladores onde cada
um gerencia um aspecto particular do estado do <em>cluster</em>. Comumente, um particular
ciclo de controle (controlador) usa uma espécie de recurso como o seu <em>estado desejado</em>,
e tem uma espécie diferente de recurso que o mesmo gere para garantir que esse <em>estado desejado</em>
é cumprido.</p><p>É útil que haja controladores simples em vez de um conjunto monolítico de ciclos de controle
que estão interligados. Controladores podem falhar, então o Kubernetes foi desenhado para
permitir isso.</p><p>Por exemplo: um controlador de <em>Jobs</em> rastreia objetos <em>Job</em> (para
descobrir novos trabalhos) e objetos <em>Pod</em> (para correr o <em>Jobs</em>, e então
ver quando o trabalho termina). Neste caso outra coisa cria os <em>Jobs</em>,
enquanto o controlador <em>Job</em> cria <em>Pods</em>.</p><blockquote class="note callout"><div><strong>Note:</strong><p>Podem existir vários controladores que criam ou atualizam a mesma espécie (kind) de objeto.
Atrás das cortinas, os controladores do Kubernetes garantem que eles apenas tomam
atenção aos recursos ligados aos seus recursos controladores.</p><p>Por exemplo, você pode ter <em>Deployments</em> e <em>Jobs</em>; ambos criam <em>Pods</em>.
O controlador de <em>Job</em> não apaga os <em>Pods</em> que o seu <em>Deployment</em> criou,
porque existe informação (<a class=glossary-tooltip title="Tags objects with identifying attributes that are meaningful and relevant to users." data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=labels>labels</a>)
que os controladores podem usar para diferenciar esses <em>Pods</em>.</p></div></blockquote><h2 id=running-controllers>Formas de rodar controladores</h2><p>O Kubernetes vem com um conjunto de controladores embutidos que correm
dentro do <a class=glossary-tooltip title="Componente da camada de gerenciamento que executa os processos de controle." data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>.
Estes controladores embutidos providenciam comportamentos centrais importantes.</p><p>O controlador <em>Deployment</em> e o controlador <em>Job</em> são exemplos de controladores
que veem como parte do próprio Kubernetes (controladores "embutidos").
O Kubernetes deixa você correr o plano de controle resiliente, para que se qualquer
um dos controladores embutidos falhar, outra parte do plano de controle assume
o trabalho.</p><p>Pode encontrar controladores fora do plano de controle, para extender o Kubernetes.
Ou, se quiser, pode escrever um novo controlador você mesmo.
Pode correr o seu próprio controlador como um conjunto de <em>Pods</em>,
ou externo ao Kubernetes. O que encaixa melhor vai depender no que esse
controlador faz em particular.</p><h2 id=what-s-next>What's next</h2><ul><li>Leia mais sobre o <a href=/docs/concepts/#kubernetes-control-plane>plano de controle do Kubernetes</a></li><li>Descubra alguns dos <a href=/docs/concepts/#kubernetes-objects>objetos Kubernetes</a> básicos.</li><li>Aprenda mais sobre <a href=/docs/concepts/overview/kubernetes-api/>API do Kubernetes</a></li><li>Se pretender escrever o seu próprio controlador, veja <a href=/docs/concepts/extend-kubernetes/extend-cluster/#extension-patterns>Padrões de Extensão</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-a5f7383c83ab9eb9cd0e3c4c020b3ae6>3 - Contêineres</h1><div class=lead>Tecnologia para empacotar aplicações com suas dependências em tempo de execução</div><p>Cada contêiner executado é repetível; a padronização de ter
dependências incluídas significa que você obtém o mesmo comportamento onde quer que você execute.</p><p>Os contêineres separam os aplicativos da infraestrutura de <em>host</em> subjacente.
Isso torna a implantação mais fácil em diferentes ambientes de nuvem ou sistema operacional.</p><h2 id=imagem-de-contêiner>Imagem de contêiner</h2><p>Uma <a href=/docs/concepts/containers/images/>imagem de contêiner</a> é um pacote de software pronto para executar, contendo tudo que é preciso para executar uma aplicação:
o código e o agente de execução necessário, aplicação, bibliotecas do sistema e valores padrões para qualquer configuração essencial.</p><p>Por <em>design</em>, um contêiner é imutável: você não pode mudar o código de um contêiner que já está executando. Se você tem uma aplicação conteinerizada e quer fazer mudanças, você precisa construir uma nova imagem que inclui a mudança, e recriar o contêiner para iniciar a partir da imagem atualizada.</p><h2 id=agente-de-execução-de-contêiner>Agente de execução de contêiner</h2><p>O agente de execução (<em>runtime</em>) de contêiner é o software responsável por executar os contêineres.</p><p>O Kubernetes suporta diversos agentes de execução de contêineres: <a class=glossary-tooltip title="Docker is a software technology providing operating-system-level virtualization also known as containers." data-toggle=tooltip data-placement=top href=https://docs.docker.com/engine/ target=_blank aria-label=Docker>Docker</a>, <a class=glossary-tooltip title="Um agente de execução de contêiner com enfase em simplicidade, robustez e portabilidade" data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a>, <a class=glossary-tooltip title="Um agente de execução leve de contêineres criado especificamente para o Kubernetes" data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a>, e qualquer implementação do <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>Kubernetes CRI (Container Runtime Interface)</a>.</p><h2 id=what-s-next>What's next</h2><ul><li><a href=/docs/concepts/containers/images/>Imagens de contêineres</a></li><li><a href=/docs/concepts/workloads/pods/>Pods</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-16042b4652ad19e565c7263824029a43>3.1 - Imagens</h1><p>Uma imagem de contêiner representa dados binários que encapsulam uma aplicação e todas as suas dependências de software. As imagens de contêiner são pacotes de software executáveis que podem ser executados de forma autônoma e que fazem suposições muito bem definidas sobre seu agente de execução do ambiente.</p><p>Normalmente, você cria uma imagem de contêiner da sua aplicação e a envia para um registro antes de fazer referência a ela em um <a class=glossary-tooltip title="O menor e mais simples objeto Kubernetes. Um Pod representa um conjunto de contêineres em execução no seu cluster." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a></p><p>Esta página fornece um resumo sobre o conceito de imagem de contêiner.</p><h2 id=nomes-das-imagens>Nomes das imagens</h2><p>As imagens de contêiner geralmente recebem um nome como <code>pause</code>, <code>exemplo/meuconteiner</code>, ou <code>kube-apiserver</code>.
As imagens também podem incluir um hostname de algum registro; por exemplo: <code>exemplo.registro.ficticio/nomeimagem</code>,
e um possível número de porta; por exemplo: <code>exemplo.registro.ficticio:10443/nomeimagem</code>.</p><p>Se você não especificar um hostname de registro, o Kubernetes presumirá que você se refere ao registro público do Docker.</p><p>Após a parte do nome da imagem, você pode adicionar uma <em>tag</em> (como também usar com comandos como <code>docker</code> e<code> podman</code>).
As tags permitem identificar diferentes versões da mesma série de imagens.</p><p>Tags de imagem consistem em letras maiúsculas e minúsculas, dígitos, sublinhados (<code>_</code>),
pontos (<code>.</code>) e travessões (<code> -</code>).
Existem regras adicionais sobre onde você pode colocar o separador
caracteres (<code>_</code>,<code>-</code> e <code>.</code>) dentro de uma tag de imagem.
Se você não especificar uma tag, o Kubernetes presumirá que você se refere à tag <code>latest</code> (mais recente).</p><blockquote class="caution callout"><div><strong>Caution:</strong><p>Você deve evitar usar a tag <code>latest</code> quando estiver realizando o deploy de contêineres em produção,
pois é mais difícil rastrear qual versão da imagem está sendo executada, além de tornar mais difícil o processo de reversão para uma versão funcional.</p><p>Em vez disso, especifique uma tag significativa, como <code>v1.42.0</code>.</p></div></blockquote><h2 id=atualizando-imagens>Atualizando imagens</h2><p>A política padrão de pull é <code>IfNotPresent</code> a qual faz com que o
<a class=glossary-tooltip title="Um agente que é executado em cada node no cluster. Ele garante que os contêineres estejam sendo executados em um pod." data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a> ignore
o processo de <em>pull</em> da imagem, caso a mesma já exista. Se você prefere sempre forçar o processo de <em>pull</em>,
você pode seguir uma das opções abaixo:</p><ul><li>defina a <code>imagePullPolicy</code> do contêiner para<code> Always</code>.</li><li>omita <code>imagePullPolicy</code> e use<code>: latest</code> como a tag para a imagem a ser usada.</li><li>omita o <code>imagePullPolicy</code> e a tag da imagem a ser usada.</li><li>habilite o <a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImages</a> controlador de admissão.</li></ul><p>Quando <code>imagePullPolicy</code> é definido sem um valor específico, ele também é definido como<code> Always</code>.</p><h2 id=multiarquitetura-de-imagens-com-índice-de-imagens>Multiarquitetura de imagens com índice de imagens</h2><p>Além de fornecer o binário das imagens, um registro de contêiner também pode servir um <a href=https://github.com/opencontainers/image-spec/blob/master/image-index.md>índice de imagem do contêiner</a>. Um índice de imagem pode apontar para múltiplos <a href=https://github.com/opencontainers/image-spec/blob/master/manifest.md>manifestos da imagem</a> para versões específicas de arquitetura de um contêiner. A ideia é que você possa ter um nome para uma imagem (por exemplo: <code>pause</code>, <code>exemple/meuconteiner</code>, <code>kube-apiserver</code>) e permitir que diferentes sistemas busquem o binário da imagem correta para a arquitetura de máquina que estão usando.</p><p>O próprio Kubernetes normalmente nomeia as imagens de contêiner com o sufixo <code>-$(ARCH)</code>. Para retrocompatibilidade, gere as imagens mais antigas com sufixos. A ideia é gerar a imagem <code>pause</code> que tem o manifesto para todas as arquiteturas e <code>pause-amd64</code> que é retrocompatível com as configurações anteriores ou arquivos YAML que podem ter codificado as imagens com sufixos.</p><h2 id=usando-um-registro-privado>Usando um registro privado</h2><p>Os registros privados podem exigir chaves para acessar as imagens deles.
As credenciais podem ser fornecidas de várias maneiras:</p><ul><li>Configurando nós para autenticação em um registro privado<ul><li>todos os pods podem ler qualquer registro privado configurado</li><li>requer configuração de nó pelo administrador do cluster</li></ul></li><li>Imagens pré-obtidas<ul><li>todos os pods podem usar qualquer imagem armazenada em cache em um nó</li><li>requer acesso root a todos os nós para configurar</li></ul></li><li>Especificando ImagePullSecrets em um Pod<ul><li>apenas pods que fornecem chaves próprias podem acessar o registro privado</li></ul></li><li>Extensões locais ou específicas do fornecedor<ul><li>se estiver usando uma configuração de nó personalizado, você (ou seu provedor de nuvem) pode implementar seu mecanismo para autenticar o nó ao registro do contêiner.</li></ul></li></ul><p>Essas opções são explicadas com mais detalhes abaixo.</p><h3 id=configurando-nós-para-autenticação-em-um-registro-privado>Configurando nós para autenticação em um registro privado</h3><p>Se você executar o Docker em seus nós, poderá configurar o contêiner runtime do Docker
para autenticação em um registro de contêiner privado.</p><p>Essa abordagem é adequada se você puder controlar a configuração do nó.</p><blockquote class="note callout"><div><strong>Note:</strong> O Kubernetes padrão é compatível apenas com as seções <code>auths</code> e<code> HttpHeaders</code> na configuração do Docker.
Auxiliares de credencial do Docker (<code>credHelpers</code> ou<code> credsStore</code>) não são suportados.</div></blockquote><p>Docker armazena chaves de registros privados no arquivo <code>$HOME/.dockercfg</code> ou <code>$HOME/.docker/config.json</code>. Se você colocar o mesmo arquivo na lista de caminhos de pesquisa abaixo, o kubelet o usa como provedor de credenciais ao obter imagens.</p><ul><li><code>{--root-dir:-/var/lib/kubelet}/config.json</code></li><li><code>{cwd of kubelet}/config.json</code></li><li><code>${HOME}/.docker/config.json</code></li><li><code>/.docker/config.json</code></li><li><code>{--root-dir:-/var/lib/kubelet}/.dockercfg</code></li><li><code>{cwd of kubelet}/.dockercfg</code></li><li><code>${HOME}/.dockercfg</code></li><li><code>/.dockercfg</code></li></ul><blockquote class="note callout"><div><strong>Note:</strong> Você talvez tenha que definir <code>HOME=/root</code> explicitamente no ambiente do processo kubelet.</div></blockquote><p>Aqui estão as etapas recomendadas para configurar seus nós para usar um registro privado. Neste
exemplo, execute-os em seu desktop/laptop:</p><ol><li>Execute <code>docker login [servidor]</code> para cada conjunto de credenciais que deseja usar. Isso atualiza o <code>$HOME/.docker/config.json</code> em seu PC.</li><li>Visualize <code>$HOME/.docker/config.json</code> em um editor para garantir que contém apenas as credenciais que você deseja usar.</li><li>Obtenha uma lista de seus nós; por exemplo:<ul><li>se você quiser os nomes: <code>nodes=$( kubectl get nodes -o jsonpath='{range.items[*].metadata}{.name} {end}' )</code></li><li>se você deseja obter os endereços IP: <code>nodes=$( kubectl get nodes -o jsonpath='{range .items[*].status.addresses[?(@.type=="ExternalIP")]}{.address} {end}' )</code></li></ul></li><li>Copie seu <code>.docker/config.json</code> local para uma das listas de caminhos de busca acima.<ul><li>por exemplo, para testar isso: <code>for n in $nodes; do scp ~/.docker/config.json root@"$n":/var/lib/kubelet/config.json; done</code></li></ul></li></ol><blockquote class="note callout"><div><strong>Note:</strong> Para clusters de produção, use uma ferramenta de gerenciamento de configuração para que você possa aplicar esta
configuração em todos os nós que você precisar.</div></blockquote><p>Verifique se está funcionando criando um pod que usa uma imagem privada; por exemplo:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f - <span style=color:#b44>&lt;&lt;EOF
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Pod
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: private-image-test-1
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  containers:
</span><span style=color:#b44>    - name: uses-private-image
</span><span style=color:#b44>      image: $PRIVATE_IMAGE_NAME
</span><span style=color:#b44>      imagePullPolicy: Always
</span><span style=color:#b44>      command: [ &#34;echo&#34;, &#34;SUCCESS&#34; ]
</span><span style=color:#b44>EOF</span>
</code></pre></div><pre><code>pod/private-image-test-1 created
</code></pre><p>Se tudo estiver funcionando, então, após algum tempo, você pode executar:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs private-image-test-1
</code></pre></div><p>e veja o resultado do comando:</p><pre><code>SUCCESS
</code></pre><p>Se você suspeitar que o comando falhou, você pode executar:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pods/private-image-test-1 | grep <span style=color:#b44>&#39;Failed&#39;</span>
</code></pre></div><p>Em caso de falha, a saída é semelhante a:</p><pre><code>  Fri, 26 Jun 2015 15:36:13 -0700    Fri, 26 Jun 2015 15:39:13 -0700    19    {kubelet node-i2hq}    spec.containers{uses-private-image}    failed        Failed to pull image &quot;user/privaterepo:v1&quot;: Error: image user/privaterepo:v1 not found
</code></pre><p>Você deve garantir que todos os nós no cluster tenham o mesmo <code>.docker/config.json</code>. Caso contrário, os pods serão executados com sucesso em alguns nós e falharão em outros. Por exemplo, se você usar o escalonamento automático de nós, cada modelo de instância precisa incluir o <code>.docker/config.json</code> ou montar um drive que o contenha.</p><p>Todos os pods terão premissão de leitura às imagens em qualquer registro privado, uma vez que
as chaves privadas do registro são adicionadas ao <code>.docker/config.json</code>.</p><h3 id=imagens-pré-obtidas>Imagens pré-obtidas</h3><blockquote class="note callout"><div><strong>Note:</strong> Essa abordagem é adequada se você puder controlar a configuração do nó. Isto
não funcionará de forma confiável se o seu provedor de nuvem for responsável pelo gerenciamento de nós e os substituir
automaticamente.</div></blockquote><p>Por padrão, o kubelet tenta realizar um "pull" para cada imagem do registro especificado.
No entanto, se a propriedade <code>imagePullPolicy</code> do contêiner for definida como<code> IfNotPresent</code> ou <code>Never</code>,
em seguida, uma imagem local é usada (preferencial ou exclusivamente, respectivamente).</p><p>Se você quiser usar imagens pré-obtidas como um substituto para a autenticação do registro,
você deve garantir que todos os nós no cluster tenham as mesmas imagens pré-obtidas.</p><p>Isso pode ser usado para pré-carregar certas imagens com o intuíto de aumentar a velocidade ou como uma alternativa para autenticação em um registro privado.</p><p>Todos os pods terão permissão de leitura a quaisquer imagens pré-obtidas.</p><h3 id=especificando-imagepullsecrets-em-um-pod>Especificando imagePullSecrets em um pod</h3><blockquote class="note callout"><div><strong>Note:</strong> Esta é a abordagem recomendada para executar contêineres com base em imagens
de registros privados.</div></blockquote><p>O Kubernetes oferece suporte à especificação de chaves de registro de imagem de contêiner em um pod.</p><h4 id=criando-um-segredo-com-docker-config>Criando um segredo com Docker config</h4><p>Execute o seguinte comando, substituindo as palavras em maiúsculas com os valores apropriados:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret docker-registry &lt;name&gt; --docker-server<span style=color:#666>=</span>DOCKER_REGISTRY_SERVER --docker-username<span style=color:#666>=</span>DOCKER_USER --docker-password<span style=color:#666>=</span>DOCKER_PASSWORD --docker-email<span style=color:#666>=</span>DOCKER_EMAIL
</code></pre></div><p>Se você já tem um arquivo de credenciais do Docker, em vez de usar o
comando acima, você pode importar o arquivo de credenciais como um Kubernetes
<a class=glossary-tooltip title="Stores sensitive information, such as passwords, OAuth tokens, and ssh keys." data-toggle=tooltip data-placement=top href=/docs/concepts/configuration/secret/ target=_blank aria-label=Secrets>Secrets</a>.
<a href=/docs/tasks/configure-pod-container/pull-image-private-registry/#registry-secret-existing-credentials>Criar um segredo com base nas credenciais Docker existentes</a> explica como configurar isso.</p><p>Isso é particularmente útil se você estiver usando vários registros privados de contêineres, como <code>kubectl create secret docker-registry</code> cria um Segredo que
só funciona com um único registro privado.</p><blockquote class="note callout"><div><strong>Note:</strong> Os pods só podem fazer referência a <em>pull secrets</em> de imagem em seu próprio namespace,
portanto, esse processo precisa ser feito uma vez por namespace.</div></blockquote><h4 id=referenciando-um-imagepullsecrets-em-um-pod>Referenciando um imagePullSecrets em um pod</h4><p>Agora, você pode criar pods que fazem referência a esse segredo adicionando uma seção <code>imagePullSecrets</code>
na definição de Pod.</p><p>Por exemplo:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat <span style=color:#b44>&lt;&lt;EOF &gt; pod.yaml
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Pod
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: foo
</span><span style=color:#b44>  namespace: awesomeapps
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  containers:
</span><span style=color:#b44>    - name: foo
</span><span style=color:#b44>      image: janedoe/awesomeapp:v1
</span><span style=color:#b44>  imagePullSecrets:
</span><span style=color:#b44>    - name: myregistrykey
</span><span style=color:#b44>EOF</span>
cat <span style=color:#b44>&lt;&lt;EOF &gt;&gt; ./kustomization.yaml
</span><span style=color:#b44>resources:
</span><span style=color:#b44>- pod.yaml
</span><span style=color:#b44>EOF</span>
</code></pre></div><p>Isso precisa ser feito para cada pod que está usando um registro privado.</p><p>No entanto, a configuração deste campo pode ser automatizada definindo o imagePullSecrets
em um recurso de <a href=/docs/tasks/configure-pod-container/configure-service-account/>ServiceAccount</a>.</p><p>Verifique <a href=/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account>Adicionar ImagePullSecrets a uma conta de serviço</a> para obter instruções detalhadas.</p><p>Você pode usar isso em conjunto com um <code>.docker / config.json</code> por nó. As credenciais
serão mescladas.</p><h2 id=casos-de-uso>Casos de uso</h2><p>Existem várias soluções para configurar registros privados. Aqui estão alguns
casos de uso comuns e soluções sugeridas.</p><ol><li>Cluster executando apenas imagens não proprietárias (por exemplo, código aberto). Não há necessidade de ocultar imagens.<ul><li>Use imagens públicas no Docker hub.<ul><li>Nenhuma configuração necessária.</li><li>Alguns provedores de nuvem armazenam em cache ou espelham automaticamente imagens públicas, o que melhora a disponibilidade e reduz o tempo para extrair imagens.</li></ul></li></ul></li><li>Cluster executando algumas imagens proprietárias que devem ser ocultadas para quem está fora da empresa, mas
visível para todos os usuários do cluster.<ul><li>Use um <a href=https://docs.docker.com/registry/>registro Docker</a> privado hospedado.<ul><li>Pode ser hospedado no <a href=https://hub.docker.com/signup>Docker Hub</a> ou em outro lugar.</li><li>Configure manualmente .docker/config.json em cada nó conforme descrito acima.</li></ul></li><li>Ou execute um registro privado interno atrás de seu firewall com permissão de leitura.<ul><li>Nenhuma configuração do Kubernetes é necessária.</li></ul></li><li>Use um serviço de registro de imagem de contêiner que controla o acesso à imagem<ul><li>Funcionará melhor com o escalonamento automático do cluster do que com a configuração manual de nós.</li></ul></li><li>Ou, em um cluster onde alterar a configuração do nó é inconveniente, use <code>imagePullSecrets</code>.</li></ul></li><li>Cluster com imagens proprietárias, algumas das quais requerem controle de acesso mais rígido.<ul><li>Certifique-se de que o <a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>controlador de admissão AlwaysPullImages</a> está ativo. Caso contrário, todos os pods têm potencialmente acesso a todas as imagens.</li><li>Mova dados confidenciais para um recurso "secreto", em vez de empacotá-los em uma imagem.</li></ul></li><li>Um cluster multilocatário em que cada locatário precisa de seu próprio registro privado.<ul><li>Certifique-se de que o <a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>controlador de admissão AlwaysPullImages</a> está ativo. Caso contrário, todos os Pods de todos os locatários terão potencialmente acesso a todas as imagens.</li><li>Execute um registro privado com autorização necessária.</li><li>Gere credenciais de registro para cada locatário, coloque em segredo e preencha o segredo para cada namespace de locatário.</li><li>O locatário adiciona esse segredo a imagePullSecrets de cada namespace.</li></ul></li></ol><p>Se precisar de acesso a vários registros, você pode criar um segredo para cada registro.
O Kubelet mesclará qualquer <code>imagePullSecrets</code> em um único <code>.docker/config.json</code> virtual</p><h2 id=what-s-next>What's next</h2><ul><li>Leia a <a href=https://github.com/opencontainers/image-spec/blob/master/manifest.md>OCI Image Manifest Specification</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-643212488f778acf04bebed65ba34441>3.2 - Ambiente de Contêiner</h1><p>Essa página descreve os recursos disponíveis para contêineres no ambiente de contêiner.</p><h2 id=ambiente-de-contêiner>Ambiente de contêiner</h2><p>O ambiente de contêiner do Kubernetes fornece recursos importantes para contêineres:</p><ul><li>Um sistema de arquivos, que é a combinação de uma <a href=/docs/concepts/containers/images/>imagem</a> e um ou mais <a href=/docs/concepts/storage/volumes/>volumes</a>.</li><li>Informação sobre o contêiner propriamente.</li><li>Informação sobre outros objetos no cluster.</li></ul><h3 id=informação-de-contêiner>Informação de contêiner</h3><p>O <em>hostname</em> de um contêiner é o nome do Pod em que o contêiner está executando.
Isso é disponibilizado através do comando <code>hostname</code> ou da função <a href=https://man7.org/linux/man-pages/man2/gethostname.2.html><code>gethostname</code></a> chamada na libc.</p><p>O nome do Pod e o Namespace são expostos como variáveis de ambiente através de um mecanismo chamado <a href=/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/>downward API</a>.</p><p>Variáveis de ambiente definidas pelo usuário a partir da definição do Pod também são disponíveis para o contêiner, assim como qualquer variável de ambiente especificada estáticamente na imagem Docker.</p><h3 id=informação-do-cluster>Informação do cluster</h3><p>Uma lista de todos os serviços que estão executando quando um contêiner foi criado é disponibilizada para o contêiner como variáveis de ambiente.
Essas variáveis de ambiente são compatíveis com a funcionalidade <em>docker link</em> do Docker.</p><p>Para um serviço nomeado <em>foo</em> que mapeia para um contêiner nomeado <em>bar</em>, as seguintes variáveis são definidas:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>FOO_SERVICE_HOST</span><span style=color:#666>=</span>&lt;o host em que o serviço está executando&gt;
<span style=color:#b8860b>FOO_SERVICE_PORT</span><span style=color:#666>=</span>&lt;a porta em que o serviço está executando&gt;
</code></pre></div><p>Serviços possuem endereço IP dedicado e são disponibilizados para o contêiner via DNS,
se possuírem <a href=https://releases.k8s.io/v1.20.15/cluster/addons/dns/>DNS addon</a> habilitado.</p><h2 id=what-s-next>What's next</h2><ul><li>Aprenda mais sobre <a href=/docs/concepts/containers/container-lifecycle-hooks/>hooks de ciclo de vida do contêiner</a>.</li><li>Obtenha experiência prática
<a href=/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>anexando manipuladores a eventos de ciclo de vida do contêiner</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-a858027489648786a3b16264e451272b>3.3 - Classes de execução</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.20 [stable]</code></div><p>Essa página descreve o recurso <em>RuntimeClass</em> e a seleção do mecanismo do agente de execução.</p><p>RuntimeClass é uma funcionalidade para selecionar as configurações do agente de execução do contêiner.
A configuração do agente de execução de contêineres é usada para executar os contêineres de um Pod.</p><h2 id=motivação>Motivação</h2><p>Você pode configurar um <em>RuntimeClass</em> diferente entre os diferentes Pods para prover
um equilíbrio entre performance versus segurança. Por exemplo, se parte de sua carga de
trabalho necessita de um alto nível de garantia de segurança da informação, você pode
optar em executar esses Pods em um agente de execução que usa virtualização de hardware.
Você então terá o benefício do isolamento extra de um agente de execução alternativo, ao
custo de uma latência adicional.</p><p>Você pode ainda usar um <em>RuntimeClass</em> para executar diferentes Pods com o mesmo agente
de execução de contêineres mas com diferentes configurações.</p><h2 id=configuração>Configuração</h2><ol><li>Configure a implementação do CRI nos nós (depende do agente de execução)</li><li>Crie o recurso RuntimeClass correspondente.</li></ol><h3 id=1-configure-a-implementação-do-cri-nos-nós>1. Configure a implementação do CRI nos nós</h3><p>As configurações disponíveis através do RuntimeClass sáo dependentes da implementação do
<em>Container Runtime Interface</em> (<a class=glossary-tooltip title="Uma API para agentes de execução de contêineres se integrarem com o kubelet" data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#container-runtime target=_blank aria-label="Container runtime interface (CRI)">Container runtime interface (CRI)</a>). Veja a documentação correspondente <a href=#configura%C3%A7%C3%A3o-do-cri>abaixo</a> para a
sua implementação CRI para verificar como configurar.</p><blockquote class="note callout"><div><strong>Note:</strong> RuntimeClass assume uma configuração homogênea de nós entre todo o cluster por padrão
(o que significa que todos os nós estão configurados do mesmo jeito referente aos agentes de
execução). Para suportar configurações heterogêneas, veja <a href=#associa%C3%A7%C3%A3o>Associação</a> abaixo.</div></blockquote><p>As configurações possuem um nome <code>handler</code> correspondente, referenciado pelo RuntimeClass.
Esse nome deve ser um valor DNS 1123 válido (letras, números e o carácter <code>-</code>).</p><h3 id=2-crie-o-recurso-runtimeclass-correspondente>2. Crie o recurso RuntimeClass correspondente</h3><p>As etapas de configuração no passo 1 devem todas estar associadas a um nome para o campo <code>handler</code>
que identifica a configuração. Para cada um, crie o objeto RuntimeClass correspondente.</p><p>O recurso RuntimeClass atualmente possui apenas 2 campos significativos: o nome do RuntimeClass
(<code>metadata.name</code>) e o agente (<code>handler</code>). A definição do objeto se parece conforme a seguir:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>node.k8s.io/v1 <span style=color:#bbb> </span><span style=color:#080;font-style:italic># RuntimeClass é definido no grupo de API node.k8s.io</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RuntimeClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myclass <span style=color:#bbb> </span><span style=color:#080;font-style:italic># O nome que o RuntimeClass será chamado como</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># RuntimeClass é um recurso global, e não possui namespace.</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>handler</span>:<span style=color:#bbb> </span>myconfiguration <span style=color:#bbb> </span><span style=color:#080;font-style:italic># Nome da configuração CRI correspondente</span><span style=color:#bbb>
</span></code></pre></div><p>O nome de um objeto RuntimeClass deve ser um
<a href=/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>nome de subdomínio DNS</a> válido.</p><blockquote class="note callout"><div><strong>Note:</strong> É recomendado que operações de escrita no objeto RuntimeClass (criar/atualizar/patch/apagar)
sejam restritas a administradores do cluster. Isso geralmente é o padrão. Veja <a href=/docs/reference/access-authn-authz/authorization/>Visão Geral
de autorizações</a> para maiores detalhes.</div></blockquote><h2 id=uso>Uso</h2><p>Uma vez que as classes de execução estão configuradas no cluster, usar elas é relativamente
simples. Especifique um <code>runtimeClassName</code> na especificação do Pod. Por exemplo:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>runtimeClassName</span>:<span style=color:#bbb> </span>myclass<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></code></pre></div><p>Isso irá instruir o kubelet a usar o RuntimeClass nomeado acima (myclass) para esse Pod. Se
o nome do RuntimeClass não existir, ou o CRI não puder executar a solicitação, o Pod entrará na <a href=/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase>fase
final</a> <code>Failed</code>. Procure por um
<a href=/docs/tasks/debug-application-cluster/debug-application-introspection/>evento</a> correspondente
para uma mensagem de erro.</p><p>Se nenhum <code>runtimeClassName</code> for especificado, o RuntimeHandler padrão será utilizado, que é equivalente
ao comportamento quando a funcionalidade de RuntimeClass está desativada.</p><h3 id=configuração-do-cri>Configuração do CRI</h3><p>Para maiores detalhes de configuração dos agentes de execução CRI, veja <a href=/docs/setup/production-environment/container-runtimes/>instalação do CRI</a>.</p><h4 id=dockershim>dockershim</h4><p>O CRI dockershim embutido no Kubernetes não suporta outros agentes de execução.</p><h4 id=hahahugoshortcode-s4-hbhb><a class=glossary-tooltip title="Um agente de execução de contêiner com enfase em simplicidade, robustez e portabilidade" data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a></h4><p>Agentes de execução são configurados através da configuração do containerd em
<code>/etc/containerd/config.toml</code>. Agentes válidos são configurados sob a seção de <code>runtimes</code>:</p><pre><code>[plugins.cri.containerd.runtimes.${HANDLER_NAME}]
</code></pre><p>Veja a documentação de configuração do containerd para maiores detalhes:
<a href=https://github.com/containerd/cri/blob/master/docs/config.md>https://github.com/containerd/cri/blob/master/docs/config.md</a></p><h4 id=hahahugoshortcode-s5-hbhb><a class=glossary-tooltip title="Um agente de execução leve de contêineres criado especificamente para o Kubernetes" data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a></h4><p>Agentes de execução são configurados através da configuração do CRI-O em <code>/etc/crio/crio.conf</code>.
Agentes válidos são configurados na seção <a href=https://github.com/cri-o/cri-o/blob/master/docs/crio.conf.5.md#crioruntime-table>crio.runtime
table</a>:</p><pre><code>[crio.runtime.runtimes.${HANDLER_NAME}]
  runtime_path = &quot;${PATH_TO_BINARY}&quot;
</code></pre><p>Veja a <a href=https://raw.githubusercontent.com/cri-o/cri-o/9f11d1d/docs/crio.conf.5.md>documentação de configuração</a> do CRI-O para maiores detalhes.</p><h2 id=associação>Associação</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.16 [beta]</code></div><p>Ao especificar o campo <code>scheduling</code> para um RuntimeClass, você pode colocar limites e
garantir que os Pods executando dentro de uma RuntimeClass sejam associados a nós que
suportem eles. Se o <code>scheduling</code> não estiver configurado, assume-se que esse RuntimeClass
é suportado por todos os nós.</p><p>Para garantir que os Pods sejam executados em um nó que suporte um RuntimeClass específico,
aquele conjunto de nós deve possuir uma marca/label padrão que é selecionado pelo campo
<code>runtimeclass.scheduling.nodeSelector</code>. O nodeSelector do RuntimeClass é combinado com o
nodeSelector do Pod em tempo de admissão, obtendo a intersecção do conjunto de nós selecionado
por cada. Se existir um conflito, o pod será rejeitado.</p><p>Se os nós suportados possuírem marcação de restrição para prevenir outros Pods com uma
classe de execução diferente de executar no nó, você pode adicionar o campo <code>tolerations</code>
ao objeto RuntimeClass. Assim como com o <code>nodeSelector</code>, o <code>tolerations</code> é combinado com
o campo <code>tolerations</code> do Pod em tempo de admissão, efetivamente pegando a intersecção do
conjunto de nós aplicáveis para cada.</p><p>Para saber mais sobre a configuração de seleção de nós e tolerâncias, veja <a href=/docs/concepts/scheduling-eviction/assign-pod-node/>Associando Pods a
Nós</a>.</p><h3 id=sobrecarga-de-pods>Sobrecarga de Pods</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code></div><p>Você pode especificar os recursos extra que estão associados à execução de um Pod. Declarar esses
recursos extra permite ao cluster (incluindo o agendador/scheduler de pods) contabilizar por
esses recursos quando estiver decidindo sobre Pods e recursos. Para usar a contabilização
desses recursos extras, você deve estar com o <a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>
PodOverhead habilitado (ele já está habilitado por padrão).</p><p>Os recursos extras utilizados são especificados no objeto RuntimeClass através do campo <code>overhead</code>.
Ao usar esses campos, você especifica o uso extra de recursos necessários para executar
Pods utilizando-se desse Runtimeclass e assim contabilizar esses recursos para o Kubernetes.</p><h2 id=what-s-next>What's next</h2><ul><li><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/585-runtime-class/README.md>RuntimeClass Design</a></li><li><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/585-runtime-class/README.md#runtimeclass-scheduling>RuntimeClass Scheduling Design</a></li><li>Leia mais sobre <a href=/docs/concepts/scheduling-eviction/pod-overhead/>Sobrecarga de Pods</a></li><li><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/20190226-pod-overhead.md>PodOverhead Feature Design</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-e6941d969d81540208a3e78bc56f43bc>3.4 - Hooks de Ciclo de Vida do Contêiner</h1><p>Essa página descreve como os contêineres gerenciados pelo <em>kubelet</em> podem usar a estrutura de <em>hook</em> de ciclo de vida do contêiner para executar código acionado por eventos durante seu ciclo de vida de gerenciamento.</p><h2 id=visão-geral>Visão Geral</h2><p>Análogo a muitas estruturas de linguagem de programação que tem <em>hooks</em> de ciclo de vida de componentes, como angular,
o Kubernetes fornece aos contêineres <em>hooks</em> de ciclo de vida.
Os <em>hooks</em> permitem que os contêineres estejam cientes dos eventos em seu ciclo de vida de gerenciamento
e executem código implementado em um manipulador quando o <em>hook</em> de ciclo de vida correspondente é executado.</p><h2 id=hooks-do-contêiner>Hooks do contêiner</h2><p>Existem dois <em>hooks</em> que são expostos para os contêiners:</p><p><code>PostStart</code></p><p>Este <em>hook</em> é executado imediatamente após um contêiner ser criado.
Entretanto, não há garantia que o <em>hook</em> será executado antes do ENTRYPOINT do contêiner.
Nenhum parâmetro é passado para o manipulador.</p><p><code>PreStop</code></p><p>Esse <em>hook</em> é chamado imediatamente antes de um contêiner ser encerrado devido a uma solicitação de API ou um gerenciamento de evento como liveness/startup probe failure, preemption, resource contention e outros.
Uma chamada ao <em>hook</em> <code>PreStop</code> falha se o contêiner já está em um estado finalizado ou concluído e o <em>hook</em> deve ser concluído antes que o sinal TERM seja enviado para parar o contêiner. A contagem regressiva do período de tolerância de término do Pod começa antes que o <em>hook</em> <code>PreStop</code> seja executado, portanto, independentemente do resultado do manipulador, o contêiner será encerrado dentro do período de tolerância de encerramento do Pod. Nenhum parâmetro é passado para o manipulador.</p><p>Uma descrição mais detalhada do comportamento de término pode ser encontrada em <a href=/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>Término de Pods</a>.</p><h3 id=implementações-de-manipulador-de-hook>Implementações de manipulador de hook</h3><p>Os contêineres podem acessar um <em>hook</em> implementando e registrando um manipulador para esse <em>hook</em>.
Existem dois tipos de manipuladores de <em>hooks</em> que podem ser implementados para contêineres:</p><ul><li>Exec - Executa um comando específico, como <code>pre-stop.sh</code>, dentro dos cgroups e Namespaces do contêiner.</li><li>HTTP - Executa uma requisição HTTP em um endpoint específico do contêiner.</li></ul><h3 id=execução-do-manipulador-de-hook>Execução do manipulador de hook</h3><p>Quando um <em>hook</em> de gerenciamento de ciclo de vida do contêiner é chamado, o sistema de gerenciamento do Kubernetes executa o manipulador de acordo com a ação do <em>hook</em>, <code>httpGet</code> e <code>tcpSocket</code> são executados pelo processo kubelet e <code>exec</code> é executado pelo contêiner.</p><p>As chamadas do manipulador do <em>hook</em> são síncronas no contexto do Pod que contém o contêiner.
Isso significa que para um <em>hook</em> <code>PostStart</code>, o ENTRYPOINT do contêiner e o <em>hook</em> disparam de forma assíncrona.
No entanto, se o <em>hook</em> demorar muito para ser executado ou travar, o contêiner não consegue atingir o estado <code>running</code>.</p><p>Os <em>hooks</em> <code>PreStop</code> não são executados de forma assíncrona a partir do sinal para parar o contêiner, o <em>hook</em> precisa finalizar a sua execução antes que o sinal TERM possa ser enviado.
Se um <em>hook</em> <code>PreStop</code> travar durante a execução, a fase do Pod será <code>Terminating</code> e permanecerá até que o Pod seja morto após seu <code>terminationGracePeriodSeconds</code> expirar. Esse período de tolerância se aplica ao tempo total necessário
para o <em>hook</em> <code>PreStop</code>executar e para o contêiner parar normalmente.
Se por exemplo, o <code>terminationGracePeriodSeconds</code> é 60, e o <em>hook</em> leva 55 segundos para ser concluído, e o contêiner leva 10 segundos para parar normalmente após receber o sinal, então o contêiner será morto antes que possa parar
normalmente, uma vez que o <code>terminationGracePeriodSeconds</code> é menor que o tempo total (55 + 10) que é necessário para que essas duas coisas aconteçam.</p><p>Se um <em>hook</em> <code>PostStart</code> ou <code>PreStop</code> falhar, ele mata o contêiner.</p><p>Os usuários devem tornar seus <em>hooks</em> o mais leve possíveis.
Há casos, no entanto, em que comandos de longa duração fazem sentido, como ao salvar o estado
antes de parar um contêiner.</p><h3 id=garantias-de-entrega-de-hooks>Garantias de entrega de <em>hooks</em></h3><p>A entrega do <em>hook</em> é destinada a acontecer <em>pelo menos uma vez</em>,
o que quer dizer que um <em>hook</em> pode ser chamado várias vezes para qualquer evento,
como para <code>PostStart</code> ou <code>PreStop</code>.
Depende da implementação do <em>hook</em> lidar com isso corretamente.</p><p>Geralmente, apenas entregas únicas são feitas.
Se, por exemplo, um receptor de <em>hook</em> HTTP estiver inativo e não puder receber tráfego,
não há tentativa de reenviar.
Em alguns casos raros, no entanto, pode ocorrer uma entrega dupla.
Por exemplo, se um kubelet reiniciar no meio do envio de um <em>hook</em>, o <em>hook</em> pode ser
reenviado depois que o kubelet voltar a funcionar.</p><h3 id=depurando-manipuladores-de-hooks>Depurando manipuladores de <em>hooks</em></h3><p>Os logs para um manipulador de <em>hook</em> não são expostos em eventos de Pod.
Se um manipulador falhar por algum motivo, ele transmitirá um evento.
Para <code>PostStart</code> é o evento <code>FailedPostStartHook</code> e para <code>PreStop</code> é o evento
<code>FailedPreStopHook</code>.
Você pode ver esses eventos executando <code>kubectl describe pod &lt;nome_do_pod></code>.
Aqui está um exemplo de saída de eventos da execução deste comando:</p><pre><code>Events:
  FirstSeen  LastSeen  Count  From                                                   SubObjectPath          Type      Reason               Message
  ---------  --------  -----  ----                                                   -------------          --------  ------               -------
  1m         1m        1      {default-scheduler }                                                          Normal    Scheduled            Successfully assigned test-1730497541-cq1d2 to gke-test-cluster-default-pool-a07e5d30-siqd
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Pulling              pulling image &quot;test:1.0&quot;
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Created              Created container with docker id 5c6a256a2567; Security:[seccomp=unconfined]
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Pulled               Successfully pulled image &quot;test:1.0&quot;
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Started              Started container with docker id 5c6a256a2567
  38s        38s       1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Killing              Killing container with docker id 5c6a256a2567: PostStart handler: Error executing in Docker Container: 1
  37s        37s       1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Killing              Killing container with docker id 8df9fdfd7054: PostStart handler: Error executing in Docker Container: 1
  38s        37s       2      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}                         Warning   FailedSync           Error syncing pod, skipping: failed to &quot;StartContainer&quot; for &quot;main&quot; with RunContainerError: &quot;PostStart handler: Error executing in Docker Container: 1&quot;
  1m         22s       2      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Warning   FailedPostStartHook
</code></pre><h2 id=what-s-next>What's next</h2><ul><li>Saiba mais sobre o <a href=/docs/concepts/containers/container-environment/>Ambiente de contêiner</a>.</li><li>Obtenha experiência prática
<a href=/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>anexando manipuladores a eventos de ciclo de vida do contêiner</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-275bea454e1cf4c5adeca4058b5af988>4 - Configuração</h1></div><div class=td-content><h1 id=pg-ab6d20f33ad930a67ee7ef57bff6c75e>4.1 - Organizando o acesso ao cluster usando arquivos kubeconfig</h1><p>Utilize arquivos kubeconfig para organizar informações sobre clusters, usuários, namespaces e mecanismos de autenticação. A ferramenta de linha de comando <code>kubectl</code> faz uso dos arquivos kubeconfig para encontrar as informações necessárias para escolher e se comunicar com o serviço de API de um cluster.</p><blockquote class="note callout"><div><strong>Note:</strong> Um arquivo que é utilizado para configurar o acesso aos clusters é chamado de <em>kubeconfig</em>. Esta á uma forma genérica de referenciamento para um arquivo de configuração desta natureza. Isso não significa que existe um arquivo com o nome <code>kubeconfig</code>.</div></blockquote><p>Por padrão, o <code>kubectl</code> procura por um arquivo de nome <code>config</code> no diretório <code>$HOME/.kube</code></p><p>Você pode especificar outros arquivos kubeconfig através da variável de ambiente <code>KUBECONFIG</code> ou adicionando a opção <a href=/docs/reference/generated/kubectl/kubectl/><code>--kubeconfig</code></a>.</p><p>Para maiores detalhes na criação e especificação de um kubeconfig, veja o passo a passo em <a href=/docs/tasks/access-application-cluster/configure-access-multiple-clusters>Configurar Acesso para Múltiplos Clusters</a>.</p><h2 id=suportando-múltiplos-clusters-usuários-e-mecanismos-de-autenticação>Suportando múltiplos clusters, usuários e mecanismos de autenticação</h2><p>Imagine que você possua inúmeros clusters, e seus usuários e componentes se autenticam de várias formas. Por exemplo:</p><ul><li>Um kubelet ativo pode se autenticar utilizando certificados</li><li>Um usuário pode se autenticar através de tokens</li><li>Administradores podem possuir conjuntos de certificados os quais provém acesso aos usuários de forma individual.</li></ul><p>Através de arquivos kubeconfig, você pode organizar os seus clusters, usuários, e namespaces. Você também pode definir contextos para uma fácil troca entre clusters e namespaces.</p><h2 id=contexto>Contexto</h2><p>Um elemento de <em>contexto</em> em um kubeconfig é utilizado para agrupar parâmetros de acesso em um nome conveniente. Cada contexto possui três parâmetros: cluster, namespace, e usuário.</p><p>Por padrão, a ferramenta de linha de comando <code>kubectl</code> utiliza os parâmetros do <em>contexto atual</em> para se comunicar com o cluster.</p><p>Para escolher o contexto atual:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config use-context
</code></pre></div><h2 id=a-variável-de-ambiente-kubeconfig>A variável de ambiente KUBECONFIG</h2><p>A variável de ambiente <code>KUBECONFIG</code> possui uma lista dos arquivos kubeconfig. Para Linux e Mac, esta lista é delimitada por vírgula. No Windows, a lista é delimitada por ponto e vírgula. A variável de ambiente <code>KUBECONFIG</code> não é um requisito obrigatório - caso ela não exista o <code>kubectl</code> utilizará o arquivo kubeconfig padrão localizado no caminho <code>$HOME/.kube/config</code>.</p><p>Se a variável de ambiente <code>KUBECONFIG</code> existir, o <code>kubectl</code> utilizará uma configuração que é o resultado da combinação dos arquivos listados na variável de ambiente <code>KUBECONFIG</code>.</p><h2 id=combinando-arquivos-kubeconfig>Combinando arquivos kubeconfig</h2><p>Para inspecionar a sua configuração atual, execute o seguinte comando:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config view
</code></pre></div><p>Como descrito anteriormente, a saída poderá ser resultado de um único arquivo kubeconfig, ou poderá ser o resultado da junção de vários arquivos kubeconfig.</p><p>Aqui estão as regras que o <code>kubectl</code> utiliza quando realiza a combinação de arquivos kubeconfig:</p><ol><li><p>Se o argumento <code>--kubeconfig</code> está definido, apenas o arquivo especificado será utilizado. Apenas uma instância desta flag é permitida.</p><p>Caso contrário, se a variável de ambiente <code>KUBECONFIG</code> estiver definida, esta deverá ser utilizada como uma lista de arquivos a serem combinados, seguindo o fluxo a seguir:</p><ul><li>Ignorar arquivos vazios.</li><li>Produzir erros para aquivos cujo conteúdo não for possível desserializar.</li><li>O primeiro arquivo que definir um valor ou mapear uma chave determinada, será o escolhido.</li><li>Nunca modificar um valor ou mapear uma chave.
Exemplo: Preservar o contexto do primeiro arquivo que definir <code>current-context</code>.
Exemplo: Se dois arquivos especificarem um <code>red-user</code>, use apenas os valores do primeiro <code>red-user</code>. Mesmo se um segundo arquivo possuir entradas não conflitantes sobre a mesma entrada <code>red-user</code>, estas deverão ser descartadas.</li></ul><p>Para um exemplo de definição da variável de ambiente <code>KUBECONFIG</code> veja <a href=/docs/tasks/access-application-cluster/configure-access-multiple-clusters/#set-the-kubeconfig-environment-variable>Definido a variável de ambiente KUBECONFIG</a>.</p><p>Caso contrário, utilize o arquivo kubeconfig padrão encontrado no diretório <code>$HOME/.kube/config</code>, sem qualquer tipo de combinação.</p></li><li><p>Determine o contexto a ser utilizado baseado no primeiro padrão encontrado, nesta ordem:</p><ol><li>Usar o conteúdo da flag <code>--context</code> caso ela existir.</li><li>Usar o <code>current-context</code> a partir da combinação dos arquivos kubeconfig.</li></ol><p>Um contexto vazio é permitido neste momento.</p></li><li><p>Determinar o cluster e o usuário. Neste ponto, poderá ou não existir um contexto.
Determinar o cluster e o usuário no primeiro padrão encontrado de acordo com a ordem à seguir. Este procedimento deverá executado duas vezes: uma para definir o usuário a outra para definir o cluster.</p><ol><li>Utilizar a flag caso ela existir: <code>--user</code> ou <code>--cluster</code>.</li><li>Se o contexto não estiver vazio, utilizar o cluster ou usuário deste contexto.</li></ol><p>O usuário e o cluster poderão estar vazios neste ponto.</p></li><li><p>Determinar as informações do cluster atual a serem utilizadas. Neste ponto, poderá ou não existir informações de um cluster.</p><p>Construir cada peça de informação do cluster baseado nas opções à seguir; a primeira ocorrência encontrada será a opção vencedora:</p><ol><li>Usar as flags de linha de comando caso existirem: <code>--server</code>, <code>--certificate-authority</code>, <code>--insecure-skip-tls-verify</code>.</li><li>Se algum atributo do cluster existir a partir da combinação de kubeconfigs, estes deverão ser utilizados.</li><li>Se não existir informação de localização do servidor falhar.</li></ol></li><li><p>Determinar a informação atual de usuário a ser utilizada. Construir a informação de usuário utilizando as mesmas regras utilizadas para o caso de informações de cluster, exceto para a regra de técnica de autenticação que deverá ser única por usuário:</p><ol><li>Usar as flags, caso existirem: <code>--client-certificate</code>, <code>--client-key</code>, <code>--username</code>, <code>--password</code>, <code>--token</code>.</li><li>Usar os campos <code>user</code> resultado da combinação de arquivos kubeconfig.</li><li>Se existirem duas técnicas conflitantes, falhar.</li></ol></li><li><p>Para qualquer informação que ainda estiver ausente, utilizar os valores padrão e potencialmente solicitar informações de autenticação a partir do prompt de comando.</p></li></ol><h2 id=referências-de-arquivos>Referências de arquivos</h2><p>Arquivos e caminhos referenciados em um arquivo kubeconfig são relativos à localização do arquivo kubeconfig.</p><p>Referências de arquivos na linha de comando são relativas ao diretório de trabalho vigente.</p><p>No arquivo <code>$HOME/.kube/config</code>, caminhos relativos são armazenados de forma relativa, e caminhos absolutos são armazenados de forma absoluta.</p><h2 id=what-s-next>What's next</h2><ul><li><a href=/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>Configurar Accesso para Multiplos Clusters</a></li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#config><code>kubectl config</code></a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-712cb3c03ff14a39e5a83a6d9b71d203>5 - Segurança</h1></div><div class=td-content><h1 id=pg-04eeb110d75afc8acb2cf7a3db743985>5.1 - Visão Geral da Segurança Cloud Native</h1><p>Esta visão geral define um modelo para pensar sobre a segurança em Kubernetes no contexto da Segurança em Cloud Native.</p><blockquote class="warning callout"><div><strong>Warning:</strong> Este modelo de segurança no contêiner fornece sugestões, não prova políticas de segurança da informação.</div></blockquote><h2 id=os-4c-da-segurança-cloud-native>Os 4C da Segurança Cloud Native</h2><p>Você pode pensar na segurança em camadas. Os 4C da segurança Cloud Native são a Cloud,
Clusters, Contêineres e Código.</p><blockquote class="note callout"><div><strong>Note:</strong> Esta abordagem em camadas aumenta a <a href=https://en.wikipedia.org/wiki/Defense_in_depth_(computing)>defesa em profundidade</a>
para segurança, que é amplamente considerada como uma boa prática de segurança para software de sistemas.</div></blockquote><figure><img src=/images/docs/4c.png><figcaption><h4>Os 4C da Segurança Cloud Native</h4></figcaption></figure><p>Cada camada do modelo de segurança Cloud Native é construída sobre a próxima camada mais externa.
A camada de código se beneficia de uma base forte (Cloud, Cluster, Contêiner) de camadas seguras.
Você não pode proteger contra padrões ruins de segurança nas camadas de base através de
segurança no nível do Código.</p><h2 id=cloud>Cloud</h2><p>De muitas maneiras, a Cloud (ou servidores co-localizados, ou o datacenter corporativo) é a
<a href=https://en.wikipedia.org/wiki/Trusted_computing_base>base de computação confiável</a>
de um cluster Kubernetes. Se a camada de Cloud é vulnerável (ou
configurado de alguma maneira vulnerável), então não há garantia de que os componentes construídos
em cima desta base estejam seguros. Cada provedor de Cloud faz recomendações de segurança
para executar as cargas de trabalho com segurança nos ambientes.</p><h3 id=segurança-no-provedor-da-cloud>Segurança no provedor da Cloud</h3><p>Se você estiver executando um cluster Kubernetes em seu próprio hardware ou em um provedor de nuvem diferente,
consulte sua documentação para melhores práticas de segurança.
Aqui estão os links para as documentações de segurança dos provedores mais populares de nuvem:</p><table><caption style=display:none>Cloud provider security</caption><thead><tr><th>Provedor IaaS</th><th>Link</th></tr></thead><tbody><tr><td>Alibaba Cloud</td><td><a href=https://www.alibabacloud.com/trust-center>https://www.alibabacloud.com/trust-center</a></td></tr><tr><td>Amazon Web Services</td><td><a href=https://aws.amazon.com/security/>https://aws.amazon.com/security/</a></td></tr><tr><td>Google Cloud Platform</td><td><a href=https://cloud.google.com/security/>https://cloud.google.com/security/</a></td></tr><tr><td>IBM Cloud</td><td><a href=https://www.ibm.com/cloud/security>https://www.ibm.com/cloud/security</a></td></tr><tr><td>Microsoft Azure</td><td><a href=https://docs.microsoft.com/en-us/azure/security/azure-security>https://docs.microsoft.com/en-us/azure/security/azure-security</a></td></tr><tr><td>VMWare VSphere</td><td><a href=https://www.vmware.com/security/hardening-guides.html>https://www.vmware.com/security/hardening-guides.html</a></td></tr></tbody></table><h3 id=infrastructure-security>Segurança de Infraestrutura</h3><p>Sugestões para proteger sua infraestrutura em um cluster Kubernetes:</p><table><caption style=display:none>Infrastructure security</caption><thead><tr><th>Área de Interesse para Infraestrutura Kubernetes</th><th>Recomendação</th></tr></thead><tbody><tr><td>Acesso de rede ao servidor API (Control plane)</td><td>Todo o acesso ao control plane do Kubernetes publicamente na Internet não é permitido e é controlado por listas de controle de acesso à rede restritas ao conjunto de endereços IP necessários para administrar o cluster.</td></tr><tr><td>Acesso de rede aos Nós (nodes)</td><td>Os nós devem ser configurados para <em>só</em> aceitar conexões (por meio de listas de controle de acesso à rede) do control plane nas portas especificadas e aceitar conexões para serviços no Kubernetes do tipo NodePort e LoadBalancer. Se possível, esses nós não devem ser expostos inteiramente na Internet pública.</td></tr><tr><td>Acesso do Kubernetes à API do provedor de Cloud</td><td>Cada provedor de nuvem precisa conceder um conjunto diferente de permissões para o control plane e nós do Kubernetes. É melhor fornecer ao cluster permissão de acesso ao provedor de nuvem que segue o <a href=https://en.wikipedia.org/wiki/Principle_of_least_privilege>princípio do menor privilégio</a> para os recursos que ele precisa administrar. A <a href=https://github.com/kubernetes/kops/blob/master/docs/iam_roles.md#iam-roles>documentação do Kops</a> fornece informações sobre as políticas e roles do IAM.</td></tr><tr><td>Acesso ao etcd</td><td>O acesso ao etcd (o armazenamento de dados do Kubernetes) deve ser limitado apenas ao control plane. Dependendo de sua configuração, você deve tentar usar etcd sobre TLS. Mais informações podem ser encontradas na <a href=https://github.com/etcd-io/etcd/tree/master/Documentation>documentação do etcd</a>.</td></tr><tr><td>Encriptação etcd</td><td>Sempre que possível, é uma boa prática encriptar todas as unidades de armazenamento, mas como o etcd mantém o estado de todo o cluster (incluindo os Secrets), seu disco deve ser criptografado.</td></tr></tbody></table><h2 id=cluster>Cluster</h2><p>Existem duas áreas de preocupação para proteger o Kubernetes:</p><ul><li>Protegendo os componentes do cluster que são configuráveis.</li><li>Protegendo as aplicações que correm no cluster.</li></ul><h3 id=cluster-components>Componentes do Cluster</h3><p>Se você deseja proteger seu cluster de acesso acidental ou malicioso e adotar
boas práticas de informação, leia e siga os conselhos sobre
<a href=/docs/tasks/administer-cluster/securing-a-cluster/>protegendo seu cluster</a>.</p><h3 id=cluster-applications>Componentes no cluster (sua aplicação)</h3><p>Dependendo da superfície de ataque de sua aplicação, você pode querer se concentrar em
tópicos específicos de segurança. Por exemplo: se você estiver executando um serviço (Serviço A) que é crítico
numa cadeia de outros recursos e outra carga de trabalho separada (Serviço B) que é
vulnerável a um ataque de exaustão de recursos e, por consequência, o risco de comprometer o Serviço A
é alto se você não limitar os recursos do Serviço B. A tabela a seguir lista
áreas de atenção na segurança e recomendações para proteger cargas de trabalho em execução no Kubernetes:</p><table><thead><tr><th>Área de interesse para a segurança do Workload</th><th>Recomendação</th></tr></thead><tbody><tr><td>Autorização RBAC (acesso à API Kubernetes)</td><td><a href=https://kubernetes.io/docs/reference/access-authn-authz/rbac/>https://kubernetes.io/docs/reference/access-authn-authz/rbac/</a></td></tr><tr><td>Autenticação</td><td><a href=https://kubernetes.io/docs/concepts/security/controlling-access/>https://kubernetes.io/docs/concepts/security/controlling-access/</a></td></tr><tr><td>Gerenciamento de segredos na aplicação (e encriptando-os no etcd em repouso)</td><td><a href=https://kubernetes.io/docs/concepts/configuration/secret/>https://kubernetes.io/docs/concepts/configuration/secret/</a><br><a href=https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/>https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/</a></td></tr><tr><td>Políticas de segurança do Pod</td><td><a href=https://kubernetes.io/docs/concepts/policy/pod-security-policy/>https://kubernetes.io/docs/concepts/policy/pod-security-policy/</a></td></tr><tr><td>Qualidade de serviço (e gerenciamento de recursos de cluster)</td><td><a href=https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/>https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/</a></td></tr><tr><td>Políticas de Rede</td><td><a href=https://kubernetes.io/docs/concepts/services-networking/network-policies/>https://kubernetes.io/docs/concepts/services-networking/network-policies/</a></td></tr><tr><td>TLS para Kubernetes Ingress</td><td><a href=https://kubernetes.io/docs/concepts/services-networking/ingress/#tls>https://kubernetes.io/docs/concepts/services-networking/ingress/#tls</a></td></tr></tbody></table><h2 id=contêiner>Contêiner</h2><p>A segurança do contêiner está fora do escopo deste guia. Aqui estão recomendações gerais e
links para explorar este tópico:</p><table><thead><tr><th>Área de Interesse para Contêineres</th><th>Recomendação</th></tr></thead><tbody><tr><td>Scanners de Vulnerabilidade de Contêiner e Segurança de Dependência de SO</td><td>Como parte da etapa de construção de imagem, você deve usar algum scanner em seus contêineres em busca de vulnerabilidades.</td></tr><tr><td>Assinatura Imagem e Enforcement</td><td>Assinatura de imagens de contêineres para manter um sistema de confiança para o conteúdo de seus contêineres.</td></tr><tr><td>Proibir Usuários Privilegiados</td><td>Ao construir contêineres, consulte a documentação para criar usuários dentro dos contêineres que tenham o menor nível de privilégio no sistema operacional necessário para cumprir o objetivo do contêiner.</td></tr><tr><td>Use o Contêiner em Runtime com Isolamento mais Forte</td><td>Selecione <a href=/docs/concepts/containers/runtime-class/>classes de contêiner runtime</a> com o provedor de isolamento mais forte.</td></tr></tbody></table><h2 id=código>Código</h2><p>O código da aplicação é uma das principais superfícies de ataque sobre a qual você tem maior controle.
Embora a proteção do código do aplicativo esteja fora do tópico de segurança do Kubernetes, aqui
são recomendações para proteger o código do aplicativo:</p><h3 id=segurança-de-código>Segurança de código</h3><table><caption style=display:none>Code security</caption><thead><tr><th>Área de Atenção para o Código</th><th>Recomendação</th></tr></thead><tbody><tr><td>Acesso só através de TLS</td><td>Se seu código precisar se comunicar por TCP, execute um handshake TLS com o cliente antecipadamente. Com exceção de alguns casos, encripte tudo em trânsito. Indo um passo adiante, é uma boa ideia encriptar o tráfego de rede entre os serviços. Isso pode ser feito por meio de um processo conhecido como mutual ou <a href=https://en.wikipedia.org/wiki/Mutual_authentication>mTLS</a>, que realiza uma verificação bilateral da comunicação mediante os certificados nos serviços.</td></tr><tr><td>Limitando intervalos de porta de comunicação</td><td>Essa recomendação pode ser um pouco autoexplicativa, mas, sempre que possível, você só deve expor as portas em seu serviço que são absolutamente essenciais para a comunicação ou coleta de métricas.</td></tr><tr><td>Segurança na Dependência de Terceiros</td><td>É uma boa prática verificar regularmente as bibliotecas de terceiros de sua aplicação em busca de vulnerabilidades de segurança. Cada linguagem de programação possui uma ferramenta para realizar essa verificação automaticamente.</td></tr><tr><td>Análise de Código Estático</td><td>A maioria das linguagens fornece uma maneira para analisar um extrato do código referente a quaisquer práticas de codificação potencialmente inseguras. Sempre que possível, você deve automatizar verificações usando ferramentas que podem verificar as bases de código em busca de erros de segurança comuns. Algumas das ferramentas podem ser encontradas em <a href=https://owasp.org/www-community/Source_Code_Analysis_Tools>OWASP Source Code Analysis Tools</a>.</td></tr><tr><td>Ataques de sondagem dinâmica</td><td>Existem algumas ferramentas automatizadas que você pode executar contra seu serviço para tentar alguns dos ataques mais conhecidos. Isso inclui injeção de SQL, CSRF e XSS. Uma das ferramentas de análise dinâmica mais populares é o <a href=https://owasp.org/www-project-zap/>OWASP Zed Attack proxy</a>.</td></tr></tbody></table><h2 id=what-s-next>What's next</h2><p>Saiba mais sobre os tópicos de segurança do Kubernetes:</p><ul><li><a href=/docs/concepts/security/pod-security-standards/>Padrões de segurança do Pod</a></li><li><a href=/docs/concepts/services-networking/network-policies/>Políticas de rede para Pods</a></li><li><a href=/docs/concepts/security/controlling-access>Controle de acesso à API Kubernetes</a></li><li><a href=/docs/tasks/administer-cluster/securing-a-cluster/>Protegendo seu cluster</a></li><li><a href=/docs/tasks/tls/managing-tls-in-a-cluster/>Criptografia de dados em trânsito</a> for the control plane</li><li><a href=/docs/tasks/administer-cluster/encrypt-data/>Criptografia de dados em repouso</a></li><li><a href=/docs/concepts/configuration/secret/>Secrets no Kubernetes</a></li><li><a href=/docs/concepts/containers/runtime-class>Runtime class</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c21d05f31057c5bcd2ebdd01f4e62a0e>6 - Escalonamento</h1><div class=lead>No Kubernetes, agendamento refere-se a garantia de que os pods correspondam aos nós para que o kubelet possa executá-los. Remoção é o processo de falha proativa de um ou mais pods em nós com falta de recursos.</div></div><div class=td-content><h1 id=pg-598f36d691ab197f9d995784574b0a12>6.1 - Escalonador do Kubernetes</h1><p>No Kubernetes, <em>escalonamento</em> refere-se a garantir que os <a class=glossary-tooltip title="O menor e mais simples objeto Kubernetes. Um Pod representa um conjunto de contêineres em execução no seu cluster." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pods>Pods</a>
sejam correspondidos aos <a class=glossary-tooltip title="Um Nó é uma máquina de trabalho no Kubernetes." data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=Nodes>Nodes</a> para que o
<a class=glossary-tooltip title="Um agente que é executado em cada node no cluster. Ele garante que os contêineres estejam sendo executados em um pod." data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=Kubelet>Kubelet</a> possa executá-los.</p><h2 id=escalonamento>Visão geral do Escalonamento</h2><p>Um escalonador observa Pods recém-criados que não possuem um Node atribuído.
Para cada Pod que o escalonador descobre, ele se torna responsável por
encontrar o melhor Node para execução do Pod. O escalonador chega a essa decisão de alocação levando em consideração os princípios de programação descritos abaixo.</p><p>Se você quiser entender por que os Pods são alocados em um Node específico
ou se planeja implementar um escalonador personalizado, esta página ajudará você a
aprender sobre escalonamento.</p><h2 id=kube-scheduler>kube-scheduler</h2><p><a href=https://kubernetes.io/docs/reference/command-line-tools-reference/kube-scheduler/>kube-scheduler</a>
é o escalonador padrão do Kubernetes e é executado como parte do
<a class=glossary-tooltip title="A camada de gerenciamento de contêiner que expõe a API e as interfaces para definir, implantar e gerenciar o ciclo de vida dos contêineres." data-toggle=tooltip data-placement=top href="/pt/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label="control plane">control plane</a>.
O kube-scheduler é projetado para que, se você quiser e precisar, possa
escrever seu próprio componente de escalonamento e usá-lo.</p><p>Para cada Pod recém-criado ou outros Pods não escalonados, o kube-scheduler
seleciona um Node ideal para execução. No entanto, todos os contêineres nos Pods
têm requisitos diferentes de recursos e cada Pod também possui requisitos diferentes.
Portanto, os Nodes existentes precisam ser filtrados de acordo com os requisitos de
escalonamento específicos.</p><p>Em um cluster, Nodes que atendem aos requisitos de escalonamento para um Pod
são chamados de Nodes <em>viáveis</em>. Se nenhum dos Nodes for adequado, o Pod
permanece não escalonado até que o escalonador possa alocá-lo.</p><p>O escalonador encontra Nodes viáveis para um Pod e, em seguida, executa um conjunto de
funções para pontuar os Nodes viáveis e escolhe um Node com a maior
pontuação entre os possíveis para executar o Pod. O escalonador então notifica
o servidor da API sobre essa decisão em um processo chamado <em>binding</em>.</p><p>Fatores que precisam ser levados em consideração para decisões de escalonamento incluem
requisitos individuais e coletivos de recursos,
restrições de hardware / software / política, especificações de afinidade e anti-afinidade,
localidade de dados, interferência entre cargas de trabalho e assim por diante.</p><h3 id=implementação-kube-scheduler>Seleção do Node no kube-scheduler</h3><p>O kube-scheduler seleciona um Node para o Pod em uma operação que consiste em duas etapas:</p><ol><li>Filtragem</li><li>Pontuação</li></ol><p>A etapa de <em>filtragem</em> localiza o conjunto de Nodes onde é possível
alocar o Pod. Por exemplo, o filtro PodFitsResources verifica se um Node
candidato possui recursos disponíveis suficientes para atender às solicitações
de recursos específicas de um Pod. Após esta etapa, a lista de Nodes contém
quaisquer Nodes adequados; frequentemente, haverá mais de um. Se a lista estiver vazia,
esse Pod (ainda) não é escalonável.</p><p>Na etapa de <em>pontuação</em>, o escalonador classifica os Nodes restantes para escolher
o mais adequado. O escalonador atribui uma pontuação a cada Node
que sobreviveu à filtragem, baseando essa pontuação nas regras de pontuação ativa.</p><p>Por fim, o kube-scheduler atribui o Pod ao Node com a classificação mais alta.
Se houver mais de um Node com pontuações iguais, o kube-scheduler seleciona
um deles aleatoriamente.</p><p>Existem duas maneiras suportadas de configurar o comportamento de filtragem e pontuação
do escalonador:</p><ol><li><p><a href=/docs/reference/scheduling/policies>Políticas de Escalonamento</a> permitem configurar <em>Predicados</em> para filtragem e <em>Prioridades</em> para pontuação.</p></li><li><p><a href=/docs/reference/scheduling/profiles>Perfis de Escalonamento</a> permitem configurar Plugins que implementam diferentes estágios de escalonamento, incluindo: <code>QueueSort</code>, <code>Filter</code>, <code>Score</code>, <code>Bind</code>, <code>Reserve</code>, <code>Permit</code>, e outros. Você também pode configurar o kube-scheduler para executar diferentes perfis.</p></li></ol><h2 id=what-s-next>What's next</h2><ul><li>Leia sobre <a href=/docs/concepts/scheduling/scheduler-perf-tuning/>ajuste de desempenho do escalonador</a></li><li>Leia sobre <a href=/docs/concepts/workloads/pods/pod-topology-spread-constraints/>restrições de propagação da topologia de pod</a></li><li>Leia a <a href=/docs/reference/command-line-tools-reference/kube-scheduler/>documentação de referência</a> para o kube-scheduler</li><li>Aprenda como <a href=/docs/tasks/administer-cluster/configure-multiple-schedulers/>configurar vários escalonadores</a></li><li>Aprenda sobre <a href=/docs/tasks/administer-cluster/topology-manager/>políticas de gerenciamento de topologia</a></li><li>Aprenda sobre <a href=/docs/concepts/configuration/pod-overhead/>Pod Overhead</a></li><li>Saiba mais sobre o agendamento de pods que usam volumes em:<ul><li><a href=/docs/concepts/storage/storage-classes/#volume-binding-mode>Suporte de topologia de volume</a></li><li><a href=/docs/concepts/storage/storage-capacity/>Rastreamento de capacidade de armazenamento</a></li><li><a href=/docs/concepts/storage/storage-limits/>Limites de volumes específicos do nó</a></li></ul></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-da22fe2278df236f71efbe672f392677>6.2 - Sobrecarga de Pod</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code></div><p>Quando você executa um Pod num nó, o próprio Pod usa uma quantidade de recursos do sistema. Estes
recursos são adicionais aos recursos necessários para executar o(s) contêiner(s) dentro do Pod.
Sobrecarga de Pod, do inglês <em>Pod Overhead</em>, é uma funcionalidade que serve para contabilizar os recursos consumidos pela
infraestrutura do Pod para além das solicitações e limites do contêiner.</p><p>No Kubernetes, a sobrecarga de Pods é definido no tempo de
<a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#what-are-admission-webhooks>admissão</a>
de acordo com a sobrecarga associada à
<a href=/docs/concepts/containers/runtime-class/>RuntimeClass</a> do Pod.</p><p>Quando é ativada a Sobrecarga de Pod, a sobrecarga é considerada adicionalmente à soma das
solicitações de recursos do contêiner ao agendar um Pod. Semelhantemente, o <em>kubelet</em>
incluirá a sobrecarga do Pod ao dimensionar o cgroup do Pod e ao
executar a classificação de prioridade de migração do Pod em caso de <em>drain</em> do Node.</p><h2 id=set-up>Habilitando a Sobrecarga de Pod</h2><p>Terá de garantir que o <a href=/docs/reference/command-line-tools-reference/feature-gates/>Feature Gate</a>
<code>PodOverhead</code> esteja ativo (está ativo por padrão a partir da versão 1.18)
em todo o cluster, e uma <code>RuntimeClass</code> utilizada que defina o campo <code>overhead</code>.</p><h2 id=exemplo-de-uso>Exemplo de uso</h2><p>Para usar a funcionalidade PodOverhead, é necessário uma RuntimeClass que define o campo <code>overhead</code>.
Por exemplo, poderia usar a definição da RuntimeClass abaixo com um agente de execução de contêiner virtualizado
que use cerca de 120MiB por Pod para a máquina virtual e o sistema operacional convidado:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RuntimeClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>node.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kata-fc<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>handler</span>:<span style=color:#bbb> </span>kata-fc<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>overhead</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>podFixed</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;120Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;250m&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>As cargas de trabalho que são criadas e que especificam o manipulador RuntimeClass <code>kata-fc</code> irão
usar a sobrecarga de memória e cpu em conta para os cálculos da quota de recursos, agendamento de nós,
assim como dimensionamento do cgroup do Pod.</p><p>Considere executar a seguinte carga de trabalho de exemplo, test-pod:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>runtimeClassName</span>:<span style=color:#bbb> </span>kata-fc<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>stdin</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tty</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>500m<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>1500m<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span></code></pre></div><p>No tempo de admissão o <a href=https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/>controlador de admissão</a> RuntimeClass
atualiza o <em>PodSpec</em> da carga de trabalho de forma a incluir o <code>overhead</code> como descrito na RuntimeClass. Se o <em>PodSpec</em> já tiver este campo definido
o Pod será rejeitado. No exemplo dado, como apenas o nome do RuntimeClass é especificado, o controlador de admissão muda o Pod de forma a
incluir um <code>overhead</code>.</p><p>Depois do controlador de admissão RuntimeClass, pode verificar o <em>PodSpec</em> atualizado:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl get pod test-pod -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.spec.overhead}&#39;</span>
</code></pre></div><p>A saída é:</p><pre><code>map[cpu:250m memory:120Mi]
</code></pre><p>Se for definido um <em>ResourceQuota</em>, a soma das requisições dos contêineres assim como o campo <code>overhead</code> são contados.</p><p>Quando o kube-scheduler está decidindo que nó deve executar um novo Pod, o agendador considera o <code>overhead</code> do pod,
assim como a soma de pedidos aos contêineres para esse <em>Pod</em>. Para este exemplo, o agendador adiciona as requisições e a sobrecarga, depois procura um nó com 2.25 CPU e 320 MiB de memória disponível.</p><p>Assim que um Pod é agendado a um nó, o kubelet nesse nó cria um novo <a class=glossary-tooltip title="A group of Linux processes with optional resource isolation, accounting and limits." data-toggle=tooltip data-placement=top href="/pt/docs/reference/glossary/?all=true#term-cgroup" target=_blank aria-label=cgroup>cgroup</a>
para o Pod. É dentro deste Pod que o agente de execução de contêiners subjacente vai criar contêineres.</p><p>Se o recurso tiver um limite definido para cada contêiner (<em>QoS</em> garantida ou <em>Burstrable QoS</em> com limites definidos),
o kubelet definirá um limite superior para o cgroup do Pod associado a esse recurso (cpu.cfs_quota_us para CPU
e memory.limit_in_bytes de memória). Este limite superior é baseado na soma dos limites do contêiner mais o <code>overhead</code>
definido no <em>PodSpec</em>.</p><p>Para CPU, se o Pod for QoS garantida ou <em>Burstrable QoS</em>, o kubelet vai definir <code>cpu.shares</code> baseado na soma dos
pedidos ao contêiner mais o <code>overhead</code> definido no <em>PodSpec</em>.</p><p>Olhando para o nosso exemplo, verifique as requisições ao contêiner para a carga de trabalho:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl get pod test-pod -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.spec.containers[*].resources.limits}&#39;</span>
</code></pre></div><p>O total de requisições ao contêiner são 2000m CPU e 200MiB de memória:</p><pre><code>map[cpu: 500m memory:100Mi] map[cpu:1500m memory:100Mi]
</code></pre><p>Verifique isto comparado ao que é observado pelo nó:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl describe node | grep test-pod -B2
</code></pre></div><p>A saída mostra que 2250m CPU e 320MiB de memória são solicitados, que inclui <em>PodOverhead</em>:</p><pre><code>  Namespace                   Name                CPU Requests  CPU Limits   Memory Requests  Memory Limits  AGE
  ---------                   ----                ------------  ----------   ---------------  -------------  ---
  default                     test-pod            2250m (56%)   2250m (56%)  320Mi (1%)       320Mi (1%)     36m
</code></pre><h2 id=verificar-os-limites-cgroup-do-pod>Verificar os limites cgroup do Pod</h2><p>Verifique os cgroups de memória do Pod no nó onde a carga de trabalho está em execução. No seguinte exemplo, <a href=https://github.com/kubernetes-sigs/cri-tools/blob/master/docs/crictl.md><code>crictl</code></a>
é usado no nó, que fornece uma CLI para agentes de execução compatíveis com CRI. Isto é um
exemplo avançado para mostrar o comportamento do <em>PodOverhead</em>, e não é esperado que os usuários precisem verificar
cgroups diretamente no nó.</p><p>Primeiro, no nó em particular, determine o identificador do Pod:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># Execute no nó onde o Pod está agendado</span>
<span style=color:#b8860b>POD_ID</span><span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#a2f;font-weight:700>$(</span>sudo crictl pods --name test-pod -q<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#34;</span>
</code></pre></div><p>A partir disto, pode determinar o caminho do cgroup para o <em>Pod</em>:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># Execute no nó onde o Pod está agendado</span>
sudo crictl inspectp -o<span style=color:#666>=</span>json <span style=color:#b8860b>$POD_ID</span> | grep cgroupsPath
</code></pre></div><p>O caminho do cgroup resultante inclui o contêiner <code>pause</code> do Pod. O cgroup no nível do Pod está um diretório acima.</p><pre><code>        &quot;cgroupsPath&quot;: &quot;/kubepods/podd7f4b509-cf94-4951-9417-d1087c92a5b2/7ccf55aee35dd16aca4189c952d83487297f3cd760f1bbf09620e206e7d0c27a&quot;
</code></pre><p>Neste caso especifico, o caminho do cgroup do Pod é <code>kubepods/podd7f4b509-cf94-4951-9417-d1087c92a5b2</code>. Verifique a configuração cgroup de nível do Pod para a memória:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># Execute no nó onde o Pod está agendado</span>
<span style=color:#080;font-style:italic># Mude também o nome do cgroup para combinar com o cgroup alocado ao Pod.</span>
 cat /sys/fs/cgroup/memory/kubepods/podd7f4b509-cf94-4951-9417-d1087c92a5b2/memory.limit_in_bytes
</code></pre></div><p>Isto é 320 MiB, como esperado:</p><pre><code>335544320
</code></pre><h3 id=observabilidade>Observabilidade</h3><p>Uma métrica <code>kube_pod_overhead</code> está disponível em <a href=https://github.com/kubernetes/kube-state-metrics>kube-state-metrics</a>
para ajudar a identificar quando o <em>PodOverhead</em> está sendo utilizado e para ajudar a observar a estabilidade das cargas de trabalho
em execução com uma sobrecarga (<em>Overhead</em>) definida. Esta funcionalidade não está disponível na versão 1.9 do kube-state-metrics,
mas é esperado em uma próxima versão. Os usuários necessitarão entretanto construir o kube-state-metrics a partir do código fonte.</p><h2 id=what-s-next>What's next</h2><ul><li><a href=/docs/concepts/containers/runtime-class/>RuntimeClass</a></li><li><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/20190226-pod-overhead.md>PodOverhead Design</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-285a3785fd3d20f437c28d87ca4dadca>7 - Administração de Cluster</h1><div class=lead>Detalhes de baixo nível relevantes para criar ou administrar um cluster Kubernetes.</div><p>A visão geral da administração do cluster é para qualquer pessoa que crie ou administre um cluster do Kubernetes.
É pressuposto alguma familiaridade com os <a href=/docs/concepts>conceitos</a> principais do Kubernetes.</p><h2 id=planejando-um-cluster>Planejando um cluster</h2><p>Consulte os guias em <a href=/docs/setup>Configuração</a> para exemplos de como planejar, instalar e configurar clusters Kubernetes. As soluções listadas neste artigo são chamadas de <em>distros</em>.</p><blockquote class="note callout"><div><strong>Note:</strong> Nem todas as distros são mantidas ativamente. Escolha distros que foram testadas com uma versão recente do Kubernetes.</div></blockquote><p>Antes de escolher um guia, aqui estão algumas considerações:</p><ul><li>Você quer experimentar o Kubernetes em seu computador ou deseja criar um cluster de vários nós com alta disponibilidade? Escolha as distros mais adequadas ás suas necessidades.</li><li>Você vai usar um <strong>cluster Kubernetes gerenciado</strong> , como o <a href=https://cloud.google.com/kubernetes-engine/>Google Kubernetes Engine</a>, ou <strong>vai hospedar seu próprio cluster</strong>?</li><li>Seu cluster será <strong>local</strong>, ou <strong>na nuvem (IaaS)</strong>? O Kubernetes não oferece suporte direto a clusters híbridos. Em vez disso, você pode configurar vários clusters.</li><li><strong>Se você estiver configurando o Kubernetes local</strong>, leve em consideração qual <a href=/docs/concepts/cluster-Administration/networking>modelo de rede</a> se encaixa melhor.</li><li>Você vai executar o Kubernetes em um hardware <strong>bare metal</strong> ou em <strong>máquinas virtuais? (VMs)</strong>?</li><li>Você <strong>deseja apenas executar um cluster</strong> ou espera <strong>participar ativamente do desenvolvimento do código do projeto Kubernetes</strong>? Se for a segunda opção,
escolha uma distro desenvolvida ativamente. Algumas distros usam apenas versão binária, mas oferecem uma maior variedade de opções.</li><li>Familiarize-se com os <a href=/docs/concepts/overview/components/>componentes</a> necessários para executar um cluster.</li></ul><h2 id=gerenciando-um-cluster>Gerenciando um cluster</h2><ul><li>Aprenda como <a href=/docs/concepts/architecture/nodes/>gerenciar nós</a>.</li><li>Aprenda a configurar e <a href=/docs/concepts/policy/resource-quotas/>gerenciar a quota de recursos</a> para clusters compartilhados.</li></ul><h2 id=protegendo-um-cluster>Protegendo um cluster</h2><ul><li><p><a href=/docs/tasks/administer-cluster/certificates/>Gerar Certificados</a> descreve os passos para gerar certificados usando diferentes cadeias de ferramentas.</p></li><li><p><a href=/docs/concepts/containers/container-environment/>Ambiente de Contêineres do Kubernetes</a> descreve o ambiente para contêineres gerenciados pelo kubelet em um nó Kubernetes.</p></li><li><p><a href=/docs/concepts/security/controlling-access>Controle de Acesso a API do Kubernetes</a> descreve como o Kubernetes implementa o controle de acesso para sua própria API.</p></li><li><p><a href=/docs/reference/access-authn-authz/authentication/>Autenticação</a> explica a autenticação no Kubernetes, incluindo as várias opções de autenticação.</p></li><li><p><a href=/docs/reference/access-authn-authz/authorization/>Autorização</a> é separado da autenticação e controla como as chamadas HTTP são tratadas.</p></li><li><p><a href=/docs/reference/access-authn-authz/admission-controllers/>Usando Controladores de Admissão</a> explica plugins que interceptam requisições para o servidor da API Kubernetes após
a autenticação e autorização.</p></li><li><p><a href=/docs/tasks/administer-cluster/sysctl-cluster/>usando Sysctl em um Cluster Kubernetes</a> descreve a um administrador como usar a ferramenta de linha de comando <code>sysctl</code> para
definir os parâmetros do kernel.</p></li><li><p><a href=/docs/tasks/debug-application-cluster/audit/>Auditoria</a> descreve como interagir com <em>logs</em> de auditoria do Kubernetes.</p></li></ul><h3 id=protegendo-o-kubelet>Protegendo o kubelet</h3><ul><li><a href=/docs/concepts/architecture/control-plane-node-communication/>Comunicação Control Plane-Nó</a></li><li><a href=/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>TLS bootstrapping</a></li><li><a href=/docs/reference/command-line-tools-reference/kubelet-authentication-authorization/>Autenticação/autorização do kubelet</a></li></ul><h2 id=serviços-opcionais-para-o-cluster>Serviços Opcionais para o Cluster</h2><ul><li><p><a href=/docs/concepts/services-networking/dns-pod-service/>Integração com DNS</a> descreve como resolver um nome DNS diretamente para um serviço Kubernetes.</p></li><li><p><a href=/docs/concepts/cluster-administration/logging/>Registro e Monitoramento da Atividade do Cluster</a> explica como funciona o <em>logging</em> no Kubernetes e como implementá-lo.</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-fb494ea3b1874bd753dcd11c3f35c2dc>7.1 - Visão Geral da Administração de Cluster</h1><p>A visão geral da administração de cluster é para qualquer um criando ou administrando um cluster Kubernetes. Assume-se que você tenha alguma familiaridade com os <a href=/docs/concepts/>conceitos</a> centrais do Kubernetes.</p><h2 id=planejando-um-cluster>Planejando um cluster</h2><p>Veja os guias em <a href=/docs/setup/>Setup</a> para exemplos de como planejar, iniciar e configurar clusters Kubernetes. As soluções listadas neste artigo são chamadas <em>distros</em>.</p><p>Antes de escolher um guia, aqui estão algumas considerações.</p><ul><li><p>Você quer experimentar o Kubernetes no seu computador, ou você quer construir um cluster de alta disponibilidade e multi-nós? Escolha as distros mais adequadas às suas necessidades.</p></li><li><p><strong>Se você esta projetando para alta-disponibilidade</strong>, saiba mais sobre configuração <a href=/docs/concepts/cluster-administration/federation/>clusters em múltiplas zonas</a>.</p></li><li><p>Você usará <strong>um cluster Kubernetes hospedado</strong>, como <a href=https://cloud.google.com/kubernetes-engine/>Google Kubernetes Engine</a>, ou <strong>hospedará seu próprio cluster</strong>?</p></li><li><p>Seu cluster será <strong>on-premises</strong>, ou <strong>in the cloud (IaaS)</strong>? Kubernetes não suporta diretamente clusters híbridos. Em vez disso, você pode configurar vários clusters.</p></li><li><p><strong>Se você estiver configurando um Kubernetes on-premisess</strong>, considere qual <a href=/docs/concepts/cluster-administration/networking/>modelo de rede</a> melhor se adequa.</p></li><li><p>Você estará executando o Kubernetes em hardware <strong>"bare metal"</strong> ou em <strong>máquinas virtuais (VMs)</strong>?</p></li><li><p>Você <strong>quer apenas rodar um cluster</strong>, ou você espera fazer <strong>desenvolvimento ativo do código de projeto do Kubernetes</strong>? Se for a segunda opção, escolha uma distro mais ativa. Algumas distros fornecem apenas binários, mas oferecem uma maior variedade de opções.</p></li><li><p>Familiarize-se com os <a href=/docs/admin/cluster-components/>componentes</a> necessários para rodar um cluster.</p></li></ul><p>Nota: Nem todas as distros são ativamente mantidas. Escolha as distros que foram testadas com uma versão recente do Kubernetes.</p><h2 id=gerenciando-um-cluster>Gerenciando um cluster</h2><ul><li><p><a href=/docs/tasks/administer-cluster/cluster-management/>Gerenciando um cluster</a> descreve vários tópicos relacionados ao ciclo de vida de um cluster: criando um novo cluster, atualizando o nó mestre e os nós de trabalho do cluster, executando manutenção de nó (por exemplo, atualizações de kernel) e atualizando a versão da API do Kubernetes de um cluster em execução.</p></li><li><p>Aprender como <a href=/docs/concepts/nodes/node/>gerenciar um nó</a>.</p></li><li><p>Aprender como configurar e gerenciar o <a href=/docs/concepts/policy/resource-quotas/>recurso de quota</a> para um cluster compartilhado.</p></li></ul><h2 id=protegendo-um-cluster>Protegendo um cluster</h2><ul><li><p><a href=/docs/concepts/cluster-administration/certificates/>Certificados</a> descreve as etapas para gerar certificados usando diferentes ferramentas.</p></li><li><p><a href=/docs/concepts/containers/container-environment-variables/>Ambiente de Container Kubernetes</a> descreve o ambiente para contêineres gerenciados pelo Kubelet em um nó do Kubernetes.</p></li><li><p><a href=/docs/reference/access-authn-authz/controlling-access/>Controlando Acesso a API Kubernetes API</a> descreve como configurar
a permissão para usuários e contas de serviço.</p></li><li><p><a href=/docs/reference/access-authn-authz/authentication/>Autenticando</a> explica a autenticação no Kubernetes, incluindo as várias opções de autenticação.</p></li><li><p><a href=/docs/reference/access-authn-authz/authorization/>Autorização</a> é separada da autenticação e controla como as chamadas HTTP são tratadas.</p></li><li><p><a href=/docs/reference/access-authn-authz/admission-controllers/>Usando Controladores de Admissão</a> explica plug-ins que interceptam solicitações ao servidor da API do Kubernetes após autenticação e autorização.</p></li><li><p><a href=/docs/concepts/cluster-administration/sysctl-cluster/>Usando Sysctls em um Cluster Kubernetes</a> descreve a um administrador como usar a ferramenta de linha de comando <code>sysctl</code> para definir os parâmetros do kernel.</p></li><li><p><a href=/docs/tasks/debug-application-cluster/audit/>Auditando</a>
descreve como interagir com os logs de auditoria do Kubernetes.</p></li></ul><h3 id=protegendo-o-kubelet>Protegendo o kubelet</h3><ul><li><a href=/docs/concepts/architecture/master-node-communication/>Comunicação Master-Node</a></li><li><a href=/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>TLS bootstrapping</a></li><li><a href=/docs/admin/kubelet-authentication-authorization/>Autenticação/Autorização Kubelet</a></li></ul><h2 id=serviços-opcionais-do-cluster>Serviços Opcionais do Cluster</h2><ul><li><p><a href=/docs/concepts/services-networking/dns-pod-service/>Integração DNS</a> descreve como resolver um nome DNS diretamente para um serviço do Kubernetes.</p></li><li><p><a href=/docs/concepts/cluster-administration/logging/>Logando e monitorando a atividade de cluster</a> explica como o log funciona no Kubernetes e como implementá-lo.</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-2bf9a93ab5ba014fb6ff70b22c29d432>7.2 - Certificates</h1><p>Ao usar um client para autenticação de certificado, você pode gerar certificados
manualmente através <code>easyrsa</code>, <code>openssl</code> ou <code>cfssl</code>.</p><h3 id=easyrsa>easyrsa</h3><p><strong>easyrsa</strong> pode gerar manualmente certificados para o seu cluster.</p><ol><li><p>Baixe, descompacte e inicialize a versão corrigida do easyrsa3.</p><pre><code>curl -LO https://storage.googleapis.com/kubernetes-release/easy-rsa/easy-rsa.tar.gz
tar xzf easy-rsa.tar.gz
cd easy-rsa-master/easyrsa3
./easyrsa init-pki
</code></pre></li><li><p>Gerar o CA. (<code>--batch</code> set automatic mode. <code>--req-cn</code> default CN to use.)</p><pre><code>./easyrsa --batch &quot;--req-cn=${MASTER_IP}@`date +%s`&quot; build-ca nopass
</code></pre></li><li><p>Gere o certificado e a chave do servidor.
O argumento <code>--subject-alt-name</code> define os possíveis IPs e nomes (DNS) que o servidor de API usará para ser acessado. O <code>MASTER_CLUSTER_IP</code> é geralmente o primeiro IP do serviço CIDR que é especificado como argumento em <code>--service-cluster-ip-range</code> para o servidor de API e o componente gerenciador do controlador. O argumento <code>--days</code> é usado para definir o número de dias após o qual o certificado expira.
O exemplo abaixo também assume que você está usando <code>cluster.local</code> como DNS de domínio padrão</p><pre><code>./easyrsa --subject-alt-name=&quot;IP:${MASTER_IP},&quot;\
&quot;IP:${MASTER_CLUSTER_IP},&quot;\
&quot;DNS:kubernetes,&quot;\
&quot;DNS:kubernetes.default,&quot;\
&quot;DNS:kubernetes.default.svc,&quot;\
&quot;DNS:kubernetes.default.svc.cluster,&quot;\
&quot;DNS:kubernetes.default.svc.cluster.local&quot; \
--days=10000 \
build-server-full server nopass
</code></pre></li><li><p>Copie <code>pki/ca.crt</code>, <code>pki/issued/server.crt</code>, e <code>pki/private/server.key</code> para o seu diretório.</p></li><li><p>Preencha e adicione os seguintes parâmetros aos parâmetros de inicialização do servidor de API:</p><pre><code>--client-ca-file=/yourdirectory/ca.crt
--tls-cert-file=/yourdirectory/server.crt
--tls-private-key-file=/yourdirectory/server.key
</code></pre></li></ol><h3 id=openssl>openssl</h3><p><strong>openssl</strong> pode gerar manualmente certificados para o seu cluster.</p><ol><li><p>Gere um ca.key com 2048bit:</p><pre><code>openssl genrsa -out ca.key 2048
</code></pre></li><li><p>De acordo com o ca.key, gere um ca.crt (use -days para definir o tempo efetivo do certificado):</p><pre><code> openssl req -x509 -new -nodes -key ca.key -subj &quot;/CN=${MASTER_IP}&quot; -days 10000 -out ca.crt
</code></pre></li><li><p>Gere um server.key com 2048bit:</p><pre><code>openssl genrsa -out server.key 2048
</code></pre></li><li><p>Crie um arquivo de configuração para gerar uma solicitação de assinatura de certificado (CSR - Certificate Signing Request). Certifique-se de substituir os valores marcados com colchetes angulares (por exemplo, <code>&lt;MASTER_IP></code>) com valores reais antes de salvá-lo em um arquivo (por exemplo, <code>csr.conf</code>). Note que o valor para o <code>MASTER_CLUSTER_IP</code> é o IP do cluster de serviços para o Servidor de API, conforme descrito na subseção anterior. O exemplo abaixo também assume que você está usando <code>cluster.local</code> como DNS de domínio padrão</p><pre><code>[ req ]
default_bits = 2048
prompt = no
default_md = sha256
req_extensions = req_ext
distinguished_name = dn

[ dn ]
C = &lt;country&gt;
ST = &lt;state&gt;
L = &lt;city&gt;
O = &lt;organization&gt;
OU = &lt;organization unit&gt;
CN = &lt;MASTER_IP&gt;

[ req_ext ]
subjectAltName = @alt_names

[ alt_names ]
DNS.1 = kubernetes
DNS.2 = kubernetes.default
DNS.3 = kubernetes.default.svc
DNS.4 = kubernetes.default.svc.cluster
DNS.5 = kubernetes.default.svc.cluster.local
IP.1 = &lt;MASTER_IP&gt;
IP.2 = &lt;MASTER_CLUSTER_IP&gt;

[ v3_ext ]
authorityKeyIdentifier=keyid,issuer:always
basicConstraints=CA:FALSE
keyUsage=keyEncipherment,dataEncipherment
extendedKeyUsage=serverAuth,clientAuth
subjectAltName=@alt_names
</code></pre></li><li><p>Gere a solicitação de assinatura de certificado com base no arquivo de configuração:</p><pre><code>openssl req -new -key server.key -out server.csr -config csr.conf
</code></pre></li><li><p>Gere o certificado do servidor usando o ca.key, ca.crt e server.csr:</p><pre><code>openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key \
-CAcreateserial -out server.crt -days 10000 \
-extensions v3_ext -extfile csr.conf
</code></pre></li><li><p>Veja o certificado:</p><pre><code>openssl x509  -noout -text -in ./server.crt
</code></pre></li></ol><p>Por fim, adicione os mesmos parâmetros nos parâmetros iniciais do Servidor de API.</p><h3 id=cfssl>cfssl</h3><p><strong>cfssl</strong> é outra ferramenta para geração de certificados.</p><ol><li><p>Baixe, descompacte e prepare as ferramentas de linha de comando, conforme mostrado abaixo. Observe que você pode precisar adaptar os comandos de exemplo abaixo com base na arquitetura do hardware e versão cfssl que você está usando.</p><pre><code>curl -L https://pkg.cfssl.org/R1.2/cfssl_linux-amd64 -o cfssl
chmod +x cfssl
curl -L https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64 -o cfssljson
chmod +x cfssljson
curl -L https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64 -o cfssl-certinfo
chmod +x cfssl-certinfo
</code></pre></li><li><p>Crie um diretório para conter os artefatos e inicializar o cfssl:</p><pre><code>mkdir cert
cd cert
../cfssl print-defaults config &gt; config.json
../cfssl print-defaults csr &gt; csr.json
</code></pre></li><li><p>Crie um arquivo de configuração JSON para gerar o arquivo CA, por exemplo, <code>ca-config.json</code>:</p><pre><code>{
  &quot;signing&quot;: {
    &quot;default&quot;: {
      &quot;expiry&quot;: &quot;8760h&quot;
    },
    &quot;profiles&quot;: {
      &quot;kubernetes&quot;: {
        &quot;usages&quot;: [
          &quot;signing&quot;,
          &quot;key encipherment&quot;,
          &quot;server auth&quot;,
          &quot;client auth&quot;
        ],
        &quot;expiry&quot;: &quot;8760h&quot;
      }
    }
  }
}
</code></pre></li><li><p>Crie um arquivo de configuração JSON para o CA - solicitação de assinatura de certificado (CSR - Certificate Signing Request), por exemplo, <code>ca-csr.json</code>. Certifique-se de substituir os valores marcados com colchetes angulares por valores reais que você deseja usar.</p><pre><code>{
  &quot;CN&quot;: &quot;kubernetes&quot;,
  &quot;key&quot;: {
    &quot;algo&quot;: &quot;rsa&quot;,
    &quot;size&quot;: 2048
  },
  &quot;names&quot;:[{
    &quot;C&quot;: &quot;&lt;country&gt;&quot;,
    &quot;ST&quot;: &quot;&lt;state&gt;&quot;,
    &quot;L&quot;: &quot;&lt;city&gt;&quot;,
    &quot;O&quot;: &quot;&lt;organization&gt;&quot;,
    &quot;OU&quot;: &quot;&lt;organization unit&gt;&quot;
  }]
}
</code></pre></li><li><p>Gere a chave CA (<code>ca-key.pem</code>) e o certificado (<code> ca.pem</code>):</p><pre><code>../cfssl gencert -initca ca-csr.json | ../cfssljson -bare ca
</code></pre></li><li><p>Crie um arquivo de configuração JSON para gerar chaves e certificados para o Servidor de API, por exemplo, <code>server-csr.json</code>. Certifique-se de substituir os valores entre colchetes angulares por valores reais que você deseja usar. O <code>MASTER_CLUSTER_IP</code> é o IP do serviço do cluster para o servidor da API, conforme descrito na subseção anterior. O exemplo abaixo também assume que você está usando <code>cluster.local</code> como DNS de domínio padrão</p><pre><code>{
  &quot;CN&quot;: &quot;kubernetes&quot;,
  &quot;hosts&quot;: [
    &quot;127.0.0.1&quot;,
    &quot;&lt;MASTER_IP&gt;&quot;,
    &quot;&lt;MASTER_CLUSTER_IP&gt;&quot;,
    &quot;kubernetes&quot;,
    &quot;kubernetes.default&quot;,
    &quot;kubernetes.default.svc&quot;,
    &quot;kubernetes.default.svc.cluster&quot;,
    &quot;kubernetes.default.svc.cluster.local&quot;
  ],
  &quot;key&quot;: {
    &quot;algo&quot;: &quot;rsa&quot;,
    &quot;size&quot;: 2048
  },
  &quot;names&quot;: [{
    &quot;C&quot;: &quot;&lt;country&gt;&quot;,
    &quot;ST&quot;: &quot;&lt;state&gt;&quot;,
    &quot;L&quot;: &quot;&lt;city&gt;&quot;,
    &quot;O&quot;: &quot;&lt;organization&gt;&quot;,
    &quot;OU&quot;: &quot;&lt;organization unit&gt;&quot;
  }]
}
</code></pre></li><li><p>Gere a chave e o certificado para o Servidor de API, que são, por padrão, salvos nos arquivos <code>server-key.pem</code> e<code> server.pem</code> respectivamente:</p><pre><code>../cfssl gencert -ca=ca.pem -ca-key=ca-key.pem \
--config=ca-config.json -profile=kubernetes \
server-csr.json | ../cfssljson -bare server
</code></pre></li></ol><h2 id=distribuindo-certificado-ca-auto-assinado>Distribuindo Certificado CA auto assinado</h2><p>Um nó cliente pode se recusar a reconhecer o certificado CA self-signed como válido.
Para uma implementação de não produção ou para uma instalação que roda atrás de um firewall, você pode distribuir certificados auto-assinados para todos os clientes e atualizar a lista de certificados válidos.</p><p>Em cada cliente, execute as seguintes operações:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo cp ca.crt /usr/local/share/ca-certificates/kubernetes.crt
sudo update-ca-certificates
</code></pre></div><pre><code>Updating certificates in /etc/ssl/certs...
1 added, 0 removed; done.
Running hooks in /etc/ca-certificates/update.d....
done.
</code></pre><h2 id=api-de-certificados>API de certificados</h2><p>Você pode usar a API <code>certificates.k8s.io</code> para provisionar
certificados x509 a serem usados ​​para autenticação conforme documentado
<a href=/docs/tasks/tls/managing-tls-in-a-cluster>aqui</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-d649067a69d8d5c7e71564b42b96909e>7.3 - Conectividade do Cluster</h1><p>Conectividade é uma parte central do Kubernetes, mas pode ser desafiador
entender exatamente como é o seu funcionamento esperado. Existem 4 problemas
distintos em conectividade que devem ser tratados:</p><ol><li>Comunicações contêiner-para-contêiner altamente acopladas: Isso é resolvido
por <a class=glossary-tooltip title="O menor e mais simples objeto Kubernetes. Um Pod representa um conjunto de contêineres em execução no seu cluster." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pods>Pods</a> e comunicações através do <code>localhost</code>.</li><li>Comunicações pod-para-pod: Esse é o foco primário desse documento.</li><li>Comunicações pod-para-serviço (<em>service</em>): Isso é tratado em <a href=/docs/concepts/services-networking/service/>Services</a>.</li><li>Comunicações Externas-para-serviços: Isso é tratado em <a href=/docs/concepts/services-networking/service/>services</a>.</li></ol><p>Kubernetes é basicamente o compartilhamento de máquinas entre aplicações. Tradicionalmente,
compartilhar máquinas requer a garantia de que duas aplicações não tentem utilizar
as mesmas portas. Coordenar a alocação de portas entre múltiplos desenvolvedores é
muito dificil de fazer em escala e expõe os usuários a problemas em nível do cluster e
fora de seu controle.</p><p>A alocação dinâmica de portas traz uma série de complicações para o sistema - toda
aplicação deve obter suas portas através de flags de configuração, os servidores de API
devem saber como inserir números dinämicos de portas nos blocos de configuração, serviços
precisam saber como buscar um ao outro, etc. Ao invés de lidar com isso, o Kubernetes
faz de uma maneira diferente.</p><h2 id=o-modelo-de-conectividade-e-rede-do-kubernetes>O modelo de conectividade e rede do Kubernetes</h2><p>Todo <code>Pod</code> obtém seu próprio endereço IP. Isso significa que vocë não precisa
criar links explícitos entre os <code>Pods</code> e vocë quase nunca terá que lidar com o
mapeamento de portas de contêineres para portas do host. Isso cria um modelo simples,
retro-compatível onde os <code>Pods</code> podem ser tratados muito mais como VMs ou hosts
físicos da perspectiva de alocação de portas, nomes, descobrimento de serviços
(<em>service discovery</em>), balanceamento de carga, configuração de aplicações e migrações.</p><p>O Kubernetes impõe os seguintes requisitos fundamentais para qualquer implementação de
rede (exceto qualquer política de segmentação intencional):</p><ul><li>pods em um nó podem se comunicar com todos os pods em todos os nós sem usar <em>NAT</em>.</li><li>agentes em um nó (por exemplo o kubelet ou um serviço local) podem se comunicar com
todos os Pods naquele nó.</li></ul><p>Nota: Para as plataformas que suportam <code>Pods</code> executando na rede do host (como o Linux):</p><ul><li>pods alocados na rede do host de um nó podem se comunicar com todos os pods
em todos os nós sem <em>NAT</em>.</li></ul><p>Esse modelo não só é menos complexo, mas é principalmente compatível com o
desejo do Kubernetes de permitir a portabilidade com baixo esforço de aplicações
de VMs para contêineres. Se a sua aplicação executava anteriormente em uma VM, sua VM
possuía um IP e podia se comunicar com outras VMs no seu projeto. Esse é o mesmo
modelo básico.</p><p>Os endereços de IP no Kubernetes existem no escopo do <code>Pod</code> - contêineres em um <code>Pod</code>
compartilham o mesmo <em>network namespace</em> - incluíndo seu endereço de IP e MAC.
Isso significa que contêineres que compõem um <code>Pod</code> podem se comunicar entre eles
através do endereço <code>localhost</code> e respectivas portas. Isso também significa que
contêineres em um mesmo <code>Pod</code> devem coordenar a alocação e uso de portas, o que não
difere do modelo de processos rodando dentro de uma mesma VM. Isso é chamado de
modelo "IP-por-pod".</p><p>Como isso é implementado é um detalhe do agente de execução de contêiner em uso.</p><p>É possível solicitar uma porta no nó que será encaminhada para seu <code>Pod</code> (chamado
de <em>portas do host</em>), mas isso é uma operação muito específica. Como esse encaminhamento
é implementado é um detalhe do agente de execução do contêiner. O <code>Pod</code> mesmo
desconhece a existência ou não de portas do host.</p><h2 id=como-implementar-o-modelo-de-conectividade-do-kubernetes>Como implementar o modelo de conectividade do Kubernetes</h2><p>Existe um número de formas de implementar esse modelo de conectividade. Esse
documento não é um estudo exaustivo desses vários métodos, mas pode servir como
uma introdução de várias tecnologias e serve como um ponto de início.</p><p>A conectividade no Kubernetes é fornecida através de plugins de
<a class=glossary-tooltip title="Plugins Container network interface (CNI) são um tipo de plugin de Rede em conformidade com a especificação appc/CNI." data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/#cni target=_blank aria-label=CNIs>CNIs</a></p><p>As seguintes opções estão organizadas alfabeticamente e não implicam preferência por
qualquer solução.</p><blockquote class="callout caution" role=alert><strong>Caution:</strong>
This section links to third party projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for these projects. This page follows <a href=https://github.com/cncf/foundation/blob/master/website-guidelines.md target=_blank>CNCF website guidelines</a> by listing projects alphabetically. To add a project to this list, read the <a href=/docs/contribute/style/content-guide/#third-party-content>content guide</a> before submitting a change.</blockquote><h3 id=antrea>Antrea</h3><p>O projeto <a href=https://github.com/vmware-tanzu/antrea>Antrea</a> é uma solução de
conectividade para Kubernetes que pretende ser nativa. Ela utiliza o Open vSwitch
na camada de conectividade de dados. O Open vSwitch é um switch virtual de alta
performance e programável que suporta Linux e Windows. O Open vSwitch permite
ao Antrea implementar políticas de rede do Kubernetes (<em>NetworkPolicies</em>) de
uma forma muito performática e eficiente.</p><p>Graças à característica programável do Open vSwitch, o Antrea consegue implementar
uma série de funcionalidades de rede e segurança.</p><h3 id=aws-vpc-cni-para-kubernetes>AWS VPC CNI para Kubernetes</h3><p>O <a href=https://github.com/aws/amazon-vpc-cni-k8s>AWS VPC CNI</a> oferece conectividade
com o AWS Virtual Private Cloud (VPC) para clusters Kubernetes. Esse plugin oferece
alta performance e disponibilidade e baixa latência. Adicionalmente, usuários podem
aplicar as melhores práticas de conectividade e segurança existentes no AWS VPC
para a construção de clusters Kubernetes. Isso inclui possibilidade de usar o
<em>VPC flow logs</em>, políticas de roteamento da VPC e grupos de segurança para isolamento
de tráfego.</p><p>O uso desse plugin permite aos Pods no Kubernetes ter o mesmo endereço de IP dentro do
pod como se eles estivessem dentro da rede do VPC. O CNI (Container Network Interface)
aloca um <em>Elastic Networking Interface</em> (ENI) para cada nó do Kubernetes e usa uma
faixa de endereços IP secundário de cada ENI para os Pods no nó. O CNI inclui
controles para pré alocação dos ENIs e endereços IP para um início mais rápido dos
pods e permite clusters com até 2,000 nós.</p><p>Adicionalmente, esse CNI pode ser utilizado junto com o <a href=https://docs.aws.amazon.com/eks/latest/userguide/calico.html>Calico</a>
para a criação de políticas de rede (<em>NetworkPolicies</em>). O projeto AWS VPC CNI
tem código fonte aberto com a <a href=https://github.com/aws/amazon-vpc-cni-k8s>documentação no Github</a>.</p><h3 id=azure-cni-para-o-kubernetes>Azure CNI para o Kubernetes</h3><p><a href=https://docs.microsoft.com/en-us/azure/virtual-network/container-networking-overview>Azure CNI</a> é um
plugin de <a href=https://github.com/Azure/azure-container-networking/blob/master/docs/cni.md>código fonte aberto</a>
que integra os Pods do Kubernetes com uma rede virtual da Azure (também conhecida como VNet)
provendo performance de rede similar à de máquinas virtuais no ambiente. Os Pods
podem se comunicar com outras VNets e com ambientes <em>on-premises</em> com o uso de
funcionalidades da Azure, e também podem ter clientes com origem dessas redes.
Os Pods podem acessar serviços da Azure, como armazenamento e SQL, que são
protegidos por <em>Service Endpoints</em> e <em>Private Link</em>. Você pode utilizar as políticas
de segurança e roteamento para filtrar o tráfico do Pod. O plugin associa IPs da VNet
para os Pods utilizando um pool de IPs secundário pré-configurado na interface de rede
do nó Kubernetes.</p><p>O Azure CNI está disponível nativamente no <a href=https://docs.microsoft.com/en-us/azure/aks/configure-azure-cni>Azure Kubernetes Service (AKS)</a>.</p><h3 id=calico>Calico</h3><p><a href=https://docs.projectcalico.org/>Calico</a> é uma solução de conectividade e
segurança para contêineres, máquinas virtuais e serviços nativos em hosts. O
Calico suporta múltiplas camadas de conectividade/dados, como por exemplo:
uma camada Linux eBPF nativa, uma camada de conectividade baseada em conceitos
padrão do Linux e uma camada baseada no HNS do Windows. O calico provê uma
camada completa de conectividade e rede, mas também pode ser usado em conjunto com
<a href=https://docs.projectcalico.org/networking/determine-best-networking#calico-compatible-cni-plugins-and-cloud-provider-integrations>CNIs de provedores de nuvem</a>
para permitir a criação de políticas de rede.</p><h3 id=cilium>Cilium</h3><p><a href=https://github.com/cilium/cilium>Cilium</a> é um software de código fonte aberto
para prover conectividade e segurança entre contêineres de aplicação. O Cilium
pode lidar com tráfego na camada de aplicação (ex. HTTP) e pode forçar políticas
de rede nas camadas L3-L7 usando um modelo de segurança baseado em identidade e
desacoplado do endereçamento de redes, podendo inclusive ser utilizado com outros
plugins CNI.</p><h3 id=flannel>Flannel</h3><p><a href=https://github.com/coreos/flannel#flannel>Flannel</a> é uma camada muito simples
de conectividade que satisfaz os requisitos do Kubernetes. Muitas pessoas
reportaram sucesso em utilizar o Flannel com o Kubernetes.</p><h3 id=google-compute-engine-gce>Google Compute Engine (GCE)</h3><p>Para os scripts de configuração do Google Compute Engine, <a href=https://cloud.google.com/vpc/docs/routes>roteamento
avançado</a> é usado para associar
para cada VM uma sub-rede (o padrão é <code>/24</code> - 254 IPs). Qualquer tráfico direcionado
para aquela sub-rede será roteado diretamente para a VM pela rede do GCE. Isso é
adicional ao IP principal associado à VM, que é mascarado para o acesso à Internet.
Uma <em>brige</em> Linux (chamada <code>cbr0</code>) é configurada para existir naquela sub-rede, e é
configurada no docker através da opção <code>--bridge</code>.</p><p>O Docker é iniciado com:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>DOCKER_OPTS</span><span style=color:#666>=</span><span style=color:#b44>&#34;--bridge=cbr0 --iptables=false --ip-masq=false&#34;</span>
</code></pre></div><p>Essa <em>bridge</em> é criada pelo Kubelet (controlada pela opção <code>--network-plugin=kubenet</code>)
de acordo com a informação <code>.spec.podCIDR</code> do Nó.</p><p>O Docker irá agora alocar IPs do bloco <code>cbr-cidr</code>. Contêineres podem alcançar
outros contêineres e nós através da interface <code>cbr0</code>. Esses IPs são todos roteáveis
dentro da rede do projeto do GCE.</p><p>O GCE mesmo não sabe nada sobre esses IPs, então não irá mascará-los quando tentarem
se comunicar com a internet. Para permitir isso uma regra de IPTables é utilizada para
mascarar o tráfego para IPs fora da rede do projeto do GCE (no exemplo abaixo, 10.0.0.0/8):</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>iptables -t nat -A POSTROUTING ! -d 10.0.0.0/8 -o eth0 -j MASQUERADE
</code></pre></div><p>Por fim, o encaminhamento de IP deve ser habilitado no Kernel de forma a processar
os pacotes vindos dos contêineres:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sysctl net.ipv4.ip_forward<span style=color:#666>=</span><span style=color:#666>1</span>
</code></pre></div><p>O resultado disso tudo é que <code>Pods</code> agora podem alcançar outros <code>Pods</code> e podem também
se comunicar com a Internet.</p><h3 id=kube-router>Kube-router</h3><p><a href=https://github.com/cloudnativelabs/kube-router>Kube-router</a> é uma solução construída
que visa prover alta performance e simplicidade operacional. Kube-router provê um
proxy de serviços baseado no <a href=https://www.linuxvirtualserver.org/software/ipvs.html>LVS/IPVS</a>,
uma solução de comunicação pod-para-pod baseada em encaminhamento de pacotes Linux e sem camadas
adicionais, e funcionalidade de políticas de redes baseadas no IPTables/IPSet.</p><h3 id=redes-l2-e-bridges-linux>Redes L2 e bridges Linux</h3><p>Se você tem uma rede L2 "burra", como um switch em um ambiente "bare-metal",
você deve conseguir fazer algo similar ao ambiente GCE explicado acima.
Note que essas instruções foram testadas casualmente - parece funcionar, mas
não foi propriamente testado. Se você conseguir usar essa técnica e aperfeiçoar
o processo, por favor nos avise!!</p><p>Siga a parte <em>"With Linux Bridge devices"</em> desse
<a href=https://blog.oddbit.com/2014/08/11/four-ways-to-connect-a-docker/>tutorial super bacana</a> do
Lars Kellogg-Stedman.</p><h3 id=multus>Multus (Plugin multi redes)</h3><p><a href=https://github.com/Intel-Corp/multus-cni>Multus</a> é um plugin Multi CNI para
suportar a funcionalidade multi redes do Kubernetes usando objetos baseados em <a class=glossary-tooltip title="Código customizado que define um recurso a ser adicionado ao seu servidor de API Kubernetes sem a necessidade de construir um servidor customizado." data-toggle=tooltip data-placement=top href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/ target=_blank aria-label=CRDs>CRDs</a>.</p><p>Multus suporta todos os <a href=https://github.com/containernetworking/plugins>plugins referência</a> (ex. <a href=https://github.com/containernetworking/plugins/tree/master/plugins/meta/flannel>Flannel</a>,
<a href=https://github.com/containernetworking/plugins/tree/master/plugins/ipam/dhcp>DHCP</a>,
<a href=https://github.com/containernetworking/plugins/tree/master/plugins/main/macvlan>Macvlan</a>)
que implementam a especificação de CNI e plugins de terceiros
(ex. <a href=https://github.com/projectcalico/cni-plugin>Calico</a>, <a href=https://github.com/weaveworks/weave>Weave</a>,
<a href=https://github.com/cilium/cilium>Cilium</a>, <a href=https://github.com/contiv/netplugin>Contiv</a>).
Adicionalmente, Multus suporta cargas de trabalho no Kubernetes que necessitem de funcionalidades como
<a href=https://github.com/hustcat/sriov-cni>SRIOV</a>, <a href=https://github.com/Intel-Corp/sriov-cni>DPDK</a>,
<a href=https://github.com/intel/vhost-user-net-plugin>OVS-DPDK & VPP</a>.</p><h3 id=ovn-open-virtual-networking>OVN (Open Virtual Networking)</h3><p>OVN é uma solução de virtualização de redes de código aberto desenvolvido pela
comunidade Open vSwitch. Permite a criação de switches lógicos, roteadores lógicos,
listas de acesso, balanceadores de carga e mais, para construir diferences topologias
de redes virtuais. Esse projeto possui um plugin específico para o Kubernetes e a
documentação em <a href=https://github.com/openvswitch/ovn-kubernetes>ovn-kubernetes</a>.</p><h2 id=what-s-next>What's next</h2><p>Design inicial do modelo de conectividade do Kubernetes e alguns planos futuros
estão descritos com maiores detalhes no
<a href=https://git.k8s.io/community/contributors/design-proposals/network/networking.md>documento de design de redes</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-c4b1e87a84441f8a90699a345ce48d68>7.4 - Arquitetura de Log</h1><p>Os logs de aplicativos e sistemas podem ajudá-lo a entender o que está acontecendo dentro do seu cluster. Os logs são particularmente úteis para depurar problemas e monitorar a atividade do cluster. A maioria das aplicações modernas possui algum tipo de mecanismo de logs; como tal, a maioria dos mecanismos de contêineres também é projetada para suportar algum tipo de log. O método de log mais fácil e abrangente para aplicações em contêiner é gravar nos fluxos de saída e erro padrão.</p><p>No entanto, a funcionalidade nativa fornecida por um mecanismo de contêiner ou tempo de execução geralmente não é suficiente para uma solução completa de log. Por exemplo, se um contêiner travar, um pod for despejado ou um nó morrer, geralmente você ainda desejará acessar os logs do aplicativo. Dessa forma, os logs devem ter armazenamento e ciclo de vida separados, independentemente de nós, pods ou contêineres. Este conceito é chamado <em>cluster-level-logging</em>. O log no nível de cluster requer um back-end separado para armazenar, analisar e consultar logs. O kubernetes não fornece uma solução de armazenamento nativa para dados de log, mas você pode integrar muitas soluções de log existentes no cluster do Kubernetes.</p><p>As arquiteturas de log no nível de cluster são descritas no pressuposto de que um back-end de log esteja presente dentro ou fora do cluster. Se você não estiver interessado em ter o log no nível do cluster, ainda poderá encontrar a descrição de como os logs são armazenados e manipulados no nó para serem úteis.</p><h2 id=log-básico-no-kubernentes>Log básico no Kubernentes</h2><p>Nesta seção, você pode ver um exemplo de log básico no Kubernetes que gera dados para o fluxo de saída padrão(standard output stream). Esta demostração usa uma <a href=/examples/debug/counter-pod.yaml>especificação de pod</a> com um contêiner que grava algum texto na saída padrão uma vez por segundo.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/master/content/pt/examples/debug/counter-pod.yaml download=debug/counter-pod.yaml><code>debug/counter-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('debug-counter-pod-yaml')" title="Copy debug/counter-pod.yaml to clipboard"></img></div><div class=includecode id=debug-counter-pod-yaml><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>counter<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[/bin/sh, -c,<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#b44>&#39;i=0; while true; do echo &#34;$i: $(date)&#34;; i=$((i+1)); sleep 1; done&#39;</span>]<span style=color:#bbb>
</span></code></pre></div></div></div><p>Para executar este pod, use o seguinte comando:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/debug/counter-pod.yaml
</code></pre></div><p>A saída será:</p><pre><code>pod/counter created
</code></pre><p>Para buscar os logs, use o comando <code>kubectl logs</code>, da seguinte maneira:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs counter
</code></pre></div><p>A saída será:</p><pre><code>0: Mon Jan  1 00:00:00 UTC 2001
1: Mon Jan  1 00:00:01 UTC 2001
2: Mon Jan  1 00:00:02 UTC 2001
...
</code></pre><p>Você pode usar <code>kubectl logs</code> para recuperar logs de uma instanciação anterior de um contêiner com o sinalizador <code>--previous</code>, caso o contêiner tenha falhado. Se o seu pod tiver vários contêineres, você deverá especificar quais logs do contêiner você deseja acessar anexando um nome de contêiner ao comando. Veja a <a href=/docs/reference/generated/kubectl/kubectl-commands#logs>documentação do <code>kubectl logs</code></a> para mais destalhes.</p><h2 id=logs-no-nível-do-nó>Logs no nível do Nó</h2><p><img src=/images/docs/user-guide/logging/logging-node-level.png alt="Log no nível do nó"></p><p>Tudo o que um aplicativo em contêiner grava no <code>stdout</code> e <code>stderr</code> é tratado e redirecionado para algum lugar por dentro do mecanismo de contêiner. Por exemplo, o mecanismo de contêiner do Docker redireciona esses dois fluxos para <a href=https://docs.docker.com/engine/admin/logging/overview>um driver de log</a>, configurado no Kubernetes para gravar em um arquivo no formato json.</p><blockquote class="note callout"><div><strong>Note:</strong> O driver de log json do Docker trata cada linha como uma mensagem separada. Ao usar o driver de log do Docker, não há suporte direto para mensagens de várias linhas. Você precisa lidar com mensagens de várias linhas no nível do agente de log ou superior.</div></blockquote><p>Por padrão, se um contêiner reiniciar, o kubelet manterá um contêiner terminado com seus logs. Se um pod for despejado do nó, todos os contêineres correspondentes também serão despejados, juntamente com seus logs.</p><p>Uma consideração importante no log no nível do nó está implementado a rotação de log, para que os logs não consumam todo o armazenamento disponível no nó. Atualmente, o Kubernentes não é responsável pela rotação de logs, mas uma ferramenta de deployment deve configurar uma solução para resolver isso.
Por exemplo, nos clusters do Kubernetes, implementados pelo script <code>kube-up.sh</code>, existe uma ferramenta <a href=https://linux.die.net/man/8/logrotate><code>logrotate</code></a> configurada para executar a cada hora. Você pode configurar um tempo de execução do contêiner para girar os logs do aplicativo automaticamente, por exemplo, usando o <code>log-opt</code> do Docker.
No script <code>kube-up.sh</code>, a última abordagem é usada para imagem COS no GCP, e a anterior é usada em qualquer outro ambiente. Nos dois casos por padrão, a rotação é configurada para ocorrer quando o arquivo de log exceder 10MB.</p><p>Como exemplo, você pode encontrar informações detalhadas sobre como o <code>kube-up.sh</code> define o log da imagem COS no GCP no <a href=https://github.com/kubernetes/kubernetes/blob/v1.20.15/cluster/gce/gci/configure-helper.sh>script</a> correspondente.</p><p>Quando você executa <a href=/docs/reference/generated/kubectl/kubectl-commands#logs><code>kubectl logs</code></a> como no exemplo de log básico acima, o kubelet no nó lida com a solicitação e lê diretamente do arquivo de log, retornando o conteúdo na resposta.</p><blockquote class="note callout"><div><strong>Note:</strong> Atualmente, se algum sistema externo executou a rotação, apenas o conteúdo do arquivo de log mais recente estará disponível através de <code>kubectl logs</code>. Por exemplo, se houver um arquivo de 10MB, o <code>logrotate</code> executa a rotação e existem dois arquivos, um com 10MB de tamanho e um vazio, o <code>kubectl logs</code> retornará uma resposta vazia.</div></blockquote><h3 id=logs-de-componentes-do-sistema>Logs de componentes do sistema</h3><p>Existem dois tipos de componentes do sistema: aqueles que são executados em um contêiner e aqueles que não são executados em um contêiner. Por exemplo:</p><ul><li>O scheduler Kubernetes e o kube-proxy são executados em um contêiner.</li><li>O tempo de execução do kubelet e do contêiner, por exemplo, Docker, não é executado em contêineres.</li></ul><p>Nas máquinas com systemd, o tempo de execução do kubelet e do container é gravado no journald. Se systemd não estiver presente, eles gravam em arquivos <code>.log</code> no diretório <code>/var/log</code>.
Os componentes do sistema dentro dos contêineres sempre gravam no diretório <code>/var/log</code>, ignorando o mecanismo de log padrão. Eles usam a biblioteca de logs <a href=https://github.com/kubernetes/klog>klog</a>. Você pode encontrar as convenções para a gravidade do log desses componentes nos <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/logging.md>documentos de desenvolvimento sobre log</a>.</p><p>Da mesma forma que os logs de contêiner, os logs de componentes do sistema no diretório <code>/var/log</code> devem ser rotacionados. Nos clusters do Kubernetes criados pelo script <code>kube-up.sh</code>, esses logs são configurados para serem rotacionados pela ferramenta <code>logrotate</code> diariamente ou quando o tamanho exceder 100MB.</p><h2 id=arquiteturas-de-log-no-nível-de-cluster>Arquiteturas de log no nível de cluster</h2><p>Embora o Kubernetes não forneça uma solução nativa para o log em nível de cluster, há várias abordagens comuns que você pode considerar. Aqui estão algumas opções:</p><ul><li>Use um agente de log no nível do nó que seja executado em todos os nós.</li><li>Inclua um contêiner sidecar dedicado para efetuar logging em um pod de aplicativo.</li><li>Envie logs diretamente para um back-end de dentro de um aplicativo.</li></ul><h3 id=usando-um-agente-de-log-de-nó>Usando um agente de log de nó</h3><p><img src=/images/docs/user-guide/logging/logging-with-node-agent.png alt="Usando um agente de log no nível do nó"></p><p>Você pode implementar o log em nível de cluster incluindo um <em>agente de log em nível de nó</em> em cada nó. O agente de log é uma ferramenta dedicada que expõe logs ou envia logs para um back-end. Geralmente, o agente de log é um contêiner que tem acesso a um diretório com arquivos de log de todos os contêineres de aplicativos nesse nó.</p><p>Como o agente de log deve ser executado em todos os nós, é comum implementá-lo como uma réplica do DaemonSet, um pod de manifesto ou um processo nativo dedicado no nó. No entanto, as duas últimas abordagens são obsoletas e altamente desencorajadas.</p><p>O uso de um agente de log no nível do nó é a abordagem mais comum e incentivada para um cluster Kubernetes, porque ele cria apenas um agente por nó e não requer alterações nos aplicativos em execução no nó. No entanto, o log no nível do nó <em>funciona apenas para a saída padrão dos aplicativos e o erro padrão</em>.</p><p>O Kubernetes não especifica um agente de log, mas dois agentes de log opcionais são fornecidos com a versão Kubernetes: <a href=/docs/user-guide/logging/stackdriver>Stackdriver Logging</a> para uso com o Google Cloud Platform e <a href=/docs/user-guide/logging/elasticsearch>Elasticsearch</a>. Você pode encontrar mais informações e instruções nos documentos dedicados. Ambos usam <a href=http://www.fluentd.org/>fluentd</a> com configuração customizada como um agente no nó.</p><h3 id=usando-um-contêiner-sidecar-com-o-agente-de-log>Usando um contêiner sidecar com o agente de log</h3><p>Você pode usar um contêiner sidecar de uma das seguintes maneiras:</p><ul><li>O container sidecar transmite os logs do aplicativo para seu próprio <code>stdout</code>.</li><li>O contêiner do sidecar executa um agente de log, configurado para selecionar logs de um contêiner de aplicativo.</li></ul><h4 id=streaming-sidecar-conteiner>Streaming sidecar conteiner</h4><p><img src=/images/docs/user-guide/logging/logging-with-streaming-sidecar.png alt="Conteiner sidecar com um streaming container"></p><p>Fazendo com que seus contêineres de sidecar fluam para seus próprios <code>stdout</code> e <code>stderr</code>, você pode tirar proveito do kubelet e do agente de log que já executam em cada nó. Os contêineres sidecar lêem logs de um arquivo, socket ou journald. Cada contêiner sidecar individual imprime o log em seu próprio <code>stdout</code> ou <code>stderr</code> stream.</p><p>Essa abordagem permite separar vários fluxos de logs de diferentes partes do seu aplicativo, algumas das quais podem não ter suporte para gravar em <code>stdout</code> ou <code>stderr</code>. A lógica por trás do redirecionamento de logs é mínima, portanto dificilmente representa uma sobrecarga significativa. Além disso, como <code>stdout</code> e <code>stderr</code> são manipulados pelo kubelet, você pode usar ferramentas internas como o <code>kubectl logs</code>.</p><p>Considere o seguinte exemplo. Um pod executa um único contêiner e grava em dois arquivos de log diferentes, usando dois formatos diferentes. Aqui está um arquivo de configuração para o Pod:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/master/content/pt/examples/admin/logging/two-files-counter-pod.yaml download=admin/logging/two-files-counter-pod.yaml><code>admin/logging/two-files-counter-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-logging-two-files-counter-pod-yaml')" title="Copy admin/logging/two-files-counter-pod.yaml to clipboard"></img></div><div class=includecode id=admin-logging-two-files-counter-pod-yaml><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>counter<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- /bin/sh<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- -c<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- &gt;<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>      i=0;
</span><span style=color:#b44;font-style:italic>      while true;
</span><span style=color:#b44;font-style:italic>      do
</span><span style=color:#b44;font-style:italic>        echo &#34;$i: $(date)&#34; &gt;&gt; /var/log/1.log;
</span><span style=color:#b44;font-style:italic>        echo &#34;$(date) INFO $i&#34; &gt;&gt; /var/log/2.log;
</span><span style=color:#b44;font-style:italic>        i=$((i+1));
</span><span style=color:#b44;font-style:italic>        sleep 1;
</span><span style=color:#b44;font-style:italic>      done</span><span style=color:#bbb>      
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></code></pre></div></div></div><p>Seria uma bagunça ter entradas de log de diferentes formatos no mesmo fluxo de logs, mesmo se você conseguisse redirecionar os dois componentes para o fluxo <code>stdout</code> do contêiner. Em vez disso, você pode introduzir dois contêineres sidecar. Cada contêiner sidecar pode direcionar um arquivo de log específico de um volume compartilhado e depois redirecionar os logs para seu próprio fluxo <code>stdout</code>.</p><p>Aqui está um arquivo de configuração para um pod que possui dois contêineres sidecar:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/master/content/pt/examples/admin/logging/two-files-counter-pod-streaming-sidecar.yaml download=admin/logging/two-files-counter-pod-streaming-sidecar.yaml><code>admin/logging/two-files-counter-pod-streaming-sidecar.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-logging-two-files-counter-pod-streaming-sidecar-yaml')" title="Copy admin/logging/two-files-counter-pod-streaming-sidecar.yaml to clipboard"></img></div><div class=includecode id=admin-logging-two-files-counter-pod-streaming-sidecar-yaml><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>counter<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- /bin/sh<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- -c<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- &gt;<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>      i=0;
</span><span style=color:#b44;font-style:italic>      while true;
</span><span style=color:#b44;font-style:italic>      do
</span><span style=color:#b44;font-style:italic>        echo &#34;$i: $(date)&#34; &gt;&gt; /var/log/1.log;
</span><span style=color:#b44;font-style:italic>        echo &#34;$(date) INFO $i&#34; &gt;&gt; /var/log/2.log;
</span><span style=color:#b44;font-style:italic>        i=$((i+1));
</span><span style=color:#b44;font-style:italic>        sleep 1;
</span><span style=color:#b44;font-style:italic>      done</span><span style=color:#bbb>      
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count-log-1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[/bin/sh, -c, &#39;tail -n+1 -f /var/log/1.log&#39;]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count-log-2<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[/bin/sh, -c, &#39;tail -n+1 -f /var/log/2.log&#39;]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></code></pre></div></div></div><p>Agora, quando você executa este pod, é possível acessar cada fluxo de log separadamente, executando os seguintes comandos:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs counter count-log-1
</code></pre></div><pre><code>0: Mon Jan  1 00:00:00 UTC 2001
1: Mon Jan  1 00:00:01 UTC 2001
2: Mon Jan  1 00:00:02 UTC 2001
...
</code></pre><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs counter count-log-2
</code></pre></div><pre><code>Mon Jan  1 00:00:00 UTC 2001 INFO 0
Mon Jan  1 00:00:01 UTC 2001 INFO 1
Mon Jan  1 00:00:02 UTC 2001 INFO 2
...
</code></pre><p>O agente no nível do nó instalado em seu cluster coleta esses fluxos de logs automaticamente sem nenhuma configuração adicional. Se desejar, você pode configurar o agente para analisar as linhas de log, dependendo do contêiner de origem.</p><p>Observe que, apesar do baixo uso da CPU e da memória (ordem de alguns milicores por CPU e ordem de vários megabytes de memória), gravar logs em um arquivo e depois transmiti-los para o <code>stdout</code> pode duplicar o uso do disco. Se você tem um aplicativo que grava em um único arquivo, geralmente é melhor definir <code>/dev/stdout</code> como destino, em vez de implementar a abordagem de contêiner de transmissão no sidecar.</p><p>Os contêineres sidecar também podem ser usados para rotacionar arquivos de log que não podem ser rotacionados pelo próprio aplicativo. Um exemplo dessa abordagem é um pequeno contêiner executando <code>logrotate</code> periodicamente.
No entanto, é recomendável usar o <code>stdout</code> e o <code>stderr</code> diretamente e deixar as políticas de rotação e retenção no kubelet.</p><h4 id=contêiner-sidecar-com-um-agente-de-log>Contêiner sidecar com um agente de log</h4><p><img src=/images/docs/user-guide/logging/logging-with-sidecar-agent.png alt="Contêiner sidecar com um agente de log"></p><p>Se o agente de log no nível do nó não for flexível o suficiente para sua situação, você poderá criar um contêiner secundário com um agente de log separado que você configurou especificamente para executar com seu aplicativo.</p><blockquote class="note callout"><div><strong>Note:</strong> O uso de um agente de log em um contêiner sidecar pode levar a um consumo significativo de recursos. Além disso, você não poderá acessar esses logs usando o comando <code>kubectl logs</code>, porque eles não são controlados pelo kubelet.</div></blockquote><p>Como exemplo, você pode usar o <a href=/docs/tasks/debug-application-cluster/logging-stackdriver/>Stackdriver</a>, que usa fluentd como um agente de log. Aqui estão dois arquivos de configuração que você pode usar para implementar essa abordagem. O primeiro arquivo contém um <a href=/docs/tasks/configure-pod-container/configure-pod-configmap/>ConfigMap</a> para configurar o fluentd.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/master/content/pt/examples/admin/logging/fluentd-sidecar-config.yaml download=admin/logging/fluentd-sidecar-config.yaml><code>admin/logging/fluentd-sidecar-config.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-logging-fluentd-sidecar-config-yaml')" title="Copy admin/logging/fluentd-sidecar-config.yaml to clipboard"></img></div><div class=includecode id=admin-logging-fluentd-sidecar-config-yaml><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-config<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fluentd.conf</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    &lt;source&gt;
</span><span style=color:#b44;font-style:italic>      type tail
</span><span style=color:#b44;font-style:italic>      format none
</span><span style=color:#b44;font-style:italic>      path /var/log/1.log
</span><span style=color:#b44;font-style:italic>      pos_file /var/log/1.log.pos
</span><span style=color:#b44;font-style:italic>      tag count.format1
</span><span style=color:#b44;font-style:italic>    &lt;/source&gt;
</span><span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    &lt;source&gt;
</span><span style=color:#b44;font-style:italic>      type tail
</span><span style=color:#b44;font-style:italic>      format none
</span><span style=color:#b44;font-style:italic>      path /var/log/2.log
</span><span style=color:#b44;font-style:italic>      pos_file /var/log/2.log.pos
</span><span style=color:#b44;font-style:italic>      tag count.format2
</span><span style=color:#b44;font-style:italic>    &lt;/source&gt;
</span><span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    &lt;match **&gt;
</span><span style=color:#b44;font-style:italic>      type google_cloud
</span><span style=color:#b44;font-style:italic>    &lt;/match&gt;</span><span style=color:#bbb>    
</span></code></pre></div></div></div><blockquote class="note callout"><div><strong>Note:</strong> A configuração do fluentd está além do escopo deste artigo. Para obter informações sobre como configurar o fluentd, consulte a <a href=http://docs.fluentd.org/>documentação oficial do fluentd</a>.</div></blockquote><p>O segundo arquivo descreve um pod que possui um contêiner sidecar rodando fluentemente.
O pod monta um volume onde o fluentd pode coletar seus dados de configuração.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/master/content/pt/examples/admin/logging/two-files-counter-pod-agent-sidecar.yaml download=admin/logging/two-files-counter-pod-agent-sidecar.yaml><code>admin/logging/two-files-counter-pod-agent-sidecar.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-logging-two-files-counter-pod-agent-sidecar-yaml')" title="Copy admin/logging/two-files-counter-pod-agent-sidecar.yaml to clipboard"></img></div><div class=includecode id=admin-logging-two-files-counter-pod-agent-sidecar-yaml><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>counter<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- /bin/sh<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- -c<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- &gt;<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>      i=0;
</span><span style=color:#b44;font-style:italic>      while true;
</span><span style=color:#b44;font-style:italic>      do
</span><span style=color:#b44;font-style:italic>        echo &#34;$i: $(date)&#34; &gt;&gt; /var/log/1.log;
</span><span style=color:#b44;font-style:italic>        echo &#34;$(date) INFO $i&#34; &gt;&gt; /var/log/2.log;
</span><span style=color:#b44;font-style:italic>        i=$((i+1));
</span><span style=color:#b44;font-style:italic>        sleep 1;
</span><span style=color:#b44;font-style:italic>      done</span><span style=color:#bbb>      
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count-agent<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/fluentd-gcp:1.30<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>FLUENTD_ARGS<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>-c /etc/fluentd-config/fluentd.conf<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/fluentd-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-config<span style=color:#bbb>
</span></code></pre></div></div></div><p>Depois de algum tempo, você pode encontrar mensagens de log na interface do Stackdriver.</p><p>Lembre-se de que este é apenas um exemplo e você pode realmente substituir o fluentd por qualquer agente de log, lendo de qualquer fonte dentro de um contêiner de aplicativo.</p><h3 id=expondo-logs-diretamente-do-aplicativo>Expondo logs diretamente do aplicativo</h3><p><img src=/images/docs/user-guide/logging/logging-from-application.png alt="Expondo logs diretamente do aplicativo"></p><p>Você pode implementar o log no nível do cluster, expondo ou enviando logs diretamente de todos os aplicativos; no entanto, a implementação desse mecanismo de log está fora do escopo do Kubernetes.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-2e05a56491965ae320c2662590b2ca18>7.5 - Configurando o Garbage Collection do kubelet</h1><p>O Garbage collection(Coleta de lixo) é uma função útil do kubelet que limpa imagens e contêineres não utilizados. O kubelet executará o garbage collection para contêineres a cada minuto e para imagens a cada cinco minutos.</p><p>Ferramentas externas de garbage collection não são recomendadas, pois podem potencialmente interromper o comportamento do kubelet removendo os contêineres que existem.</p><h2 id=coleta-de-imagens>Coleta de imagens</h2><p>O Kubernetes gerencia o ciclo de vida de todas as imagens através do imageManager, com a cooperação do cadvisor.</p><p>A política para o garbage collection de imagens leva dois fatores em consideração:
<code>HighThresholdPercent</code> e <code>LowThresholdPercent</code>. Uso do disco acima do limite acionará o garbage collection. O garbage collection excluirá as imagens que foram menos usadas recentemente até que o nível fique abaixo do limite.</p><h2 id=coleta-de-container>Coleta de container</h2><p>A política para o garbage collection de contêineres considera três variáveis definidas pelo usuário. <code>MinAge</code> é a idade mínima em que um contêiner pode ser coletado. <code>MaxPerPodContainer</code> é o número máximo de contêineres mortos que todo par de pod (UID, container name) pode ter. <code>MaxContainers</code> é o número máximo de contêineres mortos totais. Essas variáveis podem ser desabilitadas individualmente, definindo <code>MinAge</code> como zero e definindo <code>MaxPerPodContainer</code> e <code>MaxContainers</code> respectivamente para menor que zero.</p><p>O Kubelet atuará em contêineres não identificados, excluídos ou fora dos limites definidos pelos sinalizadores mencionados. Os contêineres mais antigos geralmente serão removidos primeiro. <code>MaxPerPodContainer</code> e <code>MaxContainer</code> podem potencialmente conflitar entre si em situações em que a retenção do número máximo de contêineres por pod (<code>MaxPerPodContainer</code>) estaria fora do intervalo permitido de contêineres globais mortos (<code>MaxContainers</code>). O <code>MaxPerPodContainer</code> seria ajustado nesta situação: O pior cenário seria fazer o downgrade do <code>MaxPerPodContainer</code> para 1 e remover os contêineres mais antigos. Além disso, os contêineres pertencentes a pods que foram excluídos são removidos assim que se tornem mais antigos que <code>MinAge</code>.</p><p>Os contêineres que não são gerenciados pelo kubelet não estão sujeitos ao garbage collection de contêiner.</p><h2 id=configurações-do-usuário>Configurações do usuário</h2><p>Os usuários podem ajustar os seguintes limites para ajustar o garbage collection da imagem com os seguintes sinalizadores do kubelet:</p><ol><li><code>image-gh-high-threshold</code>, a porcentagem de uso de disco que aciona o garbage collection da imagem. O padrão é 85%.</li><li><code>image-gc-low-threshold</code>, a porcentagem de uso de disco com o qual o garbage collection da imagem tenta liberar. O padrão é 80%.</li></ol><p>Também permitimos que os usuários personalizem a política do garbagem collection através dos seguintes sinalizadores do kubelet:</p><ol><li><code>minimum-container-ttl-duration</code>, idade mínima para um contêiner finalizado antes de ser colectado. O padrão é 0 minuto, o que significa que todo contêiner finalizado será coletado como lixo.</li><li><code>maximum-dead-containers-per-container</code>, número máximo de instâncias antigas a serem retidas por contêiner. O padrão é 1.</li><li><code>maximum-dead-containers</code>, número máximo de instâncias antigas de contêineres para retenção global. O padrão é -1, o que significa que não há limite global.</li></ol><p>Os contêineres podem ser potencialmente coletados como lixo antes que sua utilidade expire. Esses contêineres podem conter logs e outros dados que podem ser úteis para solucionar problemas. Um valor suficientemente grande para <code>maximum-dead-containers-per-container</code> é altamente recomendado para permitir que pelo menos 1 contêiner morto seja retido por contêiner esperado. Um valor maior para <code>maximum-dead-containers</code> também é recomendados por um motivo semelhante.
Consulte <a href=https://github.com/kubernetes/kubernetes/issues/13287>esta issue</a> para obter mais detalhes.</p><h2 id=descontinuado>Descontinuado</h2><p>Alguns recursos do Garbage Collection neste documento serão substituídos pelo kubelet eviction no futuro.</p><p>Incluindo:</p><table><thead><tr><th>Flag Existente</th><th>Nova Flag</th><th>Fundamentação</th></tr></thead><tbody><tr><td><code>--image-gc-high-threshold</code></td><td><code>--eviction-hard</code> ou <code>--eviction-soft</code></td><td>os sinais existentes de despejo podem acionar o garbage collection da imagem</td></tr><tr><td><code>--image-gc-low-threshold</code></td><td><code>--eviction-minimum-reclaim</code></td><td>recuperações de despejo atinge o mesmo comportamento</td></tr><tr><td><code>--maximum-dead-containers</code></td><td></td><td>descontinuado quando os logs antigos forem armazenados fora do contexto do contêiner</td></tr><tr><td><code>--maximum-dead-containers-per-container</code></td><td></td><td>descontinuado quando os logs antigos forem armazenados fora do contexto do contêiner</td></tr><tr><td><code>--minimum-container-ttl-duration</code></td><td></td><td>descontinuado quando os logs antigos forem armazenados fora do contexto do contêiner</td></tr><tr><td><code>--low-diskspace-threshold-mb</code></td><td><code>--eviction-hard</code> ou <code>eviction-soft</code></td><td>O despejo generaliza os limites do disco para outros recursos</td></tr><tr><td><code>--outofdisk-transition-frequency</code></td><td><code>--eviction-pressure-transition-period</code></td><td>O despejo generaliza a transição da pressão do disco para outros recursos</td></tr></tbody></table><h2 id=what-s-next>What's next</h2><p>Consulte <a href=/docs/tasks/administer-cluster/out-of-resource/>Configurando a Manipulação de Recursos Insuficientes</a> para mais detalhes.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-85d633ae590aa20ec024f1b7af1d74fc>7.6 - Instalando Addons</h1><p>Addons estendem a funcionalidade do Kubernetes.</p><p>Esta página lista alguns dos add-ons e links com suas respectivas instruções de instalação.</p><p>Os Add-ons de cada sessão são classificados em ordem alfabética - a ordem não implica qualquer status preferencial.</p><h2 id=rede-e-política-de-rede>Rede e Política de Rede</h2><ul><li><a href=https://www.github.com/noironetworks/aci-containers>ACI</a> fornece rede integrada de contêineres e segurança de rede com a Cisco ACI.</li><li><a href=https://docs.projectcalico.org/latest/getting-started/kubernetes/>Calico</a> é um provedor de políticas de rede e rede L3 seguro.</li><li><a href=https://github.com/tigera/canal/tree/master/k8s-install>Canal</a> une Flannel e Calico, fornecendo rede e política de rede.</li><li><a href=https://github.com/cilium/cilium>Cilium</a> é um plug-in de políticas de rede e rede L3 que pode impor políticas de HTTP / API / L7 de forma transparente. Tanto o modo de roteamento quanto o de sobreposição / encapsulamento são suportados.</li><li><a href=https://github.com/Huawei-PaaS/CNI-Genie>CNI-Genie</a> permite que o Kubernetes se conecte facilmente a uma variedade de plugins CNI, como Calico, Canal, Flannel, Romana ou Weave.</li><li><a href=http://contiv.github.io>Contiv</a> fornece um rede configurável (L3 nativa usando BGP, sobreposição usando vxlan, L2 clássico e Cisco-SDN / ACI) para vários casos de uso e uma estrutura rica de políticas de rede. O projeto Contiv é totalmente <a href=http://github.com/contiv>open source</a>. O script de <a href=http://github.com/contiv/install>instalação</a> fornece opções de instalação com ou sem kubeadm.</li><li><a href=http://www.juniper.net/us/en/products-services/sdn/contrail/contrail-networking/>Contrail</a>, baseado no <a href=https://tungsten.io>Tungsten Fabric</a>, é um projeto open source, multi-cloud com uma rede virtualizada e com uma plataforma de gerenciamento de políticas de rede. O Contrail e o Tungsten Fabric estão integrados a sistemas de orquestração, como Kubernetes, OpenShift, OpenStack e Mesos, e fornecem modos de isolamento para máquinas virtuais, containers / pods e cargas em servidores físicos.</li><li><a href=https://github.com/coreos/flannel/blob/master/Documentation/kubernetes.md>Flannel</a> é um provedor de rede de sobreposição que pode ser usado com o Kubernetes.</li><li><a href=https://github.com/ZTE/Knitter/>Knitter</a> é uma solução de rede que suporta múltiplas redes no Kubernetes.</li><li><a href=https://github.com/Intel-Corp/multus-cni>Multus</a> é um plugin Multi para suporte a várias redes no Kubernetes para suportar todos os plugins CNI (por exemplo, Calico, Cilium, Contiv, Flannel), além das cargas de trabalho baseadas em SRIOV, DPDK, OVS-DPDK e VPP no Kubernetes.</li><li><a href=https://docs.vmware.com/en/VMware-NSX-T/2.0/nsxt_20_ncp_kubernetes.pdf>NSX-T</a> O Plugin de contêiner (NCP) fornece integração entre o VMware NSX-T e orquestradores de contêineres como o Kubernetes, além da integração entre o NSX-T e as plataformas CaaS / PaaS baseadas em contêiner, como Pivotal Container Service (PKS) e OpenShift.</li><li><a href=https://github.com/nuagenetworks/nuage-kubernetes/blob/v5.1.1-1/docs/kubernetes-1-installation.rst>Nuage</a> é uma plataforma SDN que fornece uma rede baseada em políticas entre os Pods Kubernetes e os ambientes não-Kubernetes, com visibilidade e monitoramento de segurança.</li><li><a href=http://romana.io>Romana</a> é uma solução de rede Camada 3 para redes de pods que também suporta <a href=/docs/concepts/services-networking/network-policies/>NetworkPolicy API</a>. Detalhes da instalação do add-on Kubeadm disponíveis <a href=https://github.com/romana/romana/tree/master/containerize>aqui</a>.</li><li><a href=https://www.weave.works/docs/net/latest/kube-addon/>Weave Net</a> fornece rede e política de rede, continuará trabalhando em ambos os lados de uma partição de rede e não requer um banco de dados externo.</li></ul><h2 id=descoberta-de-serviço>Descoberta de Serviço</h2><ul><li><a href=https://coredns.io>CoreDNS</a> é um servidor DNS flexível e extensível que pode ser <a href=https://github.com/coredns/deployment/tree/master/kubernetes>instalado</a> como DNS dentro do cluster para ser utilizado por pods.</li></ul><h2 id=visualização-amp-controle>Visualização & Controle</h2><ul><li><a href=https://github.com/kubernetes/dashboard#kubernetes-dashboard>Dashboard</a> é uma interface web para gestão do Kubernetes.</li><li><a href=https://www.weave.works/documentation/scope-latest-installing/#k8s>Weave Scope</a> é uma ferramenta gráfica para visualizar contêineres, pods, serviços etc. Use-o em conjunto com o <a href=https://cloud.weave.works/>Weave Cloud account</a> ou hospede você mesmo a interface do usuário.</li></ul><h2 id=a-infraestrutura>A infraestrutura</h2><ul><li><a href=https://kubevirt.io/user-guide/docs/latest/administration/intro.html#cluster-side-add-on-deployment>KubeVirt</a> é um add-on para executar máquinas virtuais no Kubernetes. É geralmente executado em clusters em maquina fisica.</li></ul><h2 id=add-ons-legado>Add-ons Legado</h2><p>Existem vários outros complementos documentados no diretório não mais ultilizados <a href=https://git.k8s.io/kubernetes/cluster/addons>cluster/addons</a>.</p><p>Projetos bem mantidos deveriam ser linkados aqui. PRs são bem vindas!</p></div><div class=td-content style=page-break-before:always><h1 id=pg-7e0d97616b15e2c383c6a0a96ec442cb>8 - Extendendo o Kubernetes</h1></div><div class=td-content><h1 id=pg-0af41d3bd7c785621b58b7564793396a>8.1 - Extendendo a API do Kubernetes</h1></div><div class=td-content><h1 id=pg-1ea4977c0ebf97569bf54a477faa7fa5>8.1.1 - Extendendo a API do Kubernetes com a camada de agregação</h1><p>A camada de agregação permite ao Kubernetes ser estendido com APIs adicionais,
para além do que é oferecido pelas APIs centrais do Kubernetes.
As APIs adicionais podem ser soluções prontas tal como o
<a href=/docs/concepts/extend-kubernetes/service-catalog/>catálogo de serviços</a>,
ou APIs que você mesmo desenvolva.</p><p>A camada de agregação é diferente dos <a href=/docs/concepts/extend-kubernetes/api-extension/custom-resources/>Recursos Personalizados</a>,
que são uma forma de fazer o <a class=glossary-tooltip title="O componente da camada de gerenciamento que serve a API do Kubernetes." data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=kube-apiserver>kube-apiserver</a>
reconhecer novas espécies de objetos.</p><h2 id=camada-de-agregação>Camada de agregação</h2><p>A camada de agregação executa em processo com o kube-apiserver.
Até que um recurso de extensão seja registado, a camada de agregação
não fará nada. Para registar uma API, terá de adicionar um objeto <em>APIService</em>
que irá "reclamar" o caminho URL na API do Kubernetes. Nesta altura, a camada
de agregação procurará qualquer coisa enviada para esse caminho da API
(e.g. <code>/apis/myextension.mycompany.io/v1/…</code>) para o <em>APIService</em> registado.</p><p>A maneira mais comum de implementar o <em>APIService</em> é executar uma
<em>extensão do servidor API</em> em <em>Pods</em> que executam no seu cluster.
Se estiver a usar o servidor de extensão da API para gerir recursos
no seu cluster, o servidor de extensão da API (também escrito como "extension-apiserver")
é tipicamente emparelhado com um ou mais <a class=glossary-tooltip title="Um ciclo de controle que observa o estado partilhado do cluster através do API Server e efetua mudanças tentando mover o estado atual em direção ao estado desejado." data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controladores>controladores</a>.
A biblioteca apiserver-builder providencia um esqueleto para ambos
os servidores de extensão da API e controladores associados.</p><h3 id=latência-da-resposta>Latência da resposta</h3><p>Servidores de extensão de APIs devem ter baixa latência de rede de e para o kube-apiserver.
Pedidos de descoberta são necessários que façam a ida e volta do kube-apiserver em 5
segundos ou menos.</p><p>Se o seu servidor de extensão da API não puder cumprir com o requisito de latência,
considere fazer alterações que permitam atingi-lo. Pode também definir
<a href=/docs/reference/command-line-tools-reference/feature-gates/>portal de funcionalidade</a> <code>EnableAggregatedDiscoveryTimeout=false</code> no kube-apiserver para desativar
a restrição de intervalo. Esta portal de funcionalidade deprecado será removido
num lançamento futuro.</p><h2 id=what-s-next>What's next</h2><ul><li>Para pôr o agregador a funcionar no seu ambiente, <a href=/docs/tasks/access-kubernetes-api/configure-aggregation-layer/>configure a camada de agregação</a>.</li><li>De seguida, <a href=/docs/tasks/access-kubernetes-api/setup-extension-api-server/>configura um api-server de extensão</a> para funcionar com a camada de agregação.</li><li>Também, aprenda como pode <a href=/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/>estender a API do Kubernetes através do use de Definições de Recursos Personalizados</a>.</li><li>Leia a especificação do <a href=/docs/reference/generated/kubernetes-api/v1.20/#apiservice-v1-apiregistration-k8s-io>APIService</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c8937cdc9df96f3328becf04f8211292>8.2 - Extensões de Computação, armazenamento e redes</h1></div><div class=td-content><h1 id=pg-1ac2260db9ecccbf0303a899bc27ce6d>8.2.1 - Plugins de rede</h1><p>Plugins de redes no Kubernetes podem ser dos seguintes tipos:</p><ul><li>Plugins CNI: Aderentes à especificação <a href=https://github.com/containernetworking/cni>Container Network Interface</a> (CNI), desenhados para interoperabilidade.<ul><li>Kubernetes usa a versão <a href=https://github.com/containernetworking/cni/blob/spec-v0.4.0/SPEC.md>v0.4.0</a> da especificação CNI.</li></ul></li><li>Plugin kubenet: Implementa o <code>cbr0</code> básico usando os plugins CNI <code>bridge</code> e <code>host-local</code></li></ul><h2 id=instalação>Instalação</h2><p>O kubelet possui um plugin único padrão, e um plugin padrão comum para todo o cluster.
Ele verifica o plugin quando inicia, se lembra o que encontrou, e executa o plugin selecionado
em momentos oportunos dentro do ciclo de vida de um Pod (isso é verdadeiro apenas com o Docker,
uma vez que o CRI gerencia seus próprios plugins de CNI). Existem dois parâmetros de linha de comando
no Kubelet para se ter em mente quando usando plugins:</p><ul><li><code>cni-bin-dir</code>: O Kubelet verifica esse diretório por plugins na inicialização</li><li><code>network-plugin</code>: O plugin de rede que deve ser utilizado do diretório configurado em
<code>cni-bin-dir</code>. Deve ser igual ao nome configurado por um plugin no diretório de plugins.
Para plugins de CNI, isso equivale ao valor <code>cni</code>.</li></ul><h2 id=requisitos-de-plugins-de-rede>Requisitos de plugins de Rede</h2><p>Além de prover a <a href=https://github.com/kubernetes/kubernetes/tree/v1.20.15/pkg/kubelet/dockershim/network/plugins.go>interface <code>NetworkPlugin</code></a>
para configuração da rede do pod, o plugin pode necessitar de suporte específico ao
kube-proxy.
O proxy iptables obviamente depende do iptables, e o plugin deve garantir que o
tráfego do contêiner esteja disponível para o iptables. Por exemplo, se o plugin
conecta os contêineres à <em>Linux bridge</em>, o plugin deve configurar a diretiva de
<em>sysctl</em> <code>net/bridge/bridge-nf-call-iptables</code> com o valor <code>1</code> para garantir que o
proxy iptables opere normalmente. Se o plugin não faz uso da <em>Linux Bridge</em> (mas outro
mecanismo, como Open vSwitch) ele deve garantir que o tráfego do contêiner é roteado
apropriadamente para o proxy.</p><p>Por padrão, se nenhum plugin de rede é configurado no kubelet, o plugin <code>noop</code> é utilizado,
que configura <code>net/bridge/bridge-nf-call-iptables=1</code> para garantir que configurações simples
(como Docker com <em>bridge Linux</em>) operem corretamente com o proxy iptables.</p><h3 id=cni>CNI</h3><p>O plugin de CNI é selecionado utilizando-se da opção <code>--network-plugin=cni</code> no início do Kubeket.
O Kubelet lê um arquivo do diretório especificado em <code>--cni-conf-dir</code> (padrão <code>/etc/cni/net.d</code>)
e usa a configuração de CNI desse arquivo para configurar a rede de cada Pod. O arquivo de
configuração do CNI deve usar a <a href=https://github.com/containernetworking/cni/blob/master/SPEC.md#network-configuration>especificação de CNI</a>,
e qualquer plugin referenciado nesse arquivo deve estar presente no diretório
<code>--cni-bin-dir</code> (padrão <code>/opt/cni/bin</code>).</p><p>Se existirem múltiplos arquivos de configuração no diretório, o kubelet usa o arquivo de
configuração que vier primeiro pelo nome, em ordem alfabética.</p><p>Adicionalmente ao plugin de CNI especificado no arquivo de configuração, o Kubernetes requer
o plugin CNI padrão <a href=https://github.com/containernetworking/plugins/blob/master/plugins/main/loopback/loopback.go><code>lo</code></a> ao menos na versão 0.2.0.</p><h4 id=suporte-a-hostport>Suporte a hostPort</h4><p>O plugin de redes CNI suporta <code>hostPort</code>. Você pode utilizar o plugin oficial
<a href=https://github.com/containernetworking/plugins/tree/master/plugins/meta/portmap>portmap</a>
ou usar seu próprio plugin com a funcionalidade de <em>portMapping</em>.</p><p>Caso você deseje habilitar o suporte a <code>hostPort</code>, você deve especificar
<code>portMappings capability</code> no seu <code>cni-conf-dir</code>.
Por exemplo:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;k8s-pod-network&#34;</span>,
  <span style=color:green;font-weight:700>&#34;cniVersion&#34;</span>: <span style=color:#b44>&#34;0.3.0&#34;</span>,
  <span style=color:green;font-weight:700>&#34;plugins&#34;</span>: [
    {
      <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;calico&#34;</span>,
      <span style=color:green;font-weight:700>&#34;log_level&#34;</span>: <span style=color:#b44>&#34;info&#34;</span>,
      <span style=color:green;font-weight:700>&#34;datastore_type&#34;</span>: <span style=color:#b44>&#34;kubernetes&#34;</span>,
      <span style=color:green;font-weight:700>&#34;nodename&#34;</span>: <span style=color:#b44>&#34;127.0.0.1&#34;</span>,
      <span style=color:green;font-weight:700>&#34;ipam&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;host-local&#34;</span>,
        <span style=color:green;font-weight:700>&#34;subnet&#34;</span>: <span style=color:#b44>&#34;usePodCidr&#34;</span>
      },
      <span style=color:green;font-weight:700>&#34;policy&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;k8s&#34;</span>
      },
      <span style=color:green;font-weight:700>&#34;kubernetes&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;kubeconfig&#34;</span>: <span style=color:#b44>&#34;/etc/cni/net.d/calico-kubeconfig&#34;</span>
      }
    },
    {
      <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;portmap&#34;</span>,
      <span style=color:green;font-weight:700>&#34;capabilities&#34;</span>: {<span style=color:green;font-weight:700>&#34;portMappings&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>}
    }
  ]
}
</code></pre></div><h4 id=suporte-a-controle-de-banda>Suporte a controle de banda</h4><p><strong>Funcionalidade experimental</strong></p><p>O plugin de rede CNI também suporta o controle de banda de entrada e saída.
Você pode utilizar o plugin oficial <a href=https://github.com/containernetworking/plugins/tree/master/plugins/meta/bandwidth>bandwidth</a>
desenvolvido ou usar seu próprio plugin de controle de banda.</p><p>Se você habilitar o suporte ao controle de banda, você deve adicionar o plugin <code>bandwidth</code>
no seu arquivo de configuração de CNI (padrão <code>/etc/cni/net.d</code>) e garantir que o programa
exista no diretório de binários do CNI (padrão <code>/opt/cni/bin</code>).</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;k8s-pod-network&#34;</span>,
  <span style=color:green;font-weight:700>&#34;cniVersion&#34;</span>: <span style=color:#b44>&#34;0.3.0&#34;</span>,
  <span style=color:green;font-weight:700>&#34;plugins&#34;</span>: [
    {
      <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;calico&#34;</span>,
      <span style=color:green;font-weight:700>&#34;log_level&#34;</span>: <span style=color:#b44>&#34;info&#34;</span>,
      <span style=color:green;font-weight:700>&#34;datastore_type&#34;</span>: <span style=color:#b44>&#34;kubernetes&#34;</span>,
      <span style=color:green;font-weight:700>&#34;nodename&#34;</span>: <span style=color:#b44>&#34;127.0.0.1&#34;</span>,
      <span style=color:green;font-weight:700>&#34;ipam&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;host-local&#34;</span>,
        <span style=color:green;font-weight:700>&#34;subnet&#34;</span>: <span style=color:#b44>&#34;usePodCidr&#34;</span>
      },
      <span style=color:green;font-weight:700>&#34;policy&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;k8s&#34;</span>
      },
      <span style=color:green;font-weight:700>&#34;kubernetes&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;kubeconfig&#34;</span>: <span style=color:#b44>&#34;/etc/cni/net.d/calico-kubeconfig&#34;</span>
      }
    },
    {
      <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;bandwidth&#34;</span>,
      <span style=color:green;font-weight:700>&#34;capabilities&#34;</span>: {<span style=color:green;font-weight:700>&#34;bandwidth&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>}
    }
  ]
}
</code></pre></div><p>Agora você pode adicionar as anotações <code>kubernetes.io/ingress-bandwidth</code> e
<code>kubernetes.io/egress-bandwidth</code> em seu pod.
Por exemplo:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/ingress-bandwidth</span>:<span style=color:#bbb> </span>1M<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/egress-bandwidth</span>:<span style=color:#bbb> </span>1M<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div><h3 id=kubenet>kubenet</h3><p>Kubenet é um plugin de rede muito simples, existente apenas no Linux. Ele não
implementa funcionalidades mais avançadas, como rede entre nós ou políticas de rede.
Ele é geralmente utilizado junto a um provedor de nuvem que configura as regras de
roteamento para comunicação entre os nós, ou em ambientes com apenas um nó.</p><p>O Kubenet cria uma <em>interface bridge</em> no Linux chamada <code>cbr0</code> e cria um par <em>veth</em>
para cada um dos pods com o host como a outra ponta desse par, conectado à <code>cbr0</code>.
Na interface no lado do Pod um endereço IP é alocado de uma faixa associada ao nó,
sendo parte de alguma configuração no nó ou pelo controller-manager. Na interface <code>cbr0</code>
é associado o MTU equivalente ao menor MTU de uma interface de rede do host.</p><p>Esse plugin possui alguns requisitos:</p><ul><li>Os plugins CNI padrão <code>bridge</code>, <code>lo</code> e <code>host-local</code> são obrigatórios, ao menos na
versão 0.2.0. O Kubenet buscará inicialmente esses plugins no diretório <code>/opt/cni/bin</code>.
Especifique a opção <code>cni-bin-dir</code> no kubelet para fornecer um diretório adicional
de busca. O primeiro local equivalente será o utilizado.</li><li>O kubelet deve ser executado com a opção <code>--network-plugin=kubenet</code> para habilitar esse plugin.</li><li>O Kubelet deve ainda ser executado com a opção <code>--non-masquerade-cidr=&lt;clusterCidr></code> para
garantir que o tráfego de IPs para fora dessa faixa seja mascarado.</li><li>O nó deve possuir uma subrede associada, através da opção <code>--pod-cidr</code> configurada
na inicialização do kubelet, ou as opções <code>--allocate-node-cidrs=true --cluster-cidr=&lt;cidr></code>
utilizadas na inicialização do <em>controller-manager</em>.</li></ul><h3 id=customizando-o-mtu-com-kubenet>Customizando o MTU (com kubenet)</h3><p>O MTU deve sempre ser configurado corretamente para obter-se a melhor performance de
rede. Os plugins de rede geralmente tentam detectar uma configuração correta de MTU,
porém algumas vezes a lógica não irá resultar em uma configuração adequada. Por exemplo,
se a <em>Docker bridge</em> ou alguma outra interface possuir um MTU pequeno, o kubenet irá
selecionar aquela MTU. Ou caso você esteja utilizando encapsulamento IPSEC, o MTU deve
ser reduzido, e esse cálculo não faz parte do escopo da maioria dos plugins de rede.</p><p>Sempre que necessário, você pode configurar explicitamente o MTU com a opção <code>network-plugin-mtu</code>
no kubelet. Por exemplo, na AWS o MTU da <code>eth0</code> geralmente é 9001 então você deve
especificar <code>--network-plugin-mtu=9001</code>. Se você estiver usando IPSEC você deve reduzir
o MTU para permitir o encapsulamento excedente; por exemplo: <code>--network-plugin-mtu=8773</code>.</p><p>Essa opção faz parte do plugin de rede. Atualmente <strong>apenas o kubenet suporta a configuração
<code>network-plugin-mtu</code></strong>.</p><h2 id=resumo-de-uso>Resumo de uso</h2><ul><li><code>--network-plugin=cni</code> especifica que devemos usar o plugin de redes <code>cni</code> com os
binários do plugin localizados em <code>--cni-bin-dir</code> (padrão <code>/opt/cni/bin</code>) e as
configurações do plugin localizadas em <code>--cni-conf-dir</code> (default <code>/etc/cni/net.d</code>).</li><li><code>--network-plugin=kubenet</code> especifica que iremos usar o plugin de rede <code>kubenet</code>
com os plugins CNI <code>bridge</code>, <code>lo</code> e <code>host-local</code> localizados em <code>/opt/cni/bin</code> ou <code>cni-bin-dir</code>.</li><li><code>--network-plugin-mtu=9001</code> especifica o MTU a ser utilizado, atualmente apenas em uso
pelo plugin de rede <code>kubenet</code></li></ul><h2 id=what-s-next>What's next</h2></div><div class=td-content style=page-break-before:always><h1 id=pg-3131452556176159fb269593c1a52012>8.3 - Padrão Operador</h1><p>Operadores são extensões de software para o Kubernetes que
fazem uso de <a href=/docs/concepts/extend-kubernetes/api-extension/custom-resources/><em>recursos personalizados</em></a>
para gerir aplicações e os seus componentes. Operadores seguem os<br>princípios do Kubernetes, notavelmente o <a href=/docs/concepts/#kubernetes-control-plane>ciclo de controle</a>.</p><h2 id=motivação>Motivação</h2><p>O padrão Operador tem como objetivo capturar o principal objetivo de um operador
humano que gere um serviço ou um conjunto de serviços. Operadores humanos
responsáveis por aplicações e serviços específicos têm um conhecimento
profundo da forma como o sistema é suposto se comportar, como é instalado
e como deve reagir na ocorrência de problemas.</p><p>As pessoas que executam cargas de trabalho no Kubernetes habitualmente gostam
de usar automação para cuidar de tarefas repetitivas. O padrão Operador captura
a forma como pode escrever código para automatizar uma tarefa para além do que
o Kubernetes fornece.</p><h2 id=operadores-no-kubernetes>Operadores no Kubernetes</h2><p>O Kubernetes é desenhado para automação. <em>Out of the box</em>, você tem bastante
automação embutida no núcleo do Kubernetes. Pode usar
o Kubernetes para automatizar instalações e executar cargas de trabalho,
e pode ainda automatizar a forma como o Kubernetes faz isso.</p><p>O conceito de <a class=glossary-tooltip title="Um ciclo de controle que observa o estado partilhado do cluster através do API Server e efetua mudanças tentando mover o estado atual em direção ao estado desejado." data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controlador>controlador</a> no
Kubernetes permite a extensão do comportamento sem modificar o código do próprio
Kubernetes.
Operadores são clientes da API do Kubernetes que atuam como controladores para
um dado <a href=/docs/concepts/api-extension/custom-resources/><em>Custom Resource</em></a></p><h2 id=exemplo>Exemplo de um Operador</h2><p>Algumas das coisas que um operador pode ser usado para automatizar incluem:</p><ul><li>instalar uma aplicação a pedido</li><li>obter e restaurar backups do estado dessa aplicação</li><li>manipular atualizações do código da aplicação juntamente com alterações
como esquemas de base de dados ou definições de configuração extra</li><li>publicar um <em>Service</em> para aplicações que não suportam a APIs do Kubernetes
para as descobrir</li><li>simular una falha em todo ou parte do cluster de forma a testar a resiliência</li><li>escolher um lider para uma aplicação distribuída sem um processo
de eleição de membro interno</li></ul><p>Como deve um Operador parecer em mais detalhe? Aqui está um exemplo em mais
detalhe:</p><ol><li>Um recurso personalizado (<em>custom resource</em>) chamado SampleDB, que você pode
configurar para dentro do <em>cluster</em>.</li><li>Um <em>Deployment</em> que garante que um <em>Pod</em> está a executar que contém a
parte controlador do operador.</li><li>Uma imagem do <em>container</em> do código do operador.</li><li>Código do controlador que consulta o plano de controle para descobrir quais
recursos <em>SampleDB</em> estão configurados.</li><li>O núcleo do Operador é o código para informar ao servidor da API (<em>API server</em>) como fazer
a realidade coincidir com os recursos configurados.<ul><li>Se você adicionar um novo <em>SampleDB</em>, o operador configurará <em>PersistentVolumeClaims</em>
para fornecer armazenamento de base de dados durável, um <em>StatefulSet</em> para executar <em>SampleDB</em> e
um <em>Job</em> para lidar com a configuração inicial.</li><li>Se você apagá-lo, o Operador tira um <em>snapshot</em> e então garante que
o <em>StatefulSet</em> e <em>Volumes</em> também são removidos.</li></ul></li><li>O operador também gere backups regulares da base de dados. Para cada recurso <em>SampleDB</em>,
o operador determina quando deve criar um <em>Pod</em> que possa se conectar
à base de dados e faça backups. Esses <em>Pods</em> dependeriam de um <em>ConfigMap</em>
e / ou um <em>Secret</em> que possui detalhes e credenciais de conexão com à base de dados.</li><li>Como o Operador tem como objetivo fornecer automação robusta para o recurso
que gere, haveria código de suporte adicional. Para este exemplo,
O código verifica se a base de dados está a executar uma versão antiga e, se estiver,
cria objetos <em>Job</em> que o atualizam para si.</li></ol><h2 id=instalar-operadores>Instalar Operadores</h2><p>A forma mais comum de instalar um Operador é a de adicionar a
definição personalizada de recurso (<em>Custom Resource Definition</em>) e
o seu Controlador associado ao seu cluster.
O Controlador vai normalmente executar fora do
<a class=glossary-tooltip title="A camada de gerenciamento de contêiner que expõe a API e as interfaces para definir, implantar e gerenciar o ciclo de vida dos contêineres." data-toggle=tooltip data-placement=top href="/pt/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label="plano de controle">plano de controle</a>,
como você faria com qualquer aplicação containerizada.
Por exemplo, você pode executar o controlador no seu cluster como um <em>Deployment</em>.</p><h2 id=usando-um-operador>Usando um Operador</h2><p>Uma vez que você tenha um Operador instalado, usaria-o adicionando, modificando
ou apagando a espécie de recurso que o Operador usa. Seguindo o exemplo acima,
você configuraria um <em>Deployment</em> para o próprio Operador, e depois:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get SampleDB                   <span style=color:#080;font-style:italic># encontra a base de dados configurada</span>

kubectl edit SampleDB/example-database <span style=color:#080;font-style:italic># mudar manualmente algumas definições</span>
</code></pre></div><p>…e é isso! O Operador vai tomar conta de aplicar
as mudanças assim como manter o serviço existente em boa forma.</p><h2 id=escrevendo-operador>Escrevendo o seu próprio Operador</h2><p>Se não existir no ecosistema um Operador que implementa
o comportamento que pretende, pode codificar o seu próprio.
<a href=#qual-%C3%A9-o-pr%C3%B3ximo>Qual é o próximo</a> você vai encontrar
alguns <em>links</em> para bibliotecas e ferramentas que pode usar
para escrever o seu próprio Operador <em>cloud native</em>.</p><p>Pode também implementar um Operador (isto é, um Controlador) usando qualquer linguagem / <em>runtime</em>
que pode atuar como um <a href=/docs/reference/using-api/client-libraries/>cliente da API do Kubernetes</a>.</p><h2 id=what-s-next>What's next</h2><ul><li>Aprenda mais sobre <a href=/docs/concepts/extend-kubernetes/api-extension/custom-resources/>Recursos Personalizados</a></li><li>Encontre operadores prontos em <a href=https://operatorhub.io/>OperatorHub.io</a> para o seu caso de uso</li><li>Use ferramentes existentes para escrever os seus Operadores:<ul><li>usando <a href=https://kudo.dev/>KUDO</a> (Kubernetes Universal Declarative Operator)</li><li>usando <a href=https://book.kubebuilder.io/>kubebuilder</a></li><li>usando <a href=https://metacontroller.app/>Metacontroller</a> juntamente com WebHooks que
implementa você mesmo</li><li>usando o <a href=https://github.com/operator-framework/getting-started>Operator Framework</a></li></ul></li><li><a href=https://operatorhub.io/>Publique</a> o seu operador para que outras pessoas o possam usar</li><li>Leia o <a href=https://coreos.com/blog/introducing-operators.html>artigo original da CoreOS</a> que introduz o padrão Operador</li><li>Leia um <a href=https://cloud.google.com/blog/products/containers-kubernetes/best-practices-for-building-kubernetes-operators-and-stateful-apps>artigo</a> da Google Cloud sobre as melhores práticas para contruir Operadores</li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/pt/docs/home/>Home</a>
<a class=text-white href=/pt/blog/>Blog</a>
<a class=text-white href=/pt/partners/>Parceiros</a>
<a class=text-white href=/pt/community/>Comunidade</a>
<a class=text-white href=/pt/case-studies/>Casos de estudo</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/popper-1.14.3.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script><script src=/js/bootstrap-4.3.1.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script><script src=/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js integrity="sha256-QGFiUam25LaJ53ab4DQGYe+k1+u3P5V0BOlj4TW07VI=" crossorigin=anonymous></script></body></html>