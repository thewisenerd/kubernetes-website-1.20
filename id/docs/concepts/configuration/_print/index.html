<!doctype html><html lang=id class=no-js><head><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-36037335-10"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','UA-36037335-10')</script><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/configuration/><link rel=alternate hreflang=zh href=https://kubernetes.io/zh/docs/concepts/configuration/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/configuration/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/configuration/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/configuration/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/configuration/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/configuration/><link rel=alternate hreflang=pt href=https://kubernetes.io/pt/docs/concepts/configuration/><link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/concepts/configuration/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.82.0"><link rel=canonical type=text/html href=https://kubernetes.io/id/docs/concepts/configuration/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Konfigurasi | Kubernetes</title><meta property="og:title" content="Konfigurasi"><meta property="og:description" content="Orkestrasi Kontainer dengan Skala Produksi"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/id/docs/concepts/configuration/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Konfigurasi"><meta itemprop=description content="Orkestrasi Kontainer dengan Skala Produksi"><meta name=twitter:card content="summary"><meta name=twitter:title content="Konfigurasi"><meta name=twitter:description content="Orkestrasi Kontainer dengan Skala Produksi"><link rel=preload href=/scss/main.min.aeea2a074ae7ac3d467a0d6f52e45894b49452cbb3f0f410c268ec7280c5a653.css as=style><link href=/scss/main.min.aeea2a074ae7ac3d467a0d6f52e45894b49452cbb3f0f410c268ec7280c5a653.css rel=stylesheet integrity><script src=/js/jquery-3.3.1.min.js integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin=anonymous></script><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png"}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:url" content="https://kubernetes.io/id/docs/concepts/configuration/"><meta property="og:title" content="Konfigurasi"><meta name=twitter:title content="Konfigurasi"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/script.js></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/id/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/id/docs/>Dokumentasi</span></a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/id/community/>Komunitas</span></a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/id/case-studies/>Studi kasus</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versi</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=https://kubernetes.io/id/docs/concepts/configuration/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/id/docs/concepts/configuration/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/id/docs/concepts/configuration/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/id/docs/concepts/configuration/>v1.21</a>
<a class=dropdown-item href=https://v1-20.docs.kubernetes.io/id/docs/concepts/configuration/>v1.20</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Bahasa Indonesia</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/configuration/>English</a>
<a class=dropdown-item href=/zh/docs/concepts/configuration/>中文 Chinese</a>
<a class=dropdown-item href=/ko/docs/concepts/configuration/>한국어 Korean</a>
<a class=dropdown-item href=/ja/docs/concepts/configuration/>日本語 Japanese</a>
<a class=dropdown-item href=/fr/docs/concepts/configuration/>Français</a>
<a class=dropdown-item href=/de/docs/concepts/configuration/>Deutsch</a>
<a class=dropdown-item href=/es/docs/concepts/configuration/>Español</a>
<a class=dropdown-item href=/pt/docs/concepts/configuration/>Português</a>
<a class=dropdown-item href=/uk/docs/concepts/configuration/>Українська</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"></div><div class="d-none d-xl-block col-xl-2 td-toc d-print-none"></div><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/id/docs/concepts/configuration/>Return to the regular view of this page</a>.</p></div><h1 class=title>Konfigurasi</h1><ul><li>1: <a href=#pg-ba9af0ed22c38fb8a45f14dc77d29e0e>Bin Packing Sumber Daya untuk Sumber Daya Tambahan</a></li><li>2: <a href=#pg-ddef6fd0e47bb51c6f05e8e7fb11d2dd>Konfigurasi dan Penerapan Konsep</a></li><li>3: <a href=#pg-4c9401ed6b037e1adb958cbce20630c7>Mengatur Sumber Daya Komputasi untuk Container</a></li><li>4: <a href=#pg-311a77266b790c3614dc2363a3a70aac>Menetapkan Pod ke Node</a></li><li>5: <a href=#pg-b5ed5deb74feef558a1d2c17569d2e3c>Taint dan Toleration</a></li><li>6: <a href=#pg-e511ed821ada65d0053341dbd8ad2bb5>Secret</a></li><li>7: <a href=#pg-ab6d20f33ad930a67ee7ef57bff6c75e>Mengatur Akses Klaster Menggunakan Berkas kubeconfig</a></li><li>8: <a href=#pg-ed4ae5e4344d619bc6df6e1278efae74>Prioritas dan Pemindahan Pod</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-ba9af0ed22c38fb8a45f14dc77d29e0e>1 - Bin Packing Sumber Daya untuk Sumber Daya Tambahan</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes 1.16 [alpha]</code></div><p><em>Kube-scheduler</em> dapat dikonfigurasikan untuk mengaktifkan pembungkusan rapat
(<em>bin packing</em>) sumber daya bersama dengan sumber daya tambahan melalui fungsi prioritas
<code>RequestedToCapacityRatioResourceAllocation</code>. Fungsi-fungsi prioritas dapat digunakan
untuk menyempurnakan <em>kube-scheduler</em> sesuai dengan kebutuhan.</p><h2 id=mengaktifkan-bin-packing-menggunakan-requestedtocapacityratioresourceallocation>Mengaktifkan <em>Bin Packing</em> menggunakan RequestedToCapacityRatioResourceAllocation</h2><p>Sebelum Kubernetes 1.15, <em>kube-scheduler</em> digunakan untuk memungkinkan mencetak
skor berdasarkan rasio permintaan terhadap kapasitas sumber daya utama seperti
CPU dan Memori. Kubernetes 1.16 menambahkan parameter baru ke fungsi prioritas
yang memungkinkan pengguna untuk menentukan sumber daya beserta dengan bobot
untuk setiap sumber daya untuk memberi nilai dari Node berdasarkan rasio
permintaan terhadap kapasitas. Hal ini memungkinkan pengguna untuk <em>bin pack</em>
sumber daya tambahan dengan menggunakan parameter yang sesuai untuk meningkatkan
pemanfaatan sumber daya yang langka dalam klaster yang besar. Perilaku
<code>RequestedToCapacityRatioResourceAllocation</code> dari fungsi prioritas dapat
dikontrol melalui pilihan konfigurasi yang disebut <code>RequestToCapacityRatioArguments</code>.
Argumen ini terdiri dari dua parameter yaitu <code>shape</code> dan <code>resources</code>. Shape
memungkinkan pengguna untuk menyempurnakan fungsi menjadi yang paling tidak
diminta atau paling banyak diminta berdasarkan nilai <code>utilization</code> dan <code>score</code>.
Sumber daya terdiri dari <code>name</code> yang menentukan sumber daya mana yang dipertimbangkan
selama penilaian dan <code>weight</code> yang menentukan bobot masing-masing sumber daya.</p><p>Di bawah ini adalah contoh konfigurasi yang menetapkan <code>requestedToCapacityRatioArguments</code>
pada perilaku <em>bin packing</em> untuk sumber daya tambahan<code> intel.com/foo</code> dan <code>intel.com/bar</code></p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
    <span style=color:green;font-weight:700>&#34;kind&#34;</span> : <span style=color:#b44>&#34;Policy&#34;</span>,
    <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span> : <span style=color:#b44>&#34;v1&#34;</span>,

    <span>...</span>

    <span style=color:green;font-weight:700>&#34;priorities&#34;</span> : [

       <span>...</span>

      {
        <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;RequestedToCapacityRatioPriority&#34;</span>,
        <span style=color:green;font-weight:700>&#34;weight&#34;</span>: <span style=color:#666>2</span>,
        <span style=color:green;font-weight:700>&#34;argument&#34;</span>: {
          <span style=color:green;font-weight:700>&#34;requestedToCapacityRatioArguments&#34;</span>: {
            <span style=color:green;font-weight:700>&#34;shape&#34;</span>: [
              {<span style=color:green;font-weight:700>&#34;utilization&#34;</span>: <span style=color:#666>0</span>, <span style=color:green;font-weight:700>&#34;score&#34;</span>: <span style=color:#666>0</span>},
              {<span style=color:green;font-weight:700>&#34;utilization&#34;</span>: <span style=color:#666>100</span>, <span style=color:green;font-weight:700>&#34;score&#34;</span>: <span style=color:#666>10</span>}
            ],
            <span style=color:green;font-weight:700>&#34;resources&#34;</span>: [
              {<span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;intel.com/foo&#34;</span>, <span style=color:green;font-weight:700>&#34;weight&#34;</span>: <span style=color:#666>3</span>},
              {<span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;intel.com/bar&#34;</span>, <span style=color:green;font-weight:700>&#34;weight&#34;</span>: <span style=color:#666>5</span>}
            ]
          }
        }
      }
    ],
  }
</code></pre></div><p><strong>Fitur ini dinonaktifkan secara <em>default</em></strong></p><h3 id=tuning-requestedtocapacityratioresourceallocation-priority-function>Tuning RequestedToCapacityRatioResourceAllocation Priority Function</h3><p><code>shape</code> digunakan untuk menentukan perilaku dari fungsi <code>RequestedToCapacityRatioPriority</code>.</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb> </span>{<span style=color:green;font-weight:700>&#34;utilization&#34;: 0, &#34;score&#34;: </span><span style=color:#666>0</span>},<span style=color:#bbb>
</span><span style=color:#bbb> </span>{<span style=color:green;font-weight:700>&#34;utilization&#34;: 100, &#34;score&#34;: </span><span style=color:#666>10</span>}<span style=color:#bbb>
</span></code></pre></div><p>Argumen di atas memberikan Node nilai 0 jika utilisasi 0% dan 10 untuk utilisasi 100%,
yang kemudian mengaktfikan perilaku <em>bin packing</em>. Untuk mengaktifkan dari paling
yang tidak diminta, nilainya harus dibalik sebagai berikut.</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb> </span>{<span style=color:green;font-weight:700>&#34;utilization&#34;: 0, &#34;score&#34;: </span><span style=color:#666>100</span>},<span style=color:#bbb>
</span><span style=color:#bbb> </span>{<span style=color:green;font-weight:700>&#34;utilization&#34;: 100, &#34;score&#34;: </span><span style=color:#666>0</span>}<span style=color:#bbb>
</span></code></pre></div><p><code>resources</code> adalah parameter opsional yang secara <em>default</em> diatur ke:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>&#34;resources&#34;: </span>[<span style=color:#bbb>
</span><span style=color:#bbb>              </span>{<span style=color:green;font-weight:700>&#34;name&#34;: &#34;CPU&#34;, &#34;weight&#34;: </span><span style=color:#666>1</span>},<span style=color:#bbb>
</span><span style=color:#bbb>              </span>{<span style=color:green;font-weight:700>&#34;name&#34;: &#34;Memory&#34;, &#34;weight&#34;: </span><span style=color:#666>1</span>}<span style=color:#bbb>
</span><span style=color:#bbb>            </span>]<span style=color:#bbb>
</span></code></pre></div><p>Ini dapat digunakan untuk menambahkan sumber daya tambahan sebagai berikut:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>&#34;resources&#34;: </span>[<span style=color:#bbb>
</span><span style=color:#bbb>              </span>{<span style=color:green;font-weight:700>&#34;name&#34;: &#34;intel.com/foo&#34;, &#34;weight&#34;: </span><span style=color:#666>5</span>},<span style=color:#bbb>
</span><span style=color:#bbb>              </span>{<span style=color:green;font-weight:700>&#34;name&#34;: &#34;CPU&#34;, &#34;weight&#34;: </span><span style=color:#666>3</span>},<span style=color:#bbb>
</span><span style=color:#bbb>              </span>{<span style=color:green;font-weight:700>&#34;name&#34;: &#34;Memory&#34;, &#34;weight&#34;: </span><span style=color:#666>1</span>}<span style=color:#bbb>
</span><span style=color:#bbb>            </span>]<span style=color:#bbb>
</span></code></pre></div><p>Parameter <code>weight</code> adalah opsional dan diatur ke 1 jika tidak ditentukan.
Selain itu, <code>weight</code> tidak dapat diatur ke nilai negatif.</p><h3 id=bagaimana-fungsi-prioritas-requestedtocapacityratioresourceallocation-menilai-node>Bagaimana Fungsi Prioritas RequestedToCapacityRatioResourceAllocation Menilai Node</h3><p>Bagian ini ditujukan bagi kamu yang ingin memahami secara detail internal
dari fitur ini.
Di bawah ini adalah contoh bagaimana nilai dari Node dihitung untuk satu kumpulan
nilai yang diberikan.</p><pre><code>Sumber daya yang diminta

intel.com/foo : 2
Memory: 256MB
CPU: 2

Bobot dari sumber daya

intel.com/foo : 5
Memory: 1
CPU: 3

FunctionShapePoint {{0, 0}, {100, 10}}

Spesifikasi dari Node 1

Tersedia:

intel.com/foo : 4
Memory : 1 GB
CPU: 8

Digunakan:

intel.com/foo: 1
Memory: 256MB
CPU: 1


Nilai Node:

intel.com/foo  = resourceScoringFunction((2+1),4)
               =  (100 - ((4-3)*100/4)
               =  (100 - 25)
               =  75
               =  rawScoringFunction(75)
               = 7

Memory         = resourceScoringFunction((256+256),1024)
               = (100 -((1024-512)*100/1024))
               = 50
               = rawScoringFunction(50)
               = 5

CPU            = resourceScoringFunction((2+1),8)
               = (100 -((8-3)*100/8))
               = 37.5
               = rawScoringFunction(37.5)
               = 3

NodeScore   =  (7 * 5) + (5 * 1) + (3 * 3) / (5 + 1 + 3)
            =  5


Spesifikasi dari Node 2

Tersedia:

intel.com/foo: 8
Memory: 1GB
CPU: 8

Digunakan:

intel.com/foo: 2
Memory: 512MB
CPU: 6


Nilai Node:

intel.com/foo  = resourceScoringFunction((2+2),8)
               =  (100 - ((8-4)*100/8)
               =  (100 - 25)
               =  50
               =  rawScoringFunction(50)
               = 5

Memory         = resourceScoringFunction((256+512),1024)
               = (100 -((1024-768)*100/1024))
               = 75
               = rawScoringFunction(75)
               = 7

CPU            = resourceScoringFunction((2+6),8)
               = (100 -((8-8)*100/8))
               = 100
               = rawScoringFunction(100)
               = 10

NodeScore   =  (5 * 5) + (7 * 1) + (10 * 3) / (5 + 1 + 3)
            =  7

</code></pre></div><div class=td-content style=page-break-before:always><h1 id=pg-ddef6fd0e47bb51c6f05e8e7fb11d2dd>2 - Konfigurasi dan Penerapan Konsep</h1><p>Dokumen ini menyoroti dan memperkuat pemahaman konsep konfigurasi yang dikenalkan di seluruh panduan pengguna, dokumentasi Memulai, dan contoh-contoh.</p><p>Dokumentasi ini terbuka. Jika Anda menemukan sesuatu yang tidak ada dalam daftar ini tetapi mungkin bermanfaat bagi orang lain, jangan ragu untuk mengajukan issue atau mengirimkan PR.</p><h2 id=tip-konfigurasi-secara-umum>Tip konfigurasi secara umum</h2><ul><li><p>Saat mendefinisikan konfigurasi, tentukan versi API stabil terbaru.</p></li><li><p>File konfigurasi harus disimpan dalam version control sebelum di push ke cluster. Ini memungkinkan Anda untuk dengan cepat mengembalikan perubahan konfigurasi jika perlu. Ini juga membantu penciptaan dan restorasi cluster.</p></li><li><p>Tulis file konfigurasi Anda menggunakan YAML tidak dengan JSON. Meskipun format ini dapat digunakan secara bergantian di hampir semua skenario, YAML cenderung lebih ramah pengguna.</p></li><li><p>Kelompokkan objek terkait ke dalam satu file yang memungkinkan. Satu file seringkali lebih mudah dikelola daripada beberapa file. Lihat pada <a href=https://github.com/kubernetes/examples/tree/v1.20.15/guestbook/all-in-one/guestbook-all-in-one.yaml>guestbook-all-in-one.yaml</a> sebagai contoh file sintaks ini.</p></li><li><p>Perhatikan juga bahwa banyak perintah <code>kubectl</code> dapat dipanggil pada direktori. Misalnya, Anda dapat memanggil <code>kubectl apply</code> pada direktori file konfigurasi.</p></li><li><p>Jangan tentukan nilai default yang tidak perlu: sederhana, konfigurasi minimal akan membuat kesalahan lebih kecil.</p></li><li><p>Masukkan deskripsi objek dalam anotasi, untuk memungkinkan introspeksi yang lebih baik.</p></li></ul><h2 id=naked-pods-vs-replicasets-deployments-and-jobs>"Naked" Pods vs ReplicaSets, Deployments, and Jobs</h2><ul><li><p>Jangan gunakan Pods naked (artinya, Pods tidak terikat dengan a <a href=/id/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a> a <a href=/id/docs/concepts/workloads/controllers/deployment/>Deployment</a>) jika kamu bisa menghindarinya. Pod naked tidak akan dijadwal ulang jika terjadi kegagalan pada node.</p><p>Deployment, yang keduanya menciptakan ReplicaSet untuk memastikan bahwa jumlah Pod yang diinginkan selalu tersedia, dan menentukan strategi untuk mengganti Pods (seperti <a href=/id/docs/concepts/workloads/controllers/deployment/#rolling-update-deployment>RollingUpdate</a>), hampir selalu lebih disukai daripada membuat Pods secara langsung, kecuali untuk beberapa yang eksplisit <a href=/id/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy><code>restartPolicy: Never</code></a> banyak skenario . A <a href=/id/docs/concepts/workloads/controllers/jobs-run-to-completion/>Job</a> mungkin juga sesuai.</p></li></ul><h2 id=services>Services</h2><ul><li><p>Buat <a href=/id/docs/concepts/services-networking/service/>Service</a> sebelum workloads backend terkait (Penyebaran atau ReplicaSets), dan sebelum workloads apa pun yang perlu mengaksesnya. Ketika Kubernetes memulai sebuah container, ia menyediakan environment variabel yang menunjuk ke semua Layanan yang berjalan ketika container itu dimulai. Misalnya, jika Layanan bernama <code>foo</code> ada, semua container akan mendapatkan variabel berikut di environment awalnya:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>FOO_SERVICE_HOST</span><span style=color:#666>=</span>&lt;the host the Service is running on&gt;
<span style=color:#b8860b>FOO_SERVICE_PORT</span><span style=color:#666>=</span>&lt;the port the Service is running on&gt;
</code></pre></div><p>*Ini menunjukan persyaratan pemesanan * - <code>Service</code> apa pun yang ingin diakses oleh<code> Pod</code> harus dibuat sebelum <code>Pod</code> itu sendiri, atau environment variabel tidak akan diisi. DNS tidak memiliki batasan ini.</p></li><li><p>Opsional (meskipun sangat disarankan) <a href=/id/docs/concepts/cluster-administration/addons/>cluster add-on</a> adalah server DNS.
Server DNS melihat API Kubernetes untuk <code>Service</code> baru dan membuat satu set catatan DNS untuk masing-masing. Jika DNS telah diaktifkan di seluruh cluster maka semua <code>Pods</code> harus dapat melakukan resolusi nama<code>Service</code> secara otomatis.</p></li><li><p>Jangan tentukan <code>hostPort</code> untuk Pod kecuali jika benar-benar diperlukan. Ketika Anda bind Pod ke <code>hostPort</code>, hal itu membatasi jumlah tempat Pod dapat dijadwalkan, karena setiap kombinasi &lt;<code> hostIP</code>, <code>hostPort</code>,<code> protokol</code>> harus unik. Jika Anda tidak menentukan <code>hostIP</code> dan<code> protokol</code> secara eksplisit, Kubernetes akan menggunakan <code>0.0.0.0</code> sebagai<code> hostIP</code> dan <code>TCP</code> sebagai default<code> protokol</code>.</p><p>Jika kamu hanya perlu akses ke port untuk keperluan debugging, Anda bisa menggunakan <a href=/id/docs/tasks/access-application-cluster/access-cluster/#manually-constructing-apiserver-proxy-urls>apiserver proxy</a> atau <a href=/id/docs/tasks/access-application-cluster/port-forward-access-application-cluster/><code>kubectl port-forward</code></a>.</p><p>Jika Anda secara eksplisit perlu mengekspos port Pod pada node, pertimbangkan untuk menggunakan <a href=/id/docs/concepts/services-networking/service/#nodeport>NodePort</a> Service sebelum beralih ke <code>hostPort</code>.</p></li><li><p>Hindari menggunakan <code>hostNetwork</code>, untuk alasan yang sama seperti<code> hostPort</code>.</p></li><li><p>Gunakan [headless Services](/id/docs/concepts/services-networking/service/#headless-
services) (yang memiliki <code>ClusterIP</code> dari<code> None</code>) untuk Service discovery yang mudah ketika Anda tidak membutuhkan <code>kube-proxy</code> load balancing.</p></li></ul><h2 id=menggunakan-label>Menggunakan label</h2><ul><li>Deklarasi dan gunakan [labels] (/id/docs/concepts/overview/working-with-objects/labels/) untuk identifikasi <strong>semantic attributes</strong> aplikasi atau Deployment kamu, seperti <code>{ app: myapp, tier: frontend, phase: test, deployment: v3 }</code>. Kamu dapat menggunakan label ini untuk memilih Pod yang sesuai untuk sumber daya lainnya; misalnya, Service yang memilih semua <code>tier: frontend</code> Pods, atau semua komponen<code> phase: test</code> dari <code>app: myapp</code>. Lihat <a href=https://github.com/kubernetes/examples/tree/v1.20.15/guestbook/>guestbook</a> aplikasi untuk contoh-contoh pendekatan ini.</li></ul><p>Service dapat dibuat untuk menjangkau beberapa Penyebaran dengan menghilangkan label khusus rilis dari pemilihnya. <a href=/id/docs/concepts/workloads/controllers/deployment/>Deployments</a> membuatnya mudah untuk memperbarui Service yang sedang berjalan tanpa downtime.</p><p>Keadaan objek yang diinginkan dideskripsikan oleh Deployment, dan jika perubahan terhadap spesifikasi tersebut adalah <em>applied</em>, Deployment controller mengubah keadaan aktual ke keadaan yang diinginkan pada tingkat yang terkontrol.</p><ul><li>Kamu dapat memanipulasi label untuk debugging. Karena Kubernetes controller (seperti ReplicaSet) dan Service Match dengan Pods menggunakan label pemilih, menghapus label yang relevan dari Pod akan menghentikannya dari dianggap oleh Controller atau dari lalu lintas yang dilayani oleh Service. Jika Anda menghapus label dari Pod yang ada, Controller akan membuat Pod baru untuk menggantikannya. Ini adalah cara yang berguna untuk men-debug Pod yang sebelumnya "live" di Environment "quarantine". Untuk menghapus atau menambahkan label secara interaktif, gunakan <a href=/docs/reference/generated/kubectl/kubectl-commands#label><code>kubectl label</code></a>.</li></ul><h2 id=container-images>Container Images</h2><p>Ini <a href=/id/docs/concepts/containers/images/#updating-images>imagePullPolicy</a> dan tag dari image mempengaruhi ketika <a href=/docs/admin/kubelet/>kubelet</a> mencoba menarik image yang ditentukan</p><ul><li><p><code>imagePullPolicy: IfNotPresent</code>: image ditarik hanya jika belum ada secara lokal.</p></li><li><p><code>imagePullPolicy: Always</code>: Image ditarik setiap kali pod dimulai.</p></li><li><p><code>imagePullPolicy</code> dihilangkan dan tag imagenya adalah <code>:latest</code> atau dihilangkan:<code>always</code> diterapkan.</p></li><li><p><code>imagePullPolicy</code> dihilangkan dan tag image ada tetapi tidak <code>:latest</code>:<code> IfNotPresent</code> diterapkan.</p></li><li><p><code>imagePullPolicy: Never</code>: image diasumsikan ada secara lokal. Tidak ada upaya yang dilakukan untuk menarik image.</p></li></ul><blockquote class="note callout"><div><strong>Catatan:</strong> Untuk memastikan container selalu menggunakan versi image yang sama, Anda bisa menentukannya <a href=https://docs.docker.com/engine/reference/commandline/pull/#pull-an-image-by-digest-immutable-identifier>digest</a>, untuk contoh <code>sha256:45b23dee08af5e43a7fea6c4cf9c25ccf269ee113168c19722f87876677c5cb2</code>. digest mengidentifikasi secara unik versi image tertentu, sehingga tidak pernah diperbarui oleh Kubernetes kecuali Anda mengubah nilai digest.</div></blockquote><blockquote class="note callout"><div><strong>Catatan:</strong> Anda harus menghindari penggunaan tag <code>: latest</code> saat menempatkan container dalam produksi karena lebih sulit untuk melacak versi image mana yang sedang berjalan dan lebih sulit untuk memutar kembali dengan benar.</div></blockquote><blockquote class="note callout"><div><strong>Catatan:</strong> Semantik caching dari penyedia gambar yang mendasarinya membuat bahkan <code>imagePullPolicy: Always</code> efisien. Dengan Docker, misalnya, jika image sudah ada, upaya pull cepat karena semua lapisan image di-cache dan tidak perlu mengunduh image.</div></blockquote><h2 id=menggunakan-kubectl>Menggunakan kubectl</h2><ul><li><p>Gunakan <code>kubectl apply -f &lt;directory></code>. Ini mencari konfigurasi Kubernetes di semua file <code>.yaml</code>,<code> .yml</code>, dan <code>.json</code> di<code>&lt;directory></code>dan meneruskannya ke<code> apply</code>.</p></li><li><p>Gunakan label selector untuk operasi <code>get</code> dan<code> delete</code> alih-alih nama objek tertentu. Lihat bagian di <a href=/id/docs/concepts/overview/working-with-objects/labels/#label-selectors>label selectors</a> dan <a href=/id/docs/concepts/cluster-administration/manage-deployment/#using-labels-effectively>using labels effectively</a>.</p></li><li><p>Gunakan <code>kubectl run</code> dan<code> kubectl expose</code> untuk dengan cepat membuat Deployment dan Service single-container. Lihat <a href=/docs/tasks/access-application-cluster/service-access-application-cluster/>Use a Service to Access an Application in a Cluster</a> untuk Contoh.</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-4c9401ed6b037e1adb958cbce20630c7>3 - Mengatur Sumber Daya Komputasi untuk Container</h1><p>Saat kamu membuat spesifikasi sebuah <a href=/id/docs/concepts/workloads/pods/pod/>Pod</a>, kamu
dapat secara opsional menentukan seberapa banyak CPU dan memori (RAM) yang dibutuhkan
oleh setiap Container. Saat Container-Container menentukan <em>request</em> (permintaan) sumber daya,
scheduler dapat membuat keputusan yang lebih baik mengenai Node mana yang akan dipilih
untuk menaruh Pod-Pod. Dan saat limit (batas) sumber daya Container-Container telah ditentukan,
maka kemungkinan rebutan sumber daya pada sebuah Node dapat dihindari.
Untuk informasi lebih lanjut mengenai perbedaan <code>request</code> dan <code>limit</code>, lihat <a href=https://git.k8s.io/community/contributors/design-proposals/node/resource-qos.md>QoS Sumber Daya</a>.</p><h2 id=jenis-jenis-sumber-daya>Jenis-jenis sumber daya</h2><p><em>CPU</em> dan <em>memori</em> masing-masing merupakan <em>jenis sumber daya</em> (<em>resource type</em>).
Sebuah jenis sumber daya memiliki satuan dasar. CPU ditentukan dalam satuan jumlah <em>core</em>,
dan memori ditentukan dalam satuan <em>bytes</em>. Jika kamu menggunakan Kubernetes v1.14 keatas,
kamu dapat menentukan sumber daya <em>huge page</em>. <em>Huge page</em> adalah fitur khusus Linux
di mana kernel Node mengalokasikan blok-blok memori yang jauh lebih besar daripada ukuran
<em>page</em> bawaannya.</p><p>Sebagai contoh, pada sebuah sistem di mana ukuran <em>page</em> bawaannya adalah 4KiB, kamu
dapat menentukan sebuah limit, <code>hugepages-2Mi: 80Mi</code>. Jika kontainer mencoba mengalokasikan
lebih dari 40 <em>huge page</em> berukuran 20MiB (total 80MiB), maka alokasi tersebut akan gagal.</p><blockquote class="note callout"><div><strong>Catatan:</strong> Kamu tidak dapat melakukan <em>overcommit</em> terhadap sumber daya <code>hugepages-*</code>.
Hal ini berbeda dari sumber daya <code>memory</code> dan <code>cpu</code> (yang dapat di-<em>overcommit</em>).</div></blockquote><p>CPU dan memori secara kolektif disebut sebagai <em>sumber daya komputasi</em>, atau cukup
<em>sumber daya</em> saja. Sumber daya komputasi adalah jumlah yang dapat diminta, dialokasikan,
dan dikonsumsi. Mereka berbeda dengan <a href=/id/docs/concepts/overview/kubernetes-api/>sumber daya API</a>.
Sumber daya API, seperti Pod dan <a href=/id/docs/concepts/services-networking/service/>Service</a> adalah
objek-objek yang dapat dibaca dan diubah melalui Kubernetes API Server.</p><h2 id=request-dan-limit-sumber-daya-dari-pod-dan-container>Request dan Limit Sumber daya dari Pod dan Container</h2><p>Setiap Container dari sebuah Pod dapat menentukan satu atau lebih dari hal-hal berikut:</p><ul><li><code>spec.containers[].resources.limits.cpu</code></li><li><code>spec.containers[].resources.limits.memory</code></li><li><code>spec.containers[].resources.limits.hugepages-&lt;size></code></li><li><code>spec.containers[].resources.requests.cpu</code></li><li><code>spec.containers[].resources.requests.memory</code></li><li><code>spec.containers[].resources.requests.hugepages-&lt;size></code></li></ul><p>Walaupun <code>requests</code> dan <code>limits</code> hanya dapat ditentukan pada Container individual, akan
lebih mudah untuk membahas tentang request dan limit sumber daya dari Pod. Sebuah
<em>request/limit sumber daya Pod</em> untuk jenis sumber daya tertentu adalah jumlah dari
request/limit sumber daya pada jenis tersebut untuk semua Container di dalam Pod tersebut.</p><h2 id=arti-dari-cpu>Arti dari CPU</h2><p>Limit dan request untuk sumber daya CPU diukur dalam satuan <em>cpu</em>.
Satu cpu, dalam Kubernetes, adalah sama dengan:</p><ul><li>1 vCPU AWS</li><li>1 Core GCP</li><li>1 vCore Azure</li><li>1 vCPU IBM</li><li>1 <em>Hyperthread</em> pada sebuah prosesor Intel <em>bare-metal</em> dengan Hyperthreading</li></ul><p>Request dalam bentuk pecahan diizinkan. Sebuah Container dengan
<code>spec.containers[].resources.requests.cpu</code> bernilai <code>0.5</code> dijamin mendapat
setengah CPU dibandingkan dengan yang meminta 1 CPU. Ekspresi nilai <code>0.1</code> ekuivalen
dengan ekspresi nilai <code>100m</code>, yang dapat dibaca sebagai "seratus milicpu". Beberapa
orang juga membacanya dengan "seratus milicore", dan keduanya ini dimengerti sebagai
hal yang sama. Sebuah request dengan angka di belakang koma, seperti <code>0.1</code> dikonversi
menjadi <code>100m</code> oleh API, dan presisi yang lebih kecil lagi dari <code>1m</code> tidak dibolehkan.
Untuk alasan ini, bentuk <code>100m</code> mungkin lebih disukai.</p><p>CPU juga selalu diminta dalam jumlah yang mutlak, tidak sebagai jumlah yang relatif;
0.1 adalah jumlah CPU yang sama pada sebuah mesin <em>single-core</em>, <em>dual-core</em>, atau
<em>48-core</em>.</p><h2 id=arti-dari-memori>Arti dari Memori</h2><p>Limit dan request untuk <code>memory</code> diukur dalam satuan <em>bytes</em>. Kamu dapat mengekspresikan
memori sebagai <em>plain integer</em> atau sebagai sebuah <em>fixed-point integer</em> menggunakan
satu dari sufiks-sufiks berikut: E, P, T, G, M, K. Kamu juga dapat menggunakan bentuk
pangkat dua ekuivalennya: Ei, Pi, Ti, Gi, Mi, Ki.
Sebagai contoh, nilai-nilai berikut kurang lebih sama:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>128974848, 129e6, 129M, 123Mi
</code></pre></div><p>Berikut sebuah contoh.
Pod berikut memiliki dua Container. Setiap Container memiliki request 0.25 cpu dan
64MiB (2<sup>26</sup> bytes) memori. Setiap Container memiliki limit 0.5 cpu dan
128MiB memori. Kamu dapat berkata bahwa Pod tersebut memiliki request 0.5 cpu dan
128MiB memori, dan memiliki limit 1 cpu dan 265MiB memori.</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>db<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MYSQL_ROOT_PASSWORD<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;password&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;64Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;250m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;128Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>wp<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;64Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;250m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;128Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span></code></pre></div><h2 id=bagaimana-pod-pod-dengan-request-sumber-daya-dijadwalkan>Bagaimana Pod-Pod dengan request sumber daya dijadwalkan</h2><p>Saat kamu membuat sebuah Pod, Kubernetes scheduler akan memilih sebuah Node
untuk Pod tersebut untuk dijalankan. Setiap Node memiliki kapasitas maksimum
untuk setiap jenis sumber daya: jumlah CPU dan memori yang dapat disediakan
oleh Node tersebut untuk Pod-Pod. Scheduler memastikan bahwa, untuk setiap
jenis sumber daya, jumlah semua request sumber daya dari Container-Container
yang dijadwalkan lebih kecil dari kapasitas Node tersebut. Perlu dicatat
bahwa walaupun penggunaan sumber daya memori atau CPU aktual/sesungguhnya pada
Node-Node sangat rendah, scheduler tetap akan menolak untuk menaruh sebuah
Pod pada sebuah Node jika pemeriksaan kapasitasnya gagal. Hal ini adalah untuk
menjaga dari kekurangan sumber daya pada sebuah Node saat penggunaan sumber daya
meningkat suatu waktu, misalnya pada saat titik puncak <em>traffic</em> harian.</p><h2 id=bagaimana-pod-pod-dengan-limit-sumber-daya-dijalankan>Bagaimana Pod-Pod dengan limit sumber daya dijalankan</h2><p>Saat Kubelet menjalankan sebuah Container dari sebuah Pod, Kubelet tersebut
mengoper limit CPU dan memori ke <em>runtime</em> kontainer.</p><p>Ketika menggunakan Docker:</p><ul><li><p><code>spec.containers[].resources.requests.cpu</code> diubah menjadi nilai <em>core</em>-nya,
yang mungkin berbentuk angka pecahan, dan dikalikan dengan 1024. Nilai yang
lebih besar antara angka ini atau 2 digunakan sebagai nilai dari <em>flag</em>
<a href=https://docs.docker.com/engine/reference/run/#cpu-share-constraint><code>--cpu-shares</code></a>
pada perintah <code>docker run</code>.</p></li><li><p><code>spec.containers[].resources.limits.cpu</code> diubah menjadi nilai <em>millicore</em>-nya dan
dikalikan dengan 100. Nilai hasilnya adalah jumlah waktu CPU yang dapat digunakan oleh
sebuah kontainer setiap 100 milidetik. Sebuah kontainer tidak dapat menggunakan lebih
dari jatah waktu CPU-nya selama selang waktu ini.</p><blockquote class="note callout"><div><strong>Catatan:</strong> Periode kuota bawaan adalah 100ms. Resolusi minimum dari kuota CPU adalah 1 milidetik.</div></blockquote></li><li><p><code>spec.containers[].resources.limits.memory</code> diubah menjadi sebuah bilangan bulat, dan
digunakan sebagai nilai dari <em>flag</em> <a href=https://docs.docker.com/engine/reference/run/#/user-memory-constraints><code>--memory</code></a>
dari perintah <code>docker run</code>.</p></li></ul><p>Jika sebuah Container melebihi batas memorinya, Container tersebut mungkin akan diterminasi.
Jika Container tersebut dapat diulang kembali, Kubelet akan mengulangnya kembali, sama
seperti jenis kegagalan lainnya.</p><p>Jika sebuah Container melebihi request memorinya, kemungkinan Pod-nya akan dipindahkan
kapanpun Node tersebut kehabisan memori.</p><p>Sebuah Container mungkin atau mungkin tidak diizinkan untuk melebihi limit CPU-nya
untuk periode waktu yang lama. Tetapi, Container tersebut tidak akan diterminasi karena
penggunaan CPU yang berlebihan.</p><p>Untuk menentukan apabila sebuah Container tidak dapat dijadwalkan atau sedang diterminasi
karena limit sumber dayanya, lihat bagian <a href=#penyelesaian-masalah>Penyelesaian Masalah</a>.</p><h2 id=memantau-penggunaan-sumber-daya-komputasi>Memantau penggunaan sumber daya komputasi</h2><p>Penggunaan sumber daya dari sebuah Pod dilaporkan sebagai bagian dari kondisi Pod.</p><p>Jika <a href=http://releases.k8s.io/v1.20.15/cluster/addons/cluster-monitoring/README.md><em>monitoring</em> opsional</a> diaktifkan pada klaster kamu, maka penggunaan sumber daya Pod dapat diambil
dari sistem <em>monitoring</em> kamu.</p><h2 id=penyelesaian-masalah>Penyelesaian Masalah</h2><h3 id=pod-pod-saya-berkondisi-pending-tertunda-dengan-event-message-failedscheduling>Pod-Pod saya berkondisi Pending (tertunda) dengan <em>event message</em> failedScheduling</h3><p>Jika scheduler tidak dapat menemukan Node manapun yang muat untuk sebuah Pod,
Pod tersebut tidak akan dijadwalkan hingga ditemukannya sebuah tempat yang
muat. Sebuah <em>event</em> akan muncul setiap kali scheduler gagal menemukan tempat
untuk Pod tersebut, seperti berikut:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod frontend | grep -A <span style=color:#666>3</span> Events
</code></pre></div><pre><code>Events:
  FirstSeen LastSeen   Count  From          Subobject   PathReason      Message
  36s   5s     6      {scheduler }              FailedScheduling  Failed for reason PodExceedsFreeCPU and possibly others
</code></pre><p>Pada contoh di atas, Pod bernama "frontend" gagal dijadwalkan karena kekurangan
sumber daya CPU pada Node tersebut. Pesan kesalahan yang serupa dapat juga menunjukkan
kegagalan karena kekurangan memori (PodExceedsFreeMemroy). Secara umum, jika sebuah
Pod berkondisi Pending (tertunda) dengan sebuah pesan seperti ini, ada beberapa hal yang
dapat dicoba:</p><ul><li>Tambah lebih banyak Node pada klaster.</li><li>Terminasi Pod-Pod yang tidak dibutuhkan untuk memberikan ruangan untuk Pod-Pod yang
tertunda.</li><li>Periksa jika nilai request Pod tersebut tidak lebih besar dari Node-node yang ada.
Contohnya, jika semua Node memiliki kapasitas <code>cpu: 1</code>, maka Pod dengan request
<code>cpu: 1.1</code> tidak akan pernah dijadwalkan.</li></ul><p>Kamu dapat memeriksa kapasitas Node-Node dan jumlah-jumlah yang telah dialokasikan
dengan perintah <code>kubectl describe nodes</code>. Contohnya:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe nodes e2e-test-node-pool-4lw4
</code></pre></div><pre><code>Name:            e2e-test-node-pool-4lw4
[ ... lines removed for clarity ...]
Capacity:
 cpu:                               2
 memory:                            7679792Ki
 pods:                              110
Allocatable:
 cpu:                               1800m
 memory:                            7474992Ki
 pods:                              110
[ ... beberapa baris dihapus untuk kejelasan ...]
Non-terminated Pods:        (5 in total)
  Namespace    Name                                  CPU Requests  CPU Limits  Memory Requests  Memory Limits
  ---------    ----                                  ------------  ----------  ---------------  -------------
  kube-system  fluentd-gcp-v1.38-28bv1               100m (5%)     0 (0%)      200Mi (2%)       200Mi (2%)
  kube-system  kube-dns-3297075139-61lj3             260m (13%)    0 (0%)      100Mi (1%)       170Mi (2%)
  kube-system  kube-proxy-e2e-test-...               100m (5%)     0 (0%)      0 (0%)           0 (0%)
  kube-system  monitoring-influxdb-grafana-v4-z1m12  200m (10%)    200m (10%)  600Mi (8%)       600Mi (8%)
  kube-system  node-problem-detector-v0.1-fj7m3      20m (1%)      200m (10%)  20Mi (0%)        100Mi (1%)
Allocated resources:
  (Total limit mungkin melebihi 100 persen, misalnya, karena _overcommit_.)
  CPU Requests    CPU Limits    Memory Requests    Memory Limits
  ------------    ----------    ---------------    -------------
  680m (34%)      400m (20%)    920Mi (12%)        1070Mi (14%)
</code></pre><p>Pada keluaran di atas, kamu dapat melihat bahwa jika sebuah Pod meminta lebih dari
1120m CPU atau 6.23Gi memori, Pod tersebut tidak akan muat pada Node tersebut.</p><p>Dengan melihat pada bagian <code>Pods</code>, kamu dapat melihat Pod-Pod mana saja yang memakan
sumber daya pada Node tersebut.
Jumlah sumber daya yang tersedia untuk Pod-Pod kurang dari kapasitas Node, karena
<em>daemon</em> sistem menggunakan sebagian dari sumber daya yang ada. Kolom <code>allocatable</code> pada
<a href=/docs/reference/generated/kubernetes-api/v1.20/#nodestatus-v1-core>NodeStatus</a>
memberikan jumlah sumber daya yang tersedia untuk Pod-Pod. Untuk lebih lanjut, lihat
<a href=https://git.k8s.io/community/contributors/design-proposals/node/node-allocatable.md>Sumber daya Node yang dapat dialokasikan</a>.</p><p>Fitur <a href=/id/docs/concepts/policy/resource-quotas/>kuota sumber daya</a> dapat disetel untuk
membatasi jumlah sumber daya yang dapat digunakan. Jika dipakai bersama dengan Namespace,
kuota sumber daya dapat mencegah suatu tim menghabiskan semua sumber daya.</p><h3 id=container-saya-diterminasi>Container saya diterminasi</h3><p>Container kamu mungkin diterminasi karena Container tersebut melebihi batasnya. Untuk
memeriksa jika sebuah Container diterminasi karena ia melebihi batas sumber dayanya,
gunakan perintah <code>kubectl describe pod</code> pada Pod yang bersangkutan:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod simmemleak-hra99
</code></pre></div><pre><code>Name:                           simmemleak-hra99
Namespace:                      default
Image(s):                       saadali/simmemleak
Node:                           kubernetes-node-tf0f/10.240.216.66
Labels:                         name=simmemleak
Status:                         Running
Reason:
Message:
IP:                             10.244.2.75
Replication Controllers:        simmemleak (1/1 replicas created)
Containers:
  simmemleak:
    Image:  saadali/simmemleak
    Limits:
      cpu:                      100m
      memory:                   50Mi
    State:                      Running
      Started:                  Tue, 07 Jul 2015 12:54:41 -0700
    Last Termination State:     Terminated
      Exit Code:                1
      Started:                  Fri, 07 Jul 2015 12:54:30 -0700
      Finished:                 Fri, 07 Jul 2015 12:54:33 -0700
    Ready:                      False
    Restart Count:              5
Conditions:
  Type      Status
  Ready     False
Events:
  FirstSeen                         LastSeen                         Count  From                              SubobjectPath                       Reason      Message
  Tue, 07 Jul 2015 12:53:51 -0700   Tue, 07 Jul 2015 12:53:51 -0700  1      {scheduler }                                                          scheduled   Successfully assigned simmemleak-hra99 to kubernetes-node-tf0f
  Tue, 07 Jul 2015 12:53:51 -0700   Tue, 07 Jul 2015 12:53:51 -0700  1      {kubelet kubernetes-node-tf0f}    implicitly required container POD   pulled      Pod container image &quot;k8s.gcr.io/pause:0.8.0&quot; already present on machine
  Tue, 07 Jul 2015 12:53:51 -0700   Tue, 07 Jul 2015 12:53:51 -0700  1      {kubelet kubernetes-node-tf0f}    implicitly required container POD   created     Created with docker id 6a41280f516d
  Tue, 07 Jul 2015 12:53:51 -0700   Tue, 07 Jul 2015 12:53:51 -0700  1      {kubelet kubernetes-node-tf0f}    implicitly required container POD   started     Started with docker id 6a41280f516d
  Tue, 07 Jul 2015 12:53:51 -0700   Tue, 07 Jul 2015 12:53:51 -0700  1      {kubelet kubernetes-node-tf0f}    spec.containers{simmemleak}         created     Created with docker id 87348f12526a
</code></pre><p>Pada contoh di atas, <code>Restart Count: 5</code> menunjukkan bahwa Container <code>simmemleak</code>
pada Pod tersebut diterminasi dan diulang kembali sebanyak lima kali.</p><p>Kamu dapat menggunakan perintah <code>kubectl get pod</code> dengan opsi <code>-o go-template=...</code> untuk
mengambil kondisi dari Container-Container yang sebelumnya diterminasi:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod -o go-template<span style=color:#666>=</span><span style=color:#b44>&#39;{{range.status.containerStatuses}}{{&#34;Container Name: &#34;}}{{.name}}{{&#34;\r\nLastState: &#34;}}{{.lastState}}{{end}}&#39;</span>  simmemleak-hra99
</code></pre></div><pre><code>Container Name: simmemleak
LastState: map[terminated:map[exitCode:137 reason:OOM Killed startedAt:2015-07-07T20:58:43Z finishedAt:2015-07-07T20:58:43Z containerID:docker://0e4095bba1feccdfe7ef9fb6ebffe972b4b14285d5acdec6f0d3ae8a22fad8b2]]
</code></pre><p>Kamu dapat lihat bahwa Container tersebut diterminasi karena <code>reason:OOM Killed</code>, di mana
<code>OOM</code> merupakan singkatan dari <em>Out Of Memory</em>, atau kehabisan memori.</p><h2 id=penyimpanan-lokal-sementara>Penyimpanan lokal sementara</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.20 [beta]</code></div><p>Kubernetes versi 1.8 memperkenalkan sebuah sumber daya baru, <em>ephemeral-storage</em> untuk mengatur penyimpanan lokal yang bersifat sementara. Pada setiap Node Kubernetes, direktori <em>root</em> dari Kubelet (secara bawaan /var/lib/kubelet) dan direktori log (/var/log) ditaruh pada partisi <em>root</em> dari Node tersebut. Partisi ini juga digunakan bersama oleh Pod-Pod melalui volume emptyDir, log kontainer, lapisan <em>image</em>, dan lapisan kontainer yang dapat ditulis.</p><p>Partisi ini bersifat "sementara" dan aplikasi-aplikasi tidak dapat mengharapkan SLA kinerja (misalnya <em>Disk IOPS</em>) dari partisi ini. Pengelolaan penyimpanan lokal sementara hanya berlaku untuk partisi <em>root</em>; partisi opsional untuk lapisan <em>image</em> dan lapisan yang dapat ditulis berada di luar ruang lingkup.</p><blockquote class="note callout"><div><strong>Catatan:</strong> Jika sebuah partisi <em>runtime</em> opsional digunakan, partisi <em>root</em> tidak akan menyimpan lapisan <em>image</em> ataupun lapisan yang dapat ditulis manapun.</div></blockquote><h3 id=menyetel-request-dan-limit-dari-penyimpanan-lokal-sementara>Menyetel request dan limit dari penyimpanan lokal sementara</h3><p>Setiap Container dari sebuah Pod dapat menentukan satu atau lebih dari hal-hal berikut:</p><ul><li><code>spec.containers[].resources.limits.ephemeral-storage</code></li><li><code>spec.containers[].resources.requests.ephemeral-storage</code></li></ul><p>Limit dan request untuk <code>ephemeral-storage</code> diukur dalam satuan <em>bytes</em>. Kamu dapat menyatakan
penyimpanan dalam bilangan bulat biasa, atau sebagai <em>fixed-point integer</em> menggunakan satu dari
sufiks-sufiks ini: E, P, T, G, M, K. Kamu jika dapat menggunakan bentuk pangkat dua ekuivalennya:
Ei, Pi, Ti, Gi, Mi, Ki. Contohnya, nilai-nilai berikut kurang lebih sama:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>128974848, 129e6, 129M, 123Mi
</code></pre></div><p>Contohnya, Pod berikut memiliki dua Container. Setiap Container memiliki request 2GiB untuk penyimpanan lokal sementara. Setiap Container memiliki limit 4GiB untuk penyimpanan lokal sementara. Maka, Pod tersebut memiliki jumlah request 4GiB penyimpanan lokal sementara, dan limit 8GiB.</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>db<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MYSQL_ROOT_PASSWORD<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;password&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2Gi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4Gi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>wp<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2Gi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4Gi&#34;</span><span style=color:#bbb>
</span></code></pre></div><h3 id=bagaimana-pod-pod-dengan-request-ephemeral-storage-dijadwalkan>Bagaimana Pod-Pod dengan request ephemeral-storage dijadwalkan</h3><p>Saat kamu membuat sebuah Pod, Kubernetes scheduler memilih sebuah Node di mana Pod
tersebut akan dijalankan. Setiap Node memiliki jumlah maksimum penyimpanan lokal sementara yang dapat disediakan.
Untuk lebih lanjut, lihat <a href=/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>"Hal-hal yang dapat dialokasikan Node"</a>.</p><p>Scheduler memastikan bahwa jumlah dari request-request sumber daya dari Container-Container yang dijadwalkan lebih kecil dari kapasitas Node.</p><h3 id=bagaimana-pod-pod-dengan-limit-ephemeral-storage-dijalankan>Bagaimana Pod-Pod dengan limit ephemeral-storage dijalankan</h3><p>Untuk isolasi pada tingkat kontainer, jika lapisan yang dapat ditulis dari sebuah Container dan penggunaan log melebihi limit penyimpanannya, maka Pod tersebut akan dipindahkan. Untuk isolasi pada tingkat Pod, jika jumlah dari penyimpanan lokal sementara dari semua Container dan juga volume emptyDir milik Pod melebihi limit, maka Pod teresebut akan dipindahkan.</p><h3 id=memantau-penggunaan-ephemeral-storage>Memantau penggunaan ephemeral-storage</h3><p>Saat penyimpanan lokal sementara digunakan, ia dipantau terus-menerus
oleh Kubelet. Pemantauan dilakukan dengan cara memindai setiap volume
emptyDir, direktori log, dan lapisan yang dapat ditulis secara periodik.
Dimulai dari Kubernetes 1.15, volume emptyDir (tetapi tidak direktori log
atau lapisan yang dapat ditulis) dapat, sebagai pilihan dari operator
klaster, dikelola dengan menggunakan <a href=http://xfs.org/docs/xfsdocs-xml-dev/XFS_User_Guide/tmp/en-US/html/xfs-quotas.html><em>project quotas</em></a>.
<em>Project quotas</em> aslinya diimplementasikan dalam XFS, dan baru-baru ini
telah diubah ke ext4fs. <em>Project quotas</em> dapat digunakan baik untuk
<em>monitoring</em> dan pemaksaan; sejak Kubernetes 1.16, mereka tersedia sebagai
fitur <em>alpha</em> untuk <em>monitoring</em> saja.</p><p><em>Quota</em> lebih cepat dan akurat dibandingkan pemindaian direktori. Saat
sebuah direktori ditentukan untuk sebuah proyek, semua berkas yang dibuat
pada direktori tersebut dibuat untuk proyek tersebut, dan kernel hanya
perlu melacak berapa banyak blok yang digunakan oleh berkas-berkas pada
proyek tersebut. Jika sebuah berkas dibuat dan dihapus, tetapi tetap dengan
sebuah <em>file descriptor</em> yang terbuka, maka berkas tersebut tetap akan
memakan ruangan penyimpanan. Ruangan ini akan dilacak oleh <em>quota</em> tersebut,
tetapi tidak akan terlihat oleh sebuah pemindaian direktori.</p><p>Kubernetes menggunakan ID proyek yang dimulai dari 1048576. ID-ID yang
digunakan akan didaftarkan di dalam <code>/etc/projects</code> dan <code>/etc/projid</code>.
Jika ID-ID proyek pada kisaran ini digunakan untuk tujuan lain pada sistem,
ID-ID proyek tersebut harus terdaftar di dalam <code>/etc/projects</code> dan <code>/etc/projid</code>
untuk mencegah Kubernetes menggunakan ID-ID tersebut.</p><p>Untuk mengaktifkan penggunaan <em>project quotas</em>, operator klaster
harus melakukan hal-hal berikut:</p><ul><li><p>Aktifkan <em>feature gate</em> <code>LocalStorageCapacityIsolationFSQuotaMonitoring=true</code>
pada konfigurasi Kubelet. Nilainya secara bawaan <code>false</code> pada
Kubernetes 1.16, jadi harus secara eksplisit disetel menjadi <code>true</code>.</p></li><li><p>Pastikan bahwa partisi <em>root</em> (atau partisi opsional <em>runtime</em>)
telah dibangun (<em>build</em>) dengan mengaktifkan <em>project quotas</em>. Semua sistem berkas (<em>filesystem</em>)
XFS mendukung <em>project quotas</em>, tetapi sistem berkas ext4 harus dibangun
secara khusus untuk mendukungnya</p></li><li><p>Pastikan bahwa partisi <em>root</em> (atau partisi opsional <em>runtime</em>) ditambatkan (<em>mount</em>)
dengan <em>project quotas</em> yang telah diaktifkan.</p></li></ul><h4 id=membangun-dan-menambatkan-sistem-berkas-dengan-project-quotas-yang-telah-diaktifkan>Membangun dan menambatkan sistem berkas dengan <em>project quotas</em> yang telah diaktifkan</h4><p>Sistem berkas XFS tidak membutuhkan tindakan khusus saat dibangun;
mereka secara otomatis telah dibangun dengan <em>project quotas</em> yang
telah diaktifkan.</p><p>Sistem berkas <em>ext4fs</em> harus dibangun dengan mengaktifkan <em>quotas</em>,
kemudian mereka harus diaktifkan pada sistem berkas tersebut.</p><pre><code>% sudo mkfs.ext4 other_ext4fs_args... -E quotatype=prjquota /dev/block_device
% sudo tune2fs -O project -Q prjquota /dev/block_device
</code></pre><p>Untuk menambatkan sistem berkasnya, baik ext4fs dan XFS membutuhkan opsi
<code>prjquota</code> disetel di dalam <code>/etc/fstab</code>:</p><pre><code>/dev/block_device	/var/kubernetes_data	defaults,prjquota	0	0
</code></pre><h2 id=sumber-daya-yang-diperluas>Sumber daya yang diperluas</h2><p>Sumber daya yang diperluas (<em>Extended Resource</em>) adalah nama sumber daya di luar domain <code>kubernetes.io</code>.
Mereka memungkinkan operator klaster untuk menyatakan dan pengguna untuk menggunakan
sumber daya di luar sumber daya bawaan Kubernetes.</p><p>Ada dua langkah untuk menggunakan sumber daya yang diperluas. Pertama, operator
klaster harus menyatakan sebuah Extended Resource. Kedua, pengguna harus meminta
sumber daya yang diperluas tersebut di dalam Pod.</p><h3 id=mengelola-sumber-daya-yang-diperluas>Mengelola sumber daya yang diperluas</h3><h4 id=sumber-daya-yang-diperluas-pada-tingkat-node>Sumber daya yang diperluas pada tingkat Node</h4><p>Sumber daya yang diperluas pada tingkat Node terikat pada Node.</p><h5 id=sumber-daya-device-plugin-yang-dikelola>Sumber daya Device Plugin yang dikelola</h5><p>Lihat <a href=/id/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>Device
Plugin</a> untuk
cara menyatakan sumber daya <em>device plugin</em> yang dikelola pada setiap node.</p><h5 id=sumber-daya-lainnya>Sumber daya lainnya</h5><p>Untuk menyatakan sebuah sumber daya yang diperluas tingkat Node, operator klaster
dapat mengirimkan permintaan HTTP <code>PATCH</code> ke API server untuk menentukan kuantitas
sumber daya yang tersedia pada kolom <code>status.capacity</code> untuk Node pada klaster.
Setelah itu, <code>status.capacity</code> pada Node akan memiliki sumber daya baru tersebut.
Kolom <code>status.allocatable</code> diperbarui secara otomatis dengan sumber daya baru
tersebut secara <em>asynchrounous</em> oleh Kubelet. Perlu dicatat bahwa karena scheduler
menggunakan nilai <code>status.allocatable</code> milik Node saat mengevaluasi muat atau tidaknya
Pod, mungkin ada waktu jeda pendek antara melakukan <code>PATCH</code> terhadap kapasitas Node
dengan sumber daya baru dengan Pod pertama yang meminta sumber daya tersebut untuk
dapat dijadwalkan pada Node tersebut.</p><p><strong>Contoh:</strong></p><p>Berikut sebuah contoh yang menunjukkan bagaimana cara menggunakan <code>curl</code> untuk
mengirim permintaan HTTP yang menyatakan lima sumber daya "example.com/foo" pada
Node <code>k8s-node-1</code> yang memiliki master <code>k8s-master</code>.</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl --header <span style=color:#b44>&#34;Content-Type: application/json-patch+json&#34;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>--request PATCH <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>--data <span style=color:#b44>&#39;[{&#34;op&#34;: &#34;add&#34;, &#34;path&#34;: &#34;/status/capacity/example.com~1foo&#34;, &#34;value&#34;: &#34;5&#34;}]&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>http://k8s-master:8080/api/v1/nodes/k8s-node-1/status
</code></pre></div><blockquote class="note callout"><div><strong>Catatan:</strong> Pada permintaan HTTP di atas, <code>~1</code> adalah <em>encoding</em> untuk karakter <code>/</code> pada jalur (<em>path</em>) <em>patch</em>.
Nilai jalur operasi tersebut di dalam JSON-Patch diinterpretasikan sebagai sebuah JSON-Pointer.
Untuk lebih lanjut, lihat <a href=https://tools.ietf.org/html/rfc6901#section-3>IETF RFC 6901, bagian 3</a>.</div></blockquote><h4 id=sumber-daya-yang-diperluas-pada-tingkat-klaster>Sumber daya yang diperluas pada tingkat klaster</h4><p>Sumber daya yang diperluas pada tingkat klaster tidak terikat pada Node. Mereka
biasanya dikelola oleh <em>scheduler extender</em>, yang menangani penggunaan sumber daya
dan kuota sumber daya.</p><p>Kamu dapat menentukan sumber daya yang diperluas yang ditangani oleh <em>scheduler extender</em>
pada <a href=https://github.com/kubernetes/kubernetes/blob/release-1.10/pkg/scheduler/api/v1/types.go#L31>konfigurasi kebijakan scheduler</a>.</p><p><strong>Contoh:</strong></p><p>Konfigurasi untuk sebuah kebijakan scheduler berikut menunjukkan bahwa
sumber daya yang diperluas pada tingkat klaster "example.com/foo" ditangani
oleh <em>scheduler extender</em>.</p><ul><li>Scheduler mengirim sebuah Pod ke <em>scheduler extender</em> hanya jika Pod tersebut
meminta "example.com/foo".</li><li>Kolom <code>ignoredByScheduler</code> menentukan bahwa scheduler tidak memeriksa sumber daya
"example.com/foo" pada predikat <code>PodFitsResources</code> miliknya.</li></ul><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Policy&#34;</span>,
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;extenders&#34;</span>: [
    {
      <span style=color:green;font-weight:700>&#34;urlPrefix&#34;</span>:<span style=color:#b44>&#34;&lt;extender-endpoint&gt;&#34;</span>,
      <span style=color:green;font-weight:700>&#34;bindVerb&#34;</span>: <span style=color:#b44>&#34;bind&#34;</span>,
      <span style=color:green;font-weight:700>&#34;managedResources&#34;</span>: [
        {
          <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;example.com/foo&#34;</span>,
          <span style=color:green;font-weight:700>&#34;ignoredByScheduler&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>
        }
      ]
    }
  ]
}
</code></pre></div><h3 id=menggunakan-sumber-daya-yang-diperluas>Menggunakan sumber daya yang diperluas</h3><p>Pengguna dapat menggunakan sumber daya yang diperluas di dalam spesifikasi Pod
seperti CPU dan memori. Scheduler menangani akuntansi sumber daya tersebut agar
tidak ada alokasi untuk yang melebihi jumlah yang tersedia.</p><p>API server membatasi jumlah sumber daya yang diperluas dalam bentuk
bilangan bulat. Contoh jumlah yang <em>valid</em> adalah <code>3</code>, <code>3000m</code>, dan
<code>3Ki</code>. Contoh jumlah yang <em>tidak valid</em> adalah <code>0.5</code> dan <code>1500m</code>.</p><blockquote class="note callout"><div><strong>Catatan:</strong> Sumber daya yang diperluas menggantikan Opaque Integer Resource.
Pengguna dapat menggunakan prefiks nama domain selain <code>kubernetes.io</code> yang sudah dipakai.</div></blockquote><p>Untuk menggunakan sebuah sumber daya yang diperluas di sebuah Pod, masukkan nama
sumber daya tersebut sebagai nilai <em>key</em> dari map <code>spec.containers[].resources.limit</code>
pada spesifikasi Container.</p><blockquote class="note callout"><div><strong>Catatan:</strong> Sumber daya yang diperluas tidak dapat di-<em>overcommit</em>, sehingga
request dan limit nilainya harus sama jika keduanya ada di spesifikasi
sebuah Container.</div></blockquote><p>Sebuah Pod hanya dijadwalkan jika semua request sumber dayanya terpenuhi, termasuk
CPU, memori, dan sumber daya yang diperluas manapun. Pod tersebut akan tetap
berada pada kondisi <code>PENDING</code> selama request sumber daya tersebut tidak terpenuhi.</p><p><strong>Contoh:</strong></p><p>Pod di bawah meminta 2 CPU dan 1 "example.com/foo" (sebuah sumber daya yang diperluas).</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>myimage<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/foo</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/foo</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></code></pre></div><h2 id=selanjutnya>Selanjutnya</h2><ul><li><p>Dapatkan pengalaman langsung <a href=/docs/tasks/configure-pod-container/assign-memory-resource/>menentukan sumber daya memori untuk Container dan Pod</a>.</p></li><li><p>Dapatkan pengalaman langsung <a href=/docs/tasks/configure-pod-container/assign-cpu-resource/>menentukan sumber daya CPU untuk Container dan Pod</a>.</p></li><li><p><a href=/docs/reference/generated/kubernetes-api/v1.20/#container-v1-core>Container API</a></p></li><li><p><a href=/docs/reference/generated/kubernetes-api/v1.20/#resourcerequirements-v1-core>ResourceRequirements</a></p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-311a77266b790c3614dc2363a3a70aac>4 - Menetapkan Pod ke Node</h1><p>Kamu dapat memaksa sebuah <a href=/id/docs/concepts/workloads/pods/pod/>pod</a> untuk hanya dapat berjalan pada <a href=/id/docs/concepts/architecture/nodes/>node</a> tertentu atau mengajukannya agar berjalan pada node tertentu. Ada beberapa cara untuk melakukan hal tersebut. Semua cara yang direkomendasikan adalah dengan menggunakan <a href=/id/docs/concepts/overview/working-with-objects/labels/><em>selector</em> label</a> untuk menetapkan pilihan yang kamu inginkan. Pada umumnya, pembatasan ini tidak dibutuhkan, sebagaimana <em>scheduler</em> akan melakukan penempatan yang proporsional dengan otomatis (seperti contohnya menyebar pod di node-node, tidak menempatkan pod pada node dengan sumber daya yang tidak memadai, dst.) tetapi ada keadaan-keadaan tertentu yang membuat kamu memiliki kendali lebih terhadap node yang menjadi tempat pod dijalankan, contohnya untuk memastikan pod dijalankan pada mesin yang telah terpasang SSD, atau untuk menempatkan pod-pod dari dua servis yang berbeda yang sering berkomunikasi bersamaan ke dalam zona ketersediaan yang sama.</p><p>Kamu dapat menemukan semua berkas untuk contoh-contoh berikut pada <a href=https://github.com/kubernetes/website/tree/release-1.20/content/en/docs/concepts/configuration/>dokumentasi yang kami sediakan di sini</a></p><h2 id=nodeselector>nodeSelector</h2><p>Penggunaan <code>nodeSelector</code> adalah cara pembatasan pemilihan node paling sederhana yang direkomendasikan. <code>nodeSelector</code> adalah sebuah <em>field</em> pada PodSpec. <code>nodeSelector</code> memerinci sebuah map berisi pasangan kunci-nilai. Agar pod dapat dijalankan pada sebuah node yang memenuhi syarat, node tersebut harus memiliki masing-masing dari pasangan kunci-nilai yang dinyatakan sebagai label (namun node juga dapat memiliki label tambahan diluar itu). Penggunaan paling umum adalah satu pasang kunci-nilai.</p><p>Mari kita telusuri contoh dari penggunaan <code>nodeSelector</code>.</p><h3 id=langkah-nol-prasyarat>Langkah Nol: Prasyarat</h3><p>Contoh ini mengasumsikan bahwa kamu memiliki pemahaman dasar tentang pod Kubernetes dan kamu telah <a href=https://github.com/kubernetes/kubernetes#documentation>membuat klaster Kubernetes</a>.</p><h3 id=langkah-satu-menyematkan-label-pada-node>Langkah Satu: Menyematkan label pada node</h3><p>Jalankan <code>kubectl get nodes</code> untuk mendapatkan nama dari node-node yang ada dalam klaster kamu. Temukan node yang akan kamu tambahkan label, kemudian jalankan perintah <code>kubectl label nodes &lt;node-name> &lt;label-key>=&lt;label-value></code> untuk menambahkan label pada node yang telah kamu pilih. Sebagai contoh, jika nama node yang saya pilih adalah 'kubernetes-foo-node-1.c.a-robinson.internal' dan label yang ingin saya tambahkan adalah 'disktype=ssd', maka saya dapat menjalankan <code>kubectl label nodes kubernetes-foo-node-1.c.a-robinson.internal disktype=ssd</code>.</p><p>Jika terjadi kegagalan dengan kesalahan perintah yang tidak <em>valid</em> ("<em>invalid command</em>"), kemungkinan besar kamu menggunakan kubectl dengan versi lebih lama yang tidak memiliki perintah <code>label</code>. Dalam hal ini, lihat [versi sebelumnya] (<a href=https://github.com/kubernetes/kubernetes/blob/a053dbc313572ed60d89dae9821ecab8bfd676dc/examples/node-selection/README.md>https://github.com/kubernetes/kubernetes/blob/a053dbc313572ed60d89dae9821ecab8bfd676dc/examples/node-selection/README.md</a>) dari petunjuk ini untuk instruksi tentang cara menetapkan label pada node.</p><p>Kamu dapat memastikan perintah telah berhasil dengan menjalankan ulang perintah <code>kubectl get nodes --show-labels</code> and memeriksa bahwa node yang dipilih sekarang sudah memiliki label yang ditambahkan. Kamu juga dapat menggunakan <code>kubectl describe node "nodename"</code> untuk melihat daftar lengkap label yang dimiliki sebuah node.</p><h3 id=langkah-dua-menambahkan-sebuah-nodeselector-ke-konfigurasi-pod-kamu>Langkah Dua: Menambahkan sebuah nodeSelector ke konfigurasi pod kamu</h3><p>Ambil berkas konfigurasi pod manapun yang akan kamu jalankan, dan tambahkan sebuah bagian <code>nodeSelector</code> pada berkas tersebut, seperti berikut. Sebagai contoh, jika berikut ini adalah konfigurasi pod saya:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></code></pre></div><p>Kemudian tambahkan sebuah <code>nodeSelector</code> seperti berikut:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/master/content/id/examples/pods/pod-nginx.yaml download=pods/pod-nginx.yaml><code>pods/pod-nginx.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-nginx-yaml')" title="Copy pods/pod-nginx.yaml to clipboard"></img></div><div class=includecode id=pods-pod-nginx-yaml><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>disktype</span>:<span style=color:#bbb> </span>ssd<span style=color:#bbb>
</span></code></pre></div></div></div><p>Ketika kamu menjalankan perintah <code>kubectl apply -f https://k8s.io/examples/pods/pod-nginx.yaml</code>, pod tersebut akan dijadwalkan pada node yang memiliki label yang dirinci. Kamu dapat memastikan penambahan nodeSelector berhasil dengan menjalankan <code>kubectl get pods -o wide</code> dan melihat "NODE" tempat Pod ditugaskan.</p><h2 id=selingan-label-node-built-in>Selingan: label node <em>built-in</em></h2><p>Sebagai tambahan dari label yang kamu <a href=#step-one-attach-label-to-the-node>sematkan</a>, node sudah terisi dengan satu set label standar. Pada Kubernetes v1.4 label tersebut adalah</p><ul><li><code>kubernetes.io/hostname</code></li><li><code>failure-domain.beta.kubernetes.io/zone</code></li><li><code>failure-domain.beta.kubernetes.io/region</code></li><li><code>beta.kubernetes.io/instance-type</code></li><li><code>kubernetes.io/os</code></li><li><code>kubernetes.io/arch</code></li></ul><blockquote class="note callout"><div><strong>Catatan:</strong> Nilai dari label-label tersebut spesifik untuk setiap penyedia layanan <em>cloud</em> dan tidak dijamin reliabilitasnya.
Contohnya, nilai dari <code>kubernetes.io/hostname</code> bisa saja sama dengan nama node pada beberapa lingkungan dan berbeda pada lingkungan lain.</div></blockquote><h2 id=isolasi-pembatasan-node>Isolasi/pembatasan Node</h2><p>Menambahkan label pada objek node memungkinkan penargetan pod pada node atau grup node yang spesifik. Penambahan label ini dapat digunakan untuk memastikan pod yang spesifik hanya berjalan pada node dengan isolasi, keamanan, atau pengaturan tertentu. Saat menggunakan label untuk tujuan tersebut, memilih kunci label yang tidak bisa dimodifikasi oleh proses kubelet pada node sangat direkomendasikan. Hal ini mencegah node yang telah diubah untuk menggunakan kredensial kubelet-nya untuk mengatur label-label pada objek nodenya sediri, dan mempengaruhi scheduler untuk menjadwalkan <em>workload</em> ke node yang telah diubah tersebut.</p><p><em>Plugin</em> penerimaan <code>NodeRestriction</code> mencegah kubeletes untuk megatur atau mengubah label dengan awalan <code>node-restriction.kubernetes.io/</code>.
Untuk memanfaatkan awalan label untuk isolasi node:</p><ol><li><p>Pastikan kamu menggunakan <a href=/docs/reference/access-authn-authz/node/><em>authorizer</em> node</a> dan mengaktifkan [<em>plugin admission NodeRestriction</em>(/docs/reference/access-authn-authz/admission-controllers/#noderestriction).</p></li><li><p>Tambah label dengan awalan <code>node-restriction.kubernetes.io/</code> ke objek node kamu, dan gunakan label tersebut pada node <em>selector</em> kamu. Contohnya, <code>example.com.node-restriction.kubernetes.io/fips=true</code> or <code>example.com.node-restriction.kubernetes.io/pci-dss=true</code>.</p></li></ol><h2 id=afinitas-dan-anti-afinitas>Afinitas dan anti-afinitas</h2><p><code>_Field_ nodeSelector</code> menyediakan cara yang sangat sederhana untuk membatasi pod ke node dengan label-label tertentu. Fitur afinitas/anti-afinitas saat ini bersifat beta dan memperluas tipe pembatasan yang dapat kamu nyatakan. Peningkatan kunci dari fitur ini adalah</p><ol><li>Bahasa yang lebih ekspresif (tidak hanya "AND of exact match")</li><li>Kamu dapat memberikan indikasi bahwa aturan yang dinyatakan bersifat rendah/preferensi dibanding dengan persyaratan mutlak sehingga jika scheduler tidak dapat memenuhinya, pod tetap akan dijadwalkan</li><li>Kamu dapat membatasi dengan label pada pod-pod lain yang berjalan pada node (atau domain <em>topological</em> lain), daripada dengan label pada node itu sendiri, yang memungkinkan pengaturan tentang pod yang dapat dan tidak dapat dilokasikan bersama.</li></ol><p>Fitur afinitas terdiri dari dua tipe afinitas yaitu "node afinitas" dan "inter-pod afinitas/anti-afinitas"
Node afinitas adalah seperti <code>nodeSelector</code> yang telah ada (tetapi dengam dua kelebihan pertama yang terdaftar di atas), sementara inter-pod afinitas/anti-afinitas membatasi pada label pod daripada label node, seperti yang dijelaskan pada item ketiga pada daftar di atas, sebagai tambahan dari item pertama dan kedua.</p><p><em>Field</em> <code>nodeSelector</code> tetap berjalan seperti biasa, namun pada akhirnya akan ditinggalkan karena afinitas node dapat menyatakan semua yang <code>nodeSelector</code> dapat nyatakan.</p><h3 id=afinitas-node-fitur-beta>Afinitas node (fitur beta)</h3><p>Afinitas node diperkenalkan sebagai fitur alfa pada Kubernetes 1.2.
Afinitas node secara konseptual mirip dengan <code>nodeSelector</code> yang memungkinkan kamu untuk membatasi node yang memenuhi syarat untuk penjadwalan pod, berdasarkan label pada node.</p><p>Saat ini ada dia tipe afinitas node, yaitu <code>requiredDuringSchedulingIgnoredDuringExecution</code> dan
<code>preferredDuringSchedulingIgnoredDuringExecution</code>. Kamu dapat menganggap dua tipe ini sebagai "kuat" dan "lemah" secara berurutan, dalam arti tipe pertama menyatakan peraturan yang <em>harus</em> dipenuhi agar pod dapat dijadwalkan pada node (sama seperti <code>nodeSelector</code> tetapi menggunakan sintaksis yang lebih ekpresif), sementara tipe kedua menyatakan <em>preferensi</em> yang akan dicoba dilaksanakan tetapi tidak akan dijamin oleh scheduler. Bagian "IgnoredDuringExecution" dari nama tipe ini berarti, mirip dengan cara kerja <code>nodeSelector</code>, jika label pada node berubah pada <em>runtime</em> yang menyebabkan aturan afinitas pada pod tidak lagi terpenuhi, pod akan tetap berjalan pada node. Pada masa yang akan datang kami berencana menawarkan <code>requiredDuringSchedulingRequiredDuringExecution</code> yang akan berjalan seperti <code>requiredDuringSchedulingIgnoredDuringExecution</code> hanya saja tipe ini akan mengeluarkan pod dari node yang gagal untuk memenuhi persyaratan afinitas node pod.</p><p>Dengan denikian, contoh dari <code>requiredDuringSchedulingIgnoredDuringExecution</code> adalah "hanya jalankan pod pada node dengan Intel CPU" dan contoh dari <code>preferredDuringSchedulingIgnoredDuringExecution</code> adalah "coba jalankan set pod ini dalam zona ketersediaan XYZ, tetapi jika tidak memungkinkan, maka biarkan beberapa pod berjalan di tempat lain".</p><p>Afinitas node dinyatakan sebagai <em>field</em> <code>nodeAffinity</code> dari <em>field</em> <code>affinity</code> pada PodSpec.</p><p>Berikut ini contoh dari pod yang menggunakan afinitas node:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/master/content/id/examples/pods/pod-with-node-affinity.yaml download=pods/pod-with-node-affinity.yaml><code>pods/pod-with-node-affinity.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-with-node-affinity-yaml')" title="Copy pods/pod-with-node-affinity.yaml to clipboard"></img></div><div class=includecode id=pods-pod-with-node-affinity-yaml><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>with-node-affinity<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>kubernetes.io/e2e-az-name<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- e2e-az1<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- e2e-az2<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>preferredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>preference</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>another-node-label-key<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- another-node-label-value<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>with-node-affinity<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/pause:2.0</code></pre></div></div></div><p>Aturan afinitas node tersebut menyatakan pod hanya bisa ditugaskan pada node dengan label yang memiliki kunci <code>kubernetes.io/e2e-az-name</code> dan bernilai <code>e2e-az1</code> atau <code>e2e-az2</code>. Selain itu, dari semua node yang memenuhi kriteria tersebut, mode dengan label dengan kunci <code>another-node-label-key</code> and bernilai <code>another-node-label-value</code> harus lebih diutamakan.</p><p>Kamu dapat meilhat operator <code>In</code> digunakan dalam contoh berikut. Sitaksis afinitas node yang baru mendukung operator-operator berikut: <code>In</code>, <code>NotIn</code>, <code>Exists</code>, <code>DoesNotExist</code>, <code>Gt</code>, <code>Lt</code>. Kamu dapat menggunakan <code>NotIn</code> dan <code>DoesNotExist</code> untuk mewujudkan perilaku node anti-afinitas, atau menggunakan <a href=/id/docs/concepts/configuration/taint-and-toleration/>node taints</a> untuk menolak pod dari node tertentu.</p><p>Jika kamu menyatakan <code>nodeSelector</code> dan <code>nodeAffinity</code>. <em>keduanya</em> harus dipenuhi agar pod dapat dijadwalkan pada node kandidat.</p><p>Jika kamu menyatakan beberapa <code>nodeSelectorTerms</code> yang terkait dengan tipe <code>nodeAffinity</code>, maka pod akan dijadwalkan pada node <strong>jika salah satu</strong> dari <code>nodeSelectorTerms</code> dapat terpenuhi.</p><p>Jika kamu menyatakan beberapa <code>matchExpressions</code> yang terkait dengan <code>nodeSelectorTerms</code>, makan pod dapat dijadwalkan pada node <strong>hanya jika semua</strong> <code>matchExpressions</code> dapat terpenuhi.</p><p>Jika kamu menghapus atau mengubah label pada node tempat pod dijadwalkan, pod tidak akan dihapus. Dengan kata lain, pemilihan afinitas hanya bekerja pada saat waktu penjadwalan pod.</p><p><em>Field</em> <code>weight</code> pada <code>preferredDuringSchedulingIgnoredDuringExecution</code> berada pada rentang nilai 1-100. Untuk setiap node yang memenuhi semua persyaratan penjadwalan (permintaan sumber daya, pernyataan afinitas RequiredDuringScheduling, dll.), <em>scheduler</em> akan menghitung nilai jumlah dengan melakukan iterasi pada elemen-elemen dari <em>field</em> ini dan menambah "bobot" pada jumlah jika node cocok dengan MatchExpressions yang sesuai. Nilai ini kemudian digabungkan dengan nilai dari fungsi prioritas lain untuk node. Node dengan nilai tertinggi adalah node lebih diutamakan.</p><p>Untuk informasi lebih lanjut tentang afinitas node kamu dapat melihat <a href=https://git.k8s.io/community/contributors/design-proposals/scheduling/nodeaffinity.md>design doc</a>.</p><h3 id=afinitas-and-anti-afinitas-antar-pod-fitur-beta>Afinitas and anti-afinitas antar pod (fitur beta)</h3><p>Afinitas and anti-afinitas antar pod diperkenalkan pada Kubernetes 1.4. Afinitas and anti-afinitas antar pod memungkinkan kamu untuk membatasi node yang memenuhi syarat untuk penjadwalan pod <em>berdasarkan label-label pada pod yang sudah berjalan pada node</em> daripada berdasarkan label-label pada node. Aturan tersebut berbentuk "pod ini harus (atau, dalam kasus
anti-afinitas, tidak boleh) berjalan dalam X jika X itu sudah menjalankan satu atau lebih pod yang memenuhi aturan Y". Y dinyatakan sebagai sebuah LabelSelector dengan daftar namespace terkait; tidak seperti node, karena pod are namespaced (maka dari itu label-label pada pod diberi namespace secara implisit), sebuah label selector di atas label-label pod harus menentukan namespace yang akan diterapkan selector. Secara konsep X adalah domain topologi seperti node, rack, zona penyedia cloud, daerah penyedia cloud, dll. Kamu dapat menyatakannya menggunakan <code>topologyKey</code> yang merupakan kunci untuk label node yang digunakan sistem untuk menunjukkan domain topologi tersebut, contohnya lihat kunci label yang terdaftar di atas pada bagian <a href=#interlude-built-in-node-labels>Selingan: label node built-in</a>.</p><blockquote class="note callout"><div><strong>Catatan:</strong> Afinitas and anti-afinitas antar pod membutuhkan jumlah pemrosesan yang substansial yang dapat memperlambat penjadwalan pada klaster berukuran besar secara signifikan. Kami tidak merekomendasikan penggunaan mereka pada klaster yang berukuran lebih besar dari beberapa ratus node.</div></blockquote><blockquote class="note callout"><div><strong>Catatan:</strong> Anti-afinitas pod mengharuskan node untuk diberi label secara konsisten, misalnya setiap node dalam klaster harus memiliki label sesuai yang cocok dengan <code>topologyKey</code>. Jika sebagian atau semua node tidak memiliki label <code>topologyKey</code> yang dinyatakan, hal ini dapat menyebabkan perilaku yang tidak diinginkan.</div></blockquote><p>Seperti afinitas node, ada dua tipe afinitas dan anti-afinitas pod, yaitu <code>requiredDuringSchedulingIgnoredDuringExecution</code> dan
<code>preferredDuringSchedulingIgnoredDuringExecution</code> yang menunjukan persyaratan "kuat" vs. "lemah". Lihat deskripsi pada bagian afinitas node sebelumnya.
Sebuah contoh dari afinitas <code>requiredDuringSchedulingIgnoredDuringExecution</code> adalah "Tempatkan bersamaan pod layanan A dan layanan B di zona yang sama, karena mereka banyak berkomunikasi satu sama lain"
dan contoh <code>preferDuringSchedulingIgnoredDuringExecution</code> anti-afinitas akan menjadi "sebarkan pod dari layanan ini di seluruh zona" (persyaratan kuat tidak masuk akal, karena kamu mungkin memiliki lebih banyak pod daripada zona).</p><p>Afinitas antar pod dinyatakan sebagai <em>field</em> <code>podAffinity</code> dari <em>field</em> <code>affinity</code> pada PodSpec dan anti-afinitas antar pod dinyatakan sebagai <em>field</em> <code>podAntiAffinity</code> dari <em>field</em> <code>affinity</code> pada PodSpec.</p><h4 id=contoh-pod-yang-menggunakan-pod-affinity>Contoh pod yang menggunakan pod affinity:</h4><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/master/content/id/examples/pods/pod-with-pod-affinity.yaml download=pods/pod-with-pod-affinity.yaml><code>pods/pod-with-pod-affinity.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-with-pod-affinity-yaml')" title="Copy pods/pod-with-pod-affinity.yaml to clipboard"></img></div><div class=includecode id=pods-pod-with-pod-affinity-yaml><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>with-pod-affinity<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>podAffinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>security<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- S1<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>failure-domain.beta.kubernetes.io/zone<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>podAntiAffinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>preferredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>podAffinityTerm</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>security<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span>- S2<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>failure-domain.beta.kubernetes.io/zone<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>with-pod-affinity<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/pause:2.0<span style=color:#bbb>
</span></code></pre></div></div></div><p>Afinitas pada pod tersebut menetapkan sebuah aturan afinitas pod dan aturan anti-afinitas pod. Pada contoh ini, <code>podAffinity</code> adalah <code>requiredDuringSchedulingIgnoredDuringExecution</code>
sementara <code>podAntiAffinity</code> adalah <code>preferredDuringSchedulingIgnoredDuringExecution</code>. Aturan afinitas pod menyatakan bahwa pod dapat dijadwalkan pada node hanya jika node tersebut berada pada zona yang sama dengan minimal satu pod yang sudah berjalan yang memiliki label dengan kunci "security" dan bernilai "S1". (Lebih detail, pod dapat berjalan pada node N jika node N memiliki label dengan kunci <code>failure-domain.beta.kubernetes.io/zone</code>dan nilai V sehingga ada minimal satu node dalam klaster dengan kunci <code>failure-domain.beta.kubernetes.io/zone</code> dan bernilai V yang menjalankan pod yang memiliki label dengan kunci "security" dan bernilai "S1".) Aturan anti-afinitas pod menyatakan bahwa pod memilih untuk tidak dijadwalkan pada sebuah node jika node tersebut sudah menjalankan pod yang memiliki label dengan kunci "security" dan bernilai "S2". (Jika <code>topologyKey</code> adalah <code>failure-domain.beta.kubernetes.io/zone</code> maka dapat diartikan bahwa pod tidak dapat dijadwalkan pada node jika node berada pada zona yang sama dengan pod yang memiliki label dengan kunci "security" dan bernilai "S2".) Lihat <a href=https://git.k8s.io/community/contributors/design-proposals/scheduling/podaffinity.md>design doc</a> untuk lebih banyak contoh afinitas dan anti-afinitas pod, baik <code>requiredDuringSchedulingIgnoredDuringExecution</code>
maupun <code>preferredDuringSchedulingIgnoredDuringExecution</code>.</p><p>Operator yang sah untuk afinitas dan anti-afinitas pod adalah <code>In</code>, <code>NotIn</code>, <code>Exists</code>, <code>DoesNotExist</code>.</p><p>Pada dasarnya, <code>topologyKey</code> dapat berupa label-kunci apapun yang sah. Namun, untuk alasan performa dan keamanan, ada beberapa batasan untuk <code>topologyKey</code>:</p><ol><li>Untuk afinitas and anti-afinitas pod <code>requiredDuringSchedulingIgnoredDuringExecution</code>, <code>topologyKey</code> tidak boleh kosong.</li><li>Untuk anti-afinitas pod <code>requiredDuringSchedulingIgnoredDuringExecution</code>, pengontrol penerimaan <code>LimitPodHardAntiAffinityTopology</code> diperkenalkan untuk membatasi <code>topologyKey</code> pada <code>kubernetes.io/hostname</code>. Jika kamu menginginkan untuk membuatnya tersedia untuk topologi khusus, kamu dapat memodifikasi pengontrol penerimaan, atau cukup menonaktifkannya saja.</li><li>Untuk anti-afinitas pod <code>preferredDuringSchedulingIgnoredDuringExecution</code>, <code>topologyKey</code> yang kosong diinterpretasikan sebagai "semua topologi" ("semua topologi" sekarang dibatasi pada kombinasi dari <code>kubernetes.io/hostname</code>, <code>failure-domain.beta.kubernetes.io/zone</code> dan <code>failure-domain.beta.kubernetes.io/region</code>).</li><li>Kecuali untuk kasus-kasus di atas, <code>topologyKey</code> dapat berupa label-kunci apapun yang sah.</li></ol><p>Sebagai tambahan untuk <code>labelSelector</code> and <code>topologyKey</code>, kamu secara opsional dapat menyatakan daftar <code>namespaces</code> dari namespaces yang akan digunakan untuk mencocokan <code>labelSelector</code> (daftar ini berjalan pada level definisi yang sama dengan <code>labelSelector</code> dan <code>topologyKey</code>)</p><p>Jika dihilangkan atau kosong, daftar ini sesuai standar akan merujuk pada <em>namespace</em> dari pod tempat definisi afinitas/anti-afinitas dinyatakan.</p><p>Semua <code>matchExpressions</code> berkaitan dengan afinitas and anti-afinitas <code>requiredDuringSchedulingIgnoredDuringExecution</code> harus dipenuhi agar pod dapat dijadwalkan pada node.</p><h4 id=penggunaan-yang-lebih-praktikal>Penggunaan yang lebih praktikal</h4><p>Afinitas and anti-afinitas antar pod dapat menjadi lebih berguna saat digunakan bersamaan dengan koleksi dengan level yang lebih tinggi seperti ReplicaSets, StatefulSets, Deployments, dll. Pengguna dapat dengan mudah mengkonfigurasi bahwa satu set workload harus
ditempatkan bersama dalam topologi yang didefinisikan sama, misalnya, node yang sama.</p><h5 id=selalu-ditempatkan-bersamaan-pada-node-yang-sama>Selalu ditempatkan bersamaan pada node yang sama</h5><p>Dalam klaster berisi 3 node, sebuah aplikasi web memiliki in-memory cache seperti redis. Kita menginginkan agar <em>web-server</em> dari aplikasi ini sebisa mungkin ditempatkan bersamaan dengan cache.</p><p>Berikut ini kutipan yaml dari deployment redis sederhana dengan 3 replika dan label selector <code>app=store</code>, Deployment memiliki konfigurasi <code>PodAntiAffinity</code> untuk memastikan <em>scheduler</em> tidak menempatkan replika bersamaan pada satu node.</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-cache<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>store<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>store<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>podAntiAffinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                </span>- store<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-server<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis:3.2-alpine<span style=color:#bbb>
</span></code></pre></div><p>Kutipan yaml dari deployment webserver berikut ini memiliki konfigurasi <code>podAntiAffinity</code> dan <code>podAffinity</code>. Konfigurasi ini menginformasikan scheduler bahwa semua replika harus ditempatkan bersamaan dengan pod yang memiliki label selector <code>app=store</code>. Konfigurasi ini juga memastikan bahwa setiap replika webserver tidak ditempatkan bersamaan pada satu node.</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web-server<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>web-store<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>web-store<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>podAntiAffinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                </span>- web-store<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>podAffinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                </span>- store<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web-app<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.12-alpine<span style=color:#bbb>
</span></code></pre></div><p>Jika kita membuat kedua dployment di atas, klaster berisi 3 node kita seharusnya menjadi seperti berikut.</p><table><thead><tr><th style=text-align:center>node-1</th><th style=text-align:center>node-2</th><th style=text-align:center>node-3</th></tr></thead><tbody><tr><td style=text-align:center><em>webserver-1</em></td><td style=text-align:center><em>webserver-2</em></td><td style=text-align:center><em>webserver-3</em></td></tr><tr><td style=text-align:center><em>cache-1</em></td><td style=text-align:center><em>cache-2</em></td><td style=text-align:center><em>cache-3</em></td></tr></tbody></table><p>st
Seperti yang kamu lihat, semua 3 replika dari <code>web-server</code> secara otomatis ditempatkan bersama dengan cache seperti yang diharapkan.</p><pre><code>$ kubectl get pods -o wide
NAME                           READY     STATUS    RESTARTS   AGE       IP           NODE
redis-cache-1450370735-6dzlj   1/1       Running   0          8m        10.192.4.2   kube-node-3
redis-cache-1450370735-j2j96   1/1       Running   0          8m        10.192.2.2   kube-node-1
redis-cache-1450370735-z73mh   1/1       Running   0          8m        10.192.3.1   kube-node-2
web-server-1287567482-5d4dz    1/1       Running   0          7m        10.192.2.3   kube-node-1
web-server-1287567482-6f7v5    1/1       Running   0          7m        10.192.4.3   kube-node-3
web-server-1287567482-s330j    1/1       Running   0          7m        10.192.3.2   kube-node-2
</code></pre><h5 id=tidak-akan-pernah-ditempatkan-bersamaan-dalam-node-yang-sama>Tidak akan pernah ditempatkan bersamaan dalam node yang sama</h5><p>Contoh di atas menggunakan aturan <code>PodAntiAffinity</code> dengan<code> topologyKey: "kubernetes.io/hostname"</code> untuk melakukan deploy klaster redis sehingga tidak ada dua instance terletak pada hos yang sama.
Lihat <a href=/docs/tutorials/stateful-application/zookeeper/#tolerating-node-failure>tutorial ZooKeeper</a> untuk contoh dari konfigurasi StatefulSet dengan anti-afinitas untuk ketersediaan tinggi, menggunakan teknik yang sama.</p><p>Untuk informasi lebih lanjut tentang afinitas/anti-afinitas antar pod, lihat <a href=https://git.k8s.io/community/contributors/design-proposals/scheduling/podaffinity.md>design doc</a>.</p><p>Kamu juga dapat mengecek <a href=/id/docs/concepts/configuration/taint-and-toleration/>Taints</a>, yang memungkinkan sebuah <em>node</em> untuk <em>menolak</em> sekumpulan pod.</p><h2 id=nodename>nodeName</h2><p><code>nodeName</code> adalah bentuk paling sederhana dari pembatasan pemilihan node, tetapi karena
keterbatasannya biasanya tidak digunakan. <code>nodeName</code> adalah sebuah <em>field</em> dari
PodSpec. Jika tidak kosong, scheduler mengabaikan pod dan
kubelet yang berjalan pada node tersebut yang mencoba menjalankan pod. Maka, jika
<code>nodeName</code> disediakan dalam PodSpec, ia memiliki hak yang lebih tinggi dibanding metode-metode di atas untuk pemilihan node.</p><p>Beberapa keterbatasan dari penggunaan <code>nodeName</code> untuk memilih node adalah:</p><ul><li>Jika node yang disebut tidak ada, maka pod tidak akan dijalankan, dan dalam beberapa kasus akan
dihapus secara otomatis.</li><li>Jika node yang disebut tidak memiliki resource yang cukup untuk mengakomodasi pod, pod akan gagal
dan alasannya akan mengindikasikan sebab kegagalan, misalnya OutOfmemory atau OutOfcpu.</li><li>Nama node pada lingkungan cloud tidak selalu dapat diprediksi atau stabil.</li></ul><p>Berikut ini contoh konfigurasi pod menggunakan <em>field</em> <code>nodeName</code>:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeName</span>:<span style=color:#bbb> </span>kube-01<span style=color:#bbb>
</span></code></pre></div><p>Pod di atas akan berjalan pada node kube-01.</p><h2 id=selanjutnya>Selanjutnya</h2></div><div class=td-content style=page-break-before:always><h1 id=pg-b5ed5deb74feef558a1d2c17569d2e3c>5 - Taint dan Toleration</h1><p>Afinitas Node, seperti yang dideskripsikan <a href=/id/docs/concepts/configuration/assign-pod-node/#node-affinity-beta-feature>di sini</a>,
adalah salah satu properti dari Pod yang menyebabkan pod tersebut memiliki preferensi
untuk ditempatkan di sekelompok Node tertentu (preferensi ini dapat berupa <em>soft constraints</em> atau
<em>hard constraints</em> yang harus dipenuhi). <em>Taint</em> merupakan kebalikan dari afinitas --
properti ini akan menyebabkan Pod memiliki preferensi untuk tidak ditempatkan pada sekelompok Node tertentu.</p><p><em>Taint</em> dan <em>toleration</em> bekerja sama untuk memastikan Pod dijadwalkan pada Node
yang sesuai. Satu atau lebih <em>taint</em> akan diterapkan pada suatu node; hal ini akan menyebabkan
node tidak akan menerima pod yang tidak mengikuti <em>taint</em> yang sudah diterapkan.</p><h2 id=konsep>Konsep</h2><p>Kamu dapat menambahkan <em>taint</em> pada sebuah <em>node</em> dengan menggunakan perintah <a href=/docs/reference/generated/kubectl/kubectl-commands#taint>kubectl taint</a>.
Misalnya,</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl taint nodes node1 <span style=color:#b8860b>key</span><span style=color:#666>=</span>value:NoSchedule
</code></pre></div><p>akan menerapkan <em>taint</em> pada <em>node</em> <code>node1</code>. <em>Taint</em> tersebut memiliki <em>key</em> <code>key</code>, <em>value</em> <code>value</code>,
dan <em>effect</em> <em>taint</em> <code>NoSchedule</code>. Hal ini artinya pod yang ada tidak akan dapat dijadwalkan pada <code>node1</code>
kecuali memiliki <em>taint</em> yang sesuai.</p><p>Untuk menghilangkan <em>taint</em> yang ditambahkan dengan perintah di atas, kamu dapat menggunakan
perintah di bawah ini:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl taint nodes node1 key:NoSchedule-
</code></pre></div><p>Kamu dapat memberikan spesifikasi <em>toleration</em> untuk <em>pod</em> pada bagian PodSpec.
Kedua <em>toleration</em> yang diterapkan di bawa ini "sesuai" dengan <em>taint</em> yang
<em>taint</em> yang dibuat dengan perintah <code>kubectl taint</code> di atas, sehingga sebuah <em>pod</em>
dengan <em>toleration</em> yang sudah didefinisikan akan mampu di-<em>schedule</em> ke node <code>node</code>:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Equal&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;value&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoSchedule&#34;</span><span style=color:#bbb>
</span></code></pre></div><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Exists&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoSchedule&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>Sebuah <em>toleration</em> "sesuai" dengan sebuah <em>taint</em> jika <em>key</em> dan efek yang
ditimbulkan sama:</p><ul><li><code>operator</code> dianggap <code>Exists</code> (pada kasus dimana tidak ada <code>value</code> yang diberikan), atau</li><li><code>operator</code> dianggap <code>Equal</code> dan <code>value</code> yang ada sama</li></ul><p><code>Operator</code> bernilai <code>Equal</code> secara <em>default</em> jika tidak diberikan spesifikasi khusus.</p><blockquote class="note callout"><div><strong>Catatan:</strong><p>Terdapat dua kasus khusus:</p><ul><li>Sebuah <code>key</code> dengan operator <code>Exists</code> akan sesuai dengan semua <em>key</em>, <em>value</em>, dan <em>effect</em> yang ada.
Dengan kata lain, <em>tolaration</em> ini akan menerima semua hal yang diberikan.</li></ul><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Exists&#34;</span><span style=color:#bbb>
</span></code></pre></div><ul><li>Sebuah <code>effect</code> yang kosong akan dianggap sesuai dengan semua <em>effect</em> dengan <em>key</em> <code>key</code>.</li></ul><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Exists&#34;</span><span style=color:#bbb>
</span></code></pre></div></div></blockquote><p>Contoh yang diberikan di atas menggunakan <code>effect</code> untuk <code>NoSchedule</code>.
Alternatif lain yang dapat digunakan adalah <code>effect</code> untuk <code>PreferNoSchedule</code>.
<code>PreferNoSchedule</code> merupakan "preferensi" yang lebih fleksibel dari <code>NoSchedule</code> --
sistem akan mencoba untuk tidak menempatkan pod yang tidak menoleransi <em>taint</em>
pada <em>node</em>, tapi hal ini bukan merupakan sesuatu yang harus dipenuhi. Jenis ketiga
dari <code>effect</code> adalah <code>NoExecute</code>, akan dijelaskan selanjutnya.</p><p>Kamu dapat menerapkan beberapa <em>taint</em> sekaligus pada <em>node</em> atau
beberapa <em>toleration</em> sekaligus pada sebuah <em>pod</em>. Mekanisme Kubernetes dapat
memproses beberapa <em>taint</em> dan <em>toleration</em> sekaligus sama halnya seperti sebuah
<em>filter</em>: memulai dengan <em>taint</em> yang ada pada <em>node</em>, kemudian mengabaikan
<em>taint</em> yang sesuai pada pod yang memiliki <em>toleration</em> yang sesuai; kemudian
<em>taint</em> yang diterapkan pada pod yang sudah disaring tadi akan menghasilkan suatu
<em>effect</em> pada pod. Secara khusus:</p><ul><li>jika terdapat <em>taint</em> yang tidak tersaring dengan <em>effect</em> <code>NoSchedule</code> maka Kubernetes tidak akan menempatkan
<em>pod</em> pada <em>node</em> tersebut</li><li>jika tidak terdapat <em>taint</em> yang tidak tersaring dengan <em>effect</em> <code>NoSchedule</code>
tapi terdapat setidaknya satu <em>taint</em> yang tidak tersaring dengan
<em>effect</em> <code>PreferNoSchedule</code> maka Kubernetes akan mencoba untuk tidak akan menempatkan
<em>pod</em> pada <em>node</em> tersebut</li><li>jika terdapat <em>taint</em> yang tidak tersaring dengan <em>effect</em> <code>NoExecute</code> maka <em>pod</em> akan
berada dalam kondisi <em>evicted</em> dari <em>node</em> (jika <em>pod</em> tersebut sudah terlanjur ditempatkan pada <em>node</em>
tersebut), dan tidak akan di-<em>schedule</em> lagi pada <em>node</em> tersebut.</li></ul><p>Sebagai contoh, bayangkan kamu memberikan <em>taint</em> pada <em>node</em> sebagai berikut:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl taint nodes node1 <span style=color:#b8860b>key1</span><span style=color:#666>=</span>value1:NoSchedule
kubectl taint nodes node1 <span style=color:#b8860b>key1</span><span style=color:#666>=</span>value1:NoExecute
kubectl taint nodes node1 <span style=color:#b8860b>key2</span><span style=color:#666>=</span>value2:NoSchedule
</code></pre></div><p>Dan <em>pod</em> memiliki dua <em>toleration</em>:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Equal&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;value1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoSchedule&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Equal&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;value1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoExecute&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>Pada kasus ini, <em>pod</em> tidak akan di-<em>schedule</em> pada <em>node</em>, karena tidak ada
<em>toleration</em> yang sesuai dengan <em>taint</em> ketiga. Akan tetapi, <em>pod</em> yang sebelumnya
sudah dijalankan di <em>node</em> dimana <em>taint</em> ditambahkan akan tetap jalan, karena <em>taint</em>
ketiga merupakan <em>taint</em> yang tidak ditoleransi oleh <em>pod</em>.</p><p>Pada umumnya, jika sebuah <em>taint</em> memiliki <em>effect</em> <code>NoExecute</code> ditambahkan pada <em>node</em>,
maka semua pod yang tidak menoleransi <em>taint</em> tersebut akan berada dalam <em>state</em>
<em>evicted</em> secara langsung, dan semua <em>pod</em> yang menoleransi <em>taint</em> tersebut
tidak akan berjalan seperti biasanya (tidak dalam <em>state</em> <em>evicted</em>). Meskipun demikian,
<em>toleration</em> dengan <em>effect</em> <code>NoExecute</code> dapat dispesfikasikan sebagai <em>field</em> opsional
<code>tolerationSeconds</code> yang memberikan perintah berapa lama suatu <em>pod</em> akan berada
pada <em>node</em> apabila sebuah <em>taint</em> ditambahkan. Contohnya:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Equal&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;value1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoExecute&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tolerationSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>3600</span><span style=color:#bbb>
</span></code></pre></div><p>ini berarti apabila sebuah <em>pod</em> sedang dalam berada dalam <em>state</em> <em>running</em>,
kemudian sebuah <em>taint</em> yang sesuai ditambahkan pada <em>node</em>, maka <em>pod</em> tersebut
akan tetap berada di dalam <em>node</em> untuk periode 3600 detik sebelum <em>state</em>-nya
berubah menjadi <em>evicted</em>. Jika <em>taint</em> dihapus sebelum periode tersebut, maka <em>pod</em>
tetap berjalan sebagaimana mestinya.</p><h2 id=contoh-penggunaan>Contoh Penggunaan</h2><p><em>Taint</em> dan <em>toleration</em> adalah mekanisme fleksibel yang digunakan untuk
memaksa <em>pod</em> agar tidak dijadwalkan pada <em>node-node</em> tertentu atau
mengubah <em>state</em> <em>pod</em> menjadi <em>evicted</em>. Berikut adalah beberapa contoh penggunaannya:</p><ul><li><p><strong>Node-Node yang Sifatnya <em>Dedicated</em></strong>: Jika kamu ingin menggunakan
sekumpulan <em>node</em> dengan penggunaan eksklusif dari sekumpulan pengguna,
kamu dapat menambahkan <em>taint</em> pada <em>node-node</em> tersebut (misalnya,
<code>kubectl taint nodes nodename dedicated=groupName:NoSchedule</code>) dan kemudian
menambahkan <em>toleration</em> yang sesuai pada <em>pod-pod</em> yang berada di dalamnya (hal ini
dapat dilakukan dengan mudah dengan cara menulis
<a href=/docs/reference/access-authn-authz/admission-controllers/><em>admission controller</em></a> yang
bersifat khusus). <em>Pod-pod</em> dengan <em>toleration</em> nantinya akan diperbolehkannya untuk menggunakan
<em>node</em> yang sudah di-<em>taint</em> (atau dengan kata lain didedikasikan penggunaannya) maupun
<em>node</em> lain yang ada di dalam klaster. Jika kamu ingin mendedikasikan <em>node</em> khusus
yang hanya digunakan oleh <em>pod-pod</em> tadi serta memastikan <em>pod-pod</em> tadi hanya menggunakan
<em>node</em> yang didedikasikan, maka kamu harus menambahkan sebuah <em>label</em> yang serupa dengan
<em>taint</em> yang diberikan pada sekelompok <em>node</em> (misalnya, <code>dedicated=groupName</code>), dan
<em>admission controller</em> sebaiknya menambahkan afininitas <em>node</em> untuk memastikan <em>pod-pod</em>
tadi hanya dijadwalkan pada <em>node</em> dengan <em>label</em> <code>dedicated=groupName</code>.</p></li><li><p><strong>Node-Node dengan Perangkat Keras Khusus</strong>: Pada suatu klaster dimana
sebagian kecuali <em>node</em> memiliki perangkat keras khusus (misalnya GPU), kita ingin
memastikan hanya <em>pod-pod</em> yang membutuhkan GPU saja yang dijadwalkan di <em>node</em> dengan GPU.
Hal ini dapat dilakukan dengan memberikan <em>taint</em> pada <em>node</em> yang memiliki perangkat keras
khusus (misalnya, <code>kubectl taint nodes nodename special=true:NoSchedule</code> atau
<code>kubectl taint nodes nodename special=true:PreferNoSchedule</code>) serta menambahkan <em>toleration</em>
yang sesuai pada <em>pod</em> yang menggunakan <em>node</em> dengan perangkat keras khusus. Seperti halnya pada
kebutuhan <em>dedicated</em> <em>node</em>, hal ini dapat dilakukan dengan mudah dengan cara menulis
<a href=/docs/reference/access-authn-authz/admission-controllers/><em>admission controller</em></a> yang
bersifat khusus. Misalnya, kita dapat menggunakan <a href=/id/docs/concepts/configuration/manage-compute-resources-container/#extended-resources><em>Extended Resource</em></a>
untuk merepresentasikan perangkat keras khusus, kemudian <em>taint</em> <em>node</em> dengan perangkat keras khusus
dengan nama <em>extended resource</em> dan jalankan <em>admission controller</em>
<a href=/docs/reference/access-authn-authz/admission-controllers/#extendedresourcetoleration>ExtendedResourceToleration</a>.
Setelah itu, karena <em>node</em> yang ada sudah di-<em>taint</em>, maka tidak akan ada <em>pod</em> yang
tidak memiliki <em>toleration</em> yang akan dijadwalkan pada <em>node</em> tersebut_.
Meskipun begitu, ketika kamu membuat suatu _pod_ yang membutuhkan _extended resource_,
maka _admission controller_ dari <code>ExtendedResourceToleration</code> akan mengoreksi
_toleration_ sehingga _pod_ tersebut dapat dijadwalkan pada _node_ dengan perangkat keras khusus.
Dengan demikian, kamu tidak perlu menambahkan _toleration_ secara manual pada pod yang ada.</p></li><li><p><strong><em>Eviction</em> berbasis <em>Taint</em> (fitur beta)</strong>: Konfigurasi <em>eviction</em> per <em>pod</em>
yang terjadi ketika <em>pod</em> mengalami gangguan, hal ini akan dibahas lebih lanjut di bagian
selanjutnya.</p></li></ul><h2 id=eviction-berbasis-taint><em>Eviction</em> berbasis <em>Taint</em></h2><p>Sebelumnya, kita sudah pernah membahas soal <em>effect</em> <em>taint</em> <code>NoExecute</code>,
yang memengaruhi <em>pod</em> yang sudah dijalankan dengan cara sebagai berikut:</p><ul><li><em>pod</em> yang tidak menoleransi <em>taint</em> akan segera diubah <em>state</em>-nya menjadi <em>evicted</em></li><li><em>pod</em> yang menoleransi <em>taint</em> yang tidak menspesifikasikan <code>tolerationSeconds</code> pada
spesifikasi <em>toleration</em> yang ada akan tetap berada di dalam <em>node</em> tanpa adanya batas waktu tertentu</li><li><em>pod</em> yang menoleransi <em>taint</em> yang menspesifikasikan <code>tolerationSeconds</code>
spesifikasi <em>toleration</em> yang ada akan tetap berada di dalam <em>node</em> hingga batas waktu tertentu</li></ul><p>Sebagai tambahan, Kubernetes 1.6 memperkenalkan dukungan alfa untuk merepresentasikan
<em>node</em> yang bermasalah. Dengan kata lain, <em>node controller</em> akan secara otomatis memberikan <em>taint</em>
pada sebuah <em>node</em> apabila <em>node</em> tersebut memenuhi kriteria tertentu. Berikut merupakan <em>taint</em>
yang secara <em>default</em> disediakan:</p><ul><li><code>node.kubernetes.io/not-ready</code>: <em>Node</em> berada dalam <em>state</em> <em>not ready</em>. Hal ini terjadi apabila
<em>value</em> dari <em>NodeCondition</em> <code>Ready</code> adalah "<code>False</code>".</li><li><code>node.kubernetes.io/unreachable</code>: <em>Node</em> berada dalam <em>state</em> <em>unreachable</em> dari <em>node controller</em>
Hal ini terjadi apabila <em>value</em> dari <em>NodeCondition</em> <code>Ready</code> adalah "<code>Unknown</code>".</li><li><code>node.kubernetes.io/out-of-disk</code>: <em>Node</em> kehabisan kapasitas <em>disk</em>.</li><li><code>node.kubernetes.io/memory-pressure</code>: <em>Node</em> berada diambang kapasitas memori.</li><li><code>node.kubernetes.io/disk-pressure</code>: <em>Node</em> berada diambang kapasitas <em>disk</em>.</li><li><code>node.kubernetes.io/network-unavailable</code>: Jaringan pada <em>Node</em> bersifat <em>unavailable</em>.</li><li><code>node.kubernetes.io/unschedulable</code>: <em>Node</em> tidak dapat dijadwalkan.</li><li><code>node.cloudprovider.kubernetes.io/uninitialized</code>: Ketika <em>kubelet</em> dijalankan dengan
penyedia layanan <em>cloud</em> "eksternal", <em>taint</em> ini akan diterapkan pada <em>node</em> untuk menandai
<em>node</em> tersebut tidak digunakan. Setelah kontroler dari <em>cloud-controller-manager</em> melakukan
inisiasi <em>node</em> tersebut, maka <em>kubelet</em> akan menghapus <em>taint</em> yang ada.</li></ul><p>Pada versi 1.13, fitur <code>TaintBasedEvictions</code> diubah menjadi beta dan diaktifkan secara <em>default</em>,
dengan demikian <em>taint-taint</em> tersebut secara otomatis ditambahkan oleh <em>NodeController</em> (atau <em>kubelet</em>)
dan logika normal untuk melakukan <em>eviction</em> pada <em>pod</em> dari suatu <em>node</em> tertentu berdasarkan <em>value</em>
dari <em>Ready</em> yang ada pada <em>NodeCondition</em> dinonaktifkan.</p><blockquote class="note callout"><div><strong>Catatan:</strong> Untuk menjaga perilaku <a href=/id/docs/concepts/architecture/nodes/><em>rate limiting</em></a> yang
ada pada <em>eviction</em> <em>pod</em> apabila <em>node</em> mengalami masalah, sistem sebenarnya menambahkan
<em>taint</em> dalam bentuk <em>rate limiter</em>. Hal ini mencegah <em>eviction</em> besar-besaran pada <em>pod</em>
pada skenario dimana master menjadi terpisah dari <em>node</em> lainnya.</div></blockquote><p>Fitur beta ini, bersamaan dengan <code>tolerationSeconds</code>, mengizinkan sebuah <em>pod</em>
untuk menspesifikasikan berapa lama <em>pod</em> harus tetap sesuai dengan sebuah <em>node</em>
apabila <em>node</em> tersebut bermasalah.</p><p>Misalnya, sebuah aplikasi dengan banyak <em>state</em> lokal akan lebih baik untuk tetap
berada di suatu <em>node</em> pada saat terjadi partisi jaringan, dengan harapan partisi jaringan
tersebut dapat diselesaikan dan mekanisme <em>eviction</em> <em>pod</em> tidak akan dilakukan.
<em>Toleration</em> yang ditambahkan akan berbentuk sebagai berikut:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;node.kubernetes.io/unreachable&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Exists&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoExecute&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tolerationSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>6000</span><span style=color:#bbb>
</span></code></pre></div><p>Perhatikan bahwa Kubernetes secara otomatis menambahkan <em>toleration</em> untuk
<code>node.kubernetes.io/not-ready</code> dengan <code>tolerationSeconds=300</code>
kecuali konfigurasi lain disediakan oleh pengguna.
Kubernetes juga secara otomatis menambahkan <em>toleration</em> untuk
<code>node.kubernetes.io/unreachable</code> dengan <code>tolerationSeconds=300</code>
kecuali konfigurasi lain disediakan oleh pengguna.</p><p><em>Toleration</em> yang ditambahkan secara otomatis ini menjamin bahwa
perilaku <em>default</em> dari suatu <em>pod</em> adalah tetap bertahan selama 5 menit pada
<em>node</em> apabila salah satu masalah terdeteksi.
Kedua <em>toleration</em> <em>default</em> tadi ditambahkan oleh <a href=https://git.k8s.io/kubernetes/plugin/pkg/admission/defaulttolerationseconds>DefaultTolerationSeconds
<em>admission controller</em></a>.</p><p><em>Pod-pod</em> pada <a href=/id/docs/concepts/workloads/controllers/daemonset/>DaemonSet</a> dibuat dengan <em>toleration</em>
<code>NoExecute</code> untuk <em>taint</em> tanpa <code>tolerationSeconds</code>:</p><ul><li><code>node.kubernetes.io/unreachable</code></li><li><code>node.kubernetes.io/not-ready</code></li></ul><p>Hal ini menjamin <em>pod-pod</em> yang merupakan bagian dari DaemonSet tidak pernah berada di dalam
<em>state</em> <em>evicted</em> apabila terjadi permasalahan pada <em>node</em>.</p><h2 id=taint-pada-node-berdasarkan-kondisi-tertentu><em>Taint</em> pada <em>Node</em> berdasarkan Kondisi Tertentu</h2><p>Pada versi 1.12, fitur <code>TaintNodesByCondition</code> menjadi fitur beta, dengan demikian <em>lifecycle</em>
dari kontroler <em>node</em> akan secara otomatis menambahkan <em>taint</em> sesuai dengan kondisi <em>node</em>.
Hal yang sama juga terjadi pada <em>scheduler</em>, <em>scheduler</em> tidak bertugas memeriksa kondisi <em>node</em>
tetapi kondisi <em>taint</em>. Hal ini memastikan bahwa kondisi <em>node</em> tidak memengaruhi apa
yang dijadwalkan di <em>node</em>. Pengguna dapat memilih untuk mengabaikan beberapa permasalahan yang
ada pada <em>node</em> (yang direpresentasikan oleh kondisi <em>Node</em>) dengan menambahkan <em>toleration</em> <em>Pod</em> <code>NoSchedule</code>.
Sedangkan <em>taint</em> dengan <em>effect</em> <code>NoExecute</code> dikendalikan oleh <code>TaintBasedEviction</code> yang merupakan
fitur beta yang diaktifkan secara <em>default</em> oleh Kubernetes sejak versi 1.13.</p><p>Sejak Kubernetes versi 1.8, kontroler DaemonSet akan secara otomatis
menambahkan <em>toleration</em> <code>NoSchedule</code> pada semua <em>daemon</em> untuk menjaga
fungsionalitas DaemonSet.</p><ul><li><code>node.kubernetes.io/memory-pressure</code></li><li><code>node.kubernetes.io/disk-pressure</code></li><li><code>node.kubernetes.io/out-of-disk</code> (hanya untuk pod yang bersifat <em>critical</em>)</li><li><code>node.kubernetes.io/unschedulable</code> (versi 1.10 atau yang lebih baru)</li><li><code>node.kubernetes.io/network-unavailable</code> (hanya untuk jaringan <em>host</em>)</li></ul><p>Menambahkan <em>toleration</em> ini menjamin <em>backward compatibility</em>.
Kamu juga dapat menambahkan <em>toleration</em> lain pada DaemonSet.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-e511ed821ada65d0053341dbd8ad2bb5>6 - Secret</h1><p>Objek <code>secret</code> pada Kubernetes mengizinkan kamu menyimpan dan mengatur informasi yang sifatnya sensitif, seperti
<em>password</em>, token OAuth, dan ssh <em>keys</em>. Menyimpan informasi yang sifatnya sensitif ini ke dalam <code>secret</code>
cenderung lebih aman dan fleksible jika dibandingkan dengan menyimpan informasi tersebut secara apa adanya pada definisi <a class=glossary-tooltip title="Unit Kubernetes yang paling sederhana dan kecil. Sebuah Pod merepresentasikan sebuah set kontainer yang dijalankan pada kluster kamu." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a> atau di dalam <a class=glossary-tooltip title="Instans yang disimpan dari sebuah Container yang memuat seperangkat perangkat lunak yang dibutuhkan untuk menjalankan sebuah aplikasi." data-toggle=tooltip data-placement=top href="/id/docs/reference/glossary/?all=true#term-image" target=_blank aria-label="container image">container image</a>.
Silahkan lihat <a href=https://git.k8s.io/community/contributors/design-proposals/auth/secrets.md>Dokumen desain Secret</a> untuk informasi yang sifatnya mendetail.</p><h2 id=ikhtisar-secret>Ikhtisar Secret</h2><p>Sebuah Secret merupakan sebuah objek yang mengandung informasi yang sifatnya
sensitif, seperti <em>password</em>, token, atau <em>key</em>. Informasi tersebut sebenarnya bisa saja
disimpan di dalam spesifikasi Pod atau <em>image</em>; meskipun demikian, melakukan penyimpanan
di dalam objek Secret mengizinkan pengguna untuk memiliki kontrol lebih lanjut mengenai
bagaimana Secret ini disimpan, serta mencegah tereksposnya informasi sensitif secara
tidak disengaja.</p><p>Baik pengguna dan sistem memiliki kemampuan untuk membuat objek Secret.</p><p>Untuk menggunakan Secret, sebuah Pod haruslah merujuk pada Secret tersebut.
Sebuah Secret dapat digunakan di dalam sebuah Pod melalui dua cara:
sebagai <em>file</em> yang ada di dalam <em>volume</em> <a class=glossary-tooltip title="Sebuah direktori yang mengandung data, dapat diakses o;eh kontainer-kontainer di dalam pod." data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=volume>volume</a>
yang di-<em>mount</em> pada salah satu container Pod, atau digunakan oleh kubelet
ketika menarik <em>image</em> yang digunakan di dalam Pod.</p><h3 id=secret-built-in>Secret <em>Built-in</em></h3><h4 id=sebuah-service-account-akan-secara-otomatis-dibuat-dan-meng-attach-secret-dengan-kredensial-api>Sebuah <em>Service Account</em> akan Secara Otomatis Dibuat dan Meng-<em>attach</em> Secret dengan Kredensial API</h4><p>Kubernetes secara otomatis membuat secret yang mengandung kredensial
yang digunakan untuk mengakses API, serta secara otomatis memerintahkan Pod untuk menggunakan
Secret ini.</p><p>Mekanisme otomatisasi pembuatan secret dan penggunaan kredensial API dapat di nonaktifkan
atau di-<em>override</em> jika kamu menginginkannya. Meskipun begitu, jika apa yang kamu butuhkan
hanyalah mengakses apiserver secara aman, maka mekanisme <em>default</em> inilah yang disarankan.</p><p>Baca lebih lanjut dokumentasi <a href=/id/docs/tasks/configure-pod-container/configure-service-account/><em>Service Account</em></a>
untuk informasi lebih lanjut mengenai bagaimana cara kerja <em>Service Account</em>.</p><h3 id=membuat-objek-secret-kamu-sendiri>Membuat Objek Secret Kamu Sendiri</h3><h4 id=membuat-secret-dengan-menggunakan-kubectl>Membuat Secret dengan Menggunakan kubectl</h4><p>Misalnya saja, beberapa Pod memerlukan akses ke sebuah basis data. Kemudian <em>username</em>
dan <em>password</em> yang harus digunakan oleh Pod-Pod tersebut berada pada mesin lokal kamu
dalam bentuk <em>file-file</em> <code>./username.txt</code> dan <code>./password.txt</code>.</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># Buatlah berkas yang selanjutnya akan digunakan pada contoh-contoh selanjutnya</span>
<span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;admin&#39;</span> &gt; ./username.txt
<span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;1f2d1e2e67df&#39;</span> &gt; ./password.txt
</code></pre></div><p>Perintah <code>kubectl create secret</code> akan mengemas <em>file-file</em> ini menjadi Secret dan
membuat sebuah objek pada Apiserver.</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic db-user-pass --from-file<span style=color:#666>=</span>./username.txt --from-file<span style=color:#666>=</span>./password.txt
</code></pre></div><pre><code>secret &quot;db-user-pass&quot; created
</code></pre><blockquote class="note callout"><div><strong>Catatan:</strong> Karakter spesial seperti <code>$</code>, <code>\*</code>, and <code>!</code> membutuhkan mekanisme <em>escaping</em>.
Jika <em>password</em> yang kamu gunakan mengandung karakter spesial, kamu perlu melakukan <em>escape</em> karakter dengan menggunakan karakter <code>\\</code>. Contohnya, apabila <em>password</em> yang kamu miliki adalah <code>S!B\*d$zDsb</code>, maka kamu harus memanggil perintah kubectl dengan cara berikut:
kubectl create secret generic dev-db-secret --from-literal=username=devuser --from-literal=password=S\!B\\*d\$zDsb
Perhatikan bahwa kamu tidak perlu melakukan <em>escape</em> karakter apabila massukan yang kamu berikan merupakan <em>file</em> (<code>--from-file</code>).</div></blockquote><p>Kamu dapat memastikan apakah suatu Secret sudah dibuat atau belum dengan menggunakan perintah:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get secrets
</code></pre></div><pre><code>NAME                  TYPE                                  DATA      AGE
db-user-pass          Opaque                                2         51s
</code></pre><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe secrets/db-user-pass
</code></pre></div><pre><code>Name:            db-user-pass
Namespace:       default
Labels:          &lt;none&gt;
Annotations:     &lt;none&gt;

Type:            Opaque

Data
====
password.txt:    12 bytes
username.txt:    5 bytes
</code></pre><blockquote class="note callout"><div><strong>Catatan:</strong> Perintah-perintah <code>kubectl get</code> dan <code>kubectl describe</code> secara <em>default</em> akan
mencegah ditampilkannya informasi yang ada di dalam Secret.
Hal ini dilakukan untuk melindungi agar Secret tidak terekspos secara tidak disengaja oleh orang lain,
atau tersimpan di dalam <em>log</em> <em>terminal</em>.</div></blockquote><p>Kamu dapat membaca <a href=#decoding-a-secret>bagaimana cara melakukan <em>decode</em> sebuah secret</a>
untuk mengetahui bagaimana cara melihat isi dari Secret.</p><h4 id=membuat-secret-secara-manual>Membuat Secret Secara Manual</h4><p>Kamu dapat membuat sebuah Secret dengan terlebih dahulu membuat <em>file</em> yang berisikan
informasi yang ingin kamu jadikan Secret dalam bentuk yaml atau json dan kemudian membuat objek
dengan menggunakan <em>file</em> tersebut. <a href=/docs/reference/generated/kubernetes-api/v1.12/#secret-v1-core>Secret</a>
mengandung dua buah <em>map</em>: <em>data</em> dan <em>stringData</em>. <em>Field</em> <em>data</em> digunakan untuk menyimpan sembarang data,
yang di-<em>encode</em> menggunakan base64. Sementara itu <em>stringData</em> disediakan untuk memudahkan kamu untuk menyimpan
informasi sensitif dalam format yang tidak di-<em>encode</em>.</p><p>Sebagai contoh, untuk menyimpan dua buah string di dalam Secret dengan menggunakan <em>field</em> data, ubahlah
informasi tersebut ke dalam base64 dengan menggunakan mekanisme sebagai berikut:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;admin&#39;</span> | base64
<span style=color:#b8860b>YWRtaW4</span><span style=color:#666>=</span>
<span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;1f2d1e2e67df&#39;</span> | base64
MWYyZDFlMmU2N2Rm
</code></pre></div><p>Buatlah sebuah Secret yang memiliki bentuk sebagai berikut:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>MWYyZDFlMmU2N2Rm<span style=color:#bbb>
</span></code></pre></div><p>Kemudian buatlah Secret menggunakan perintah <a href=/docs/reference/generated/kubectl/kubectl-commands#apply><code>kubectl apply</code></a>:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f ./secret.yaml
</code></pre></div><pre><code>secret &quot;mysecret&quot; created
</code></pre><p>Untuk beberapa skenario, kamu bisa saja ingin menggunakan opsi <em>field</em> stringData.
<em>Field</em> ini mengizinkan kamu untuk memberikan masukan berupa informasi yang belum di-<em>encode</em> secara langsung
pada sebuah Secret, informasi dalam bentuk string ini kemudian akan di-<em>encode</em> ketika Secret dibuat maupun diubah.</p><p>Contoh praktikal dari hal ini adalah ketika kamu melakukan proses <em>deploy</em> aplikasi
yang menggunakan Secret sebagai penyimpanan <em>file</em> konfigurasi, dan kamu ingin mengisi
bagian dari konfigurasi <em>file</em> tersebut ketika aplikasi di_deploy_.</p><p>Jika kamu ingin aplikasi kamu menggunakan <em>file</em> konfigurasi berikut:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiUrl</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;https://my.api.com/api/v1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;user&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;password&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>Kamu dapat menyimpan Secret ini dengan menggunakan cara berikut:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>config.yaml</span>:<span style=color:#bbb> </span>|-<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    apiUrl: &#34;https://my.api.com/api/v1&#34;
</span><span style=color:#b44;font-style:italic>    username: {{username}}
</span><span style=color:#b44;font-style:italic>    password: {{password}}</span><span style=color:#bbb>    
</span></code></pre></div><p>Alat <em>deployment</em> yang kamu gunakan kemudian akan mengubah templat variabel <code>{{username}}</code> dan <code>{{password}}</code>
sebelum menjalankan perintah <code>kubectl apply</code>.</p><p>stringData merupakan <em>field</em> yang sifatnya <em>write-only</em> untuk alasan kenyamanan pengguna.
<em>Field</em> ini tidak pernah ditampilkan ketika Secret dibaca. Sebagai contoh, misalkan saja kamu menjalankan
perintah sebagai berikut:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get secret mysecret -o yaml
</code></pre></div><p>Keluaran yang diberikan kurang lebih akan ditampilkan sebagai berikut:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2018-11-15T20:40:59Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;7225&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selfLink</span>:<span style=color:#bbb> </span>/api/v1/namespaces/default/secrets/mysecret<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>c280ad2e-e916-11e8-98f2-025000000001<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>config.yaml</span>:<span style=color:#bbb> </span>YXBpVXJsOiAiaHR0cHM6Ly9teS5hcGkuY29tL2FwaS92MSIKdXNlcm5hbWU6IHt7dXNlcm5hbWV9fQpwYXNzd29yZDoge3twYXNzd29yZH19<span style=color:#bbb>
</span></code></pre></div><p>Jika sebuah <em>field</em> dispesifikasikan dalam bentuk data maupun stringData,
maka nilai dari stringData-lah yang akan digunakan. Sebagai contoh, misalkan saja terdapat
definisi Secret sebagai berikut:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>administrator<span style=color:#bbb>
</span></code></pre></div><p>Akan menghasilkan Secret sebagai berikut:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2018-11-15T20:46:46Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;7579&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selfLink</span>:<span style=color:#bbb> </span>/api/v1/namespaces/default/secrets/mysecret<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>91460ecb-e917-11e8-98f2-025000000001<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW5pc3RyYXRvcg==<span style=color:#bbb>
</span></code></pre></div><p>Dimana string <code>YWRtaW5pc3RyYXRvcg==</code> akan di-<em>decode</em> sebagai <code>administrator</code>.</p><p><em>Key</em> dari data dan stringData yang boleh tersusun atas karakter alfanumerik,
'-', '_' atau '.'.</p><p><strong>Catatan <em>Encoding</em>:</strong> <em>Value</em> dari JSON dan YAML yang sudah diseriakisasi dari data Secret
akan di-<em>encode</em> ke dalam string base64. <em>Newline</em> dianggap tidak valid pada string ini dan harus
dihilangkan. Ketika pengguna Darwin/macOS menggunakan alat <code>base64</code>, maka pengguna
tersebut harus menghindari opsi <code>-b</code> yang digunakan untuk memecah baris yang terlalu panjang.
Sebaliknya pengguna Linux <em>harus</em> menambahkan opsi <code>-w 0</code> pada perintah <code>base64</code> atau
melakukan mekanisme <em>pipeline</em> <code>base64 | tr -d '\n'</code> jika tidak terdapat opsi <code>-w</code>.</p><h4 id=membuat-secret-dengan-menggunakan-generator>Membuat Secret dengan Menggunakan <em>Generator</em></h4><p>Kubectl mendukung <a href=/docs/tasks/manage-kubernetes-objects/kustomization/>mekanisme manajemen objek dengan menggunakan Kustomize</a>
sejak versi 1.14. Dengan fitur baru ini, kamu juga dapat membuat sebuah Secret dari sebuah <em>generator</em>
dan kemudian mengaplikasikannya untuk membuat sebuah objek pada Apiserver. <em>Generator</em> yang digunakan haruslah
dispesifikasikan di dalam sebuah <em>file</em> <code>kustomization.yaml</code> di dalam sebuah direktori.</p><p>Sebagai contoh, untuk menghasilan sebuah Secret dari <em>file-file</em> <code>./username.txt</code> dan <code>./password.txt</code></p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># Membuat sebuah berkas kustomization.yaml dengan SecretGenerator</span>
cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span><span style=color:#b44>secretGenerator:
</span><span style=color:#b44>- name: db-user-pass
</span><span style=color:#b44>  files:
</span><span style=color:#b44>  - username.txt
</span><span style=color:#b44>  - password.txt
</span><span style=color:#b44>EOF</span>
</code></pre></div><p>Gunakan direktori <em>kustomization</em> untuk membuat objek Secret yang diinginkan.</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ kubectl apply -k .
secret/db-user-pass-96mffmfh4k created
</code></pre></div><p>Kamu dapat memastikan Secret tersebut sudah dibuat dengan menggunakan perintah berikut:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ kubectl get secrets
NAME                             TYPE                                  DATA      AGE
db-user-pass-96mffmfh4k          Opaque                                <span style=color:#666>2</span>         51s

$ kubectl describe secrets/db-user-pass-96mffmfh4k
Name:            db-user-pass
Namespace:       default
Labels:          &lt;none&gt;
Annotations:     &lt;none&gt;

Type:            Opaque

<span style=color:#b8860b>Data</span>
<span style=color:#666>====</span>
password.txt:    <span style=color:#666>12</span> bytes
username.txt:    <span style=color:#666>5</span> bytes
</code></pre></div><p>Sebagai contoh, untuk membuat sebuah Secret dari literal <code>username=admin</code> dan <code>password=secret</code>,
kamu dapat menspesifikasikan <em>generator</em> Secret pada <em>file</em> <code>kustomization.yaml</code> sebagai</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># Membuat sebuah berkas kustomization.yaml dengan menggunakan SecretGenerator</span>
$ cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span><span style=color:#b44>secretGenerator:
</span><span style=color:#b44>- name: db-user-pass
</span><span style=color:#b44>  literals:
</span><span style=color:#b44>  - username=admin
</span><span style=color:#b44>  - password=secret
</span><span style=color:#b44>EOF</span>
</code></pre></div><p>Aplikasikan direktori <em>kustomization</em> untuk membuat objek Secret.</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ kubectl apply -k .
secret/db-user-pass-dddghtt9b5 created
</code></pre></div><blockquote class="note callout"><div><strong>Catatan:</strong> Secret yang dihasilkan nantinya akan memiliki tambahan sufix dengan cara melakukan teknik <em>hashing</em>
pada isi Secret tersebut. Hal ini dilakukan untuk menjamin dibuatnya sebuah Secret baru setiap kali terjadi
perubahan isi dari Secret tersebut.</div></blockquote><h4 id=melakukan-proses-decode-pada-secret>Melakukan Proses <em>Decode</em> pada Secret</h4><p>Secret dapat dibaca dengan menggunakan perintah <code>kubectl get secret</code>.
Misalnya saja, untuk membaca Secret yang dibuat pada bagian sebelumya:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get secret mysecret -o yaml
</code></pre></div><pre><code>apiVersion: v1
kind: Secret
metadata:
  creationTimestamp: 2016-01-22T18:41:56Z
  name: mysecret
  namespace: default
  resourceVersion: &quot;164619&quot;
  selfLink: /api/v1/namespaces/default/secrets/mysecret
  uid: cfee02d6-c137-11e5-8d73-42010af00002
type: Opaque
data:
  username: YWRtaW4=
  password: MWYyZDFlMmU2N2Rm
</code></pre><p>Kemudian lakukan mekanisme <em>decode</em> <em>field</em> <em>password</em>:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;MWYyZDFlMmU2N2Rm&#39;</span> | base64 --decode
</code></pre></div><pre><code>1f2d1e2e67df
</code></pre><h2 id=menggunakan-secret>Menggunakan Secret</h2><p>Secret dapat di-<em>mount</em> sebagai <em>volume</em> data atau dapat diekspos sebagai <a class=glossary-tooltip title="Variabel lingkungan Container merupakan pasangan nama=nilai yang dapat digunakan untuk menyediakan informasi penting bagi Container yang dijalankan pada Pod." data-toggle=tooltip data-placement=top href=/docs/concepts/containers/container-environment-variables/ target=_blank aria-label="variabel-variabel environment">variabel-variabel environment</a>
dapat digunakan di dalam Pod. Secret ini juga dapat digunakan secara langsug
oleh bagian lain dari sistem, tanpa secara langsung berkaitan dengan Pod.
Sebagai contoh, Secret dapat berisikan kredensial bagian suatu sistem lain yang digunakan
untuk berinteraksi dengan sistem eksternal yang kamu butuhkan.</p><h3 id=menggunakan-secret-sebagai-file-melalui-pod>Menggunakan Secret sebagai <em>File</em> melalui Pod</h3><p>Berikut adalah langkah yang harus kamu penuhi agar kamu dapat menggunakan Secret di dalam <em>volume</em> dalam sebuah Pod:</p><ol><li>Buatlah sebuah Secret, atau gunakan sebuah Secret yang sudah kamu buat sebelumnya. Beberapa Pod dapat merujuk pada sebuah Secret yang sama.</li><li>Modifikasi definisi Pod kamu dengan cara menambahkan sebuah <em>volume</em> di bawah <code>.spec.volumes[]</code>. Berilah <em>volume</em> tersebut nama, dan pastikan <em>field</em> <code>.spec.volumes[].secret.secretName</code> merujuk pada nama yang sama dengan objek secret.</li><li>Tambahkan <em>field</em> <code>.spec.containers[].volumeMounts[]</code> pada setiap container yang membutuhkan Secret. Berikan spesifikasi <code>.spec.containers[].volumeMounts[].readOnly = true</code> dan <code>.spec.containers[].volumeMounts[].mountPath</code> pada direktori dimana Secret tersebut diletakkan.</li><li>Modifikasi image dan/atau <em>command line</em> kamu agar program yang kamu miliki merujuk pada <em>file</em> di dalam direktori tersebut. Setiap <em>key</em> pada map <code>data</code> Secret akan menjadi nama dari sebuah <em>file</em> pada <code>mountPath</code>.</li></ol><p>Berikut merupakan salah satu contoh dimana sebuah Pod melakukan proses <em>mount</em> Secret pada sebuah <em>volume</em>:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></code></pre></div><p>Setiap Secret yang ingin kamu gunakan harus dirujuk pada <em>field</em> <code>.spec.volumes</code>.</p><p>Jika terdapat lebih dari satu container di dalam Pod,
maka setiap container akan membutuhkan blok <code>volumeMounts</code>-nya masing-masing,
meskipun demikian hanya sebuah <em>field</em> <code>.spec.volumes</code> yang dibutuhkan untuk setiap Secret.</p><p>Kamu dapat menyimpan banyak <em>file</em> ke dalam satu Secret,
atau menggunakan banyak Secret, hal ini tentunya bergantung pada preferensi pengguna.</p><p><strong>Proyeksi <em>key</em> Secret pada Suatu <em>Path</em> Spesifik</strong></p><p>Kita juga dapat mengontrol <em>path</em> di dalam <em>volume</em> di mana sebuah Secret diproyeksikan.
Kamu dapat menggunakan <em>field</em> <code>.spec.volumes[].secret.items</code> untuk mengubah
<em>path</em> target dari setiap <em>key</em>:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-username<span style=color:#bbb>
</span></code></pre></div><p>Apa yang akan terjadi jika kita menggunakan definisi di atas:</p><ul><li>Secret <code>username</code> akan disimpan pada <em>file</em> <code>/etc/foo/my-group/my-username</code> dan bukan <code>/etc/foo/username</code>.</li><li>Secret <code>password</code> tidak akan diproyeksikan.</li></ul><p>Jika <em>field</em> <code>.spec.volumes[].secret.items</code> digunakan, hanya <em>key-key</em> yang dispesifikan di dalam
<code>items</code> yang diproyeksikan. Untuk mengonsumsi semua <em>key-key</em> yang ada dari Secret,
semua <em>key</em> yang ada harus didaftarkan pada <em>field</em> <code>items</code>.
Semua <em>key</em> yang didaftarkan juga harus ada di dalam Secret tadi.
Jika tidak, <em>volume</em> yang didefinisikan tidak akan dibuat.</p><p><strong><em>Permission</em> <em>File-File</em> Secret</strong></p><p>Kamu juga dapat menspesifikasikan mode <em>permission</em> dari <em>file</em> Secret yang kamu inginkan.
Jika kamu tidak menspesifikasikan hal tersebut, maka nilai <em>default</em> yang akan diberikan adalah <code>0644</code> is used by default.
Kamu dapat memberikan mode <em>default</em> untuk semua Secret yang ada serta melakukan mekanisme <em>override</em> <em>permission</em>
pada setiap <em>key</em> jika memang diperlukan.</p><p>Sebagai contoh, kamu dapat memberikan spesifikasi mode <em>default</em> sebagai berikut:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>defaultMode</span>:<span style=color:#bbb> </span><span style=color:#666>256</span><span style=color:#bbb>
</span></code></pre></div><p>Kemudian, sebuah Secret akan di-<em>mount</em> pada <code>/etc/foo</code>, selanjutnya semua <em>file</em>
yang dibuat pada <em>volume</em> secret tersebut akan memiliki <em>permission</em> <code>0400</code>.</p><p>Perhatikan bahwa spesifikasi JSON tidak mendukung notasi <em>octal</em>, dengan demikian gunakanlah
<em>value</em> 256 untuk <em>permission</em> 0400. Jika kamu menggunakan format YAML untuk spesifikasi Pod,
kamu dapat menggunakan notasi <em>octal</em> untuk memberikan spesifikasi <em>permission</em> dengan cara yang lebih
natural.</p><p>Kamu juga dapat melakukan mekanisme pemetaan, seperti yang sudah dilakukan pada contoh sebelumnya,
dan kemudian memberikan spesifikasi <em>permission</em> yang berbeda untuk <em>file</em> yang berbeda.</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-username<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mode</span>:<span style=color:#bbb> </span><span style=color:#666>511</span><span style=color:#bbb>
</span></code></pre></div><p>Pada kasus tersebut, <em>file</em> yang dihasilkan pada <code>/etc/foo/my-group/my-username</code> akan memiliki
<em>permission</em> <code>0777</code>. Karena terdapat batasan pada representasi JSON, maka kamu
harus memberikan spesifikasi mode <em>permission</em> dalam bentuk notasi desimal.</p><p>Perhatikan bahwa <em>permission</em> ini bida saja ditampilkan dalam bentuk notasi desimal,
hal ini akan ditampilkan pada bagian selanjutnya.</p><p><strong>Mengonsumsi <em>Value</em> dari Secret melalui Volume</strong></p><p>Di dalam sebuah container dimana <em>volume</em> secret di-<em>mount</em>,
<em>key</em> dari Secret akan ditampilkan sebagai <em>file</em> dan <em>value</em> dari Secret yang berada dalam bentuk
base64 ini akan di-<em>decode</em> dam disimpan pada <em>file-file</em> tadi.
Berikut merupakan hasil dari eksekusi perintah di dalam container berdasarkan contoh
yang telah dipaparkan di atas:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ls /etc/foo/
</code></pre></div><pre><code>username
password
</code></pre><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat /etc/foo/username
</code></pre></div><pre><code>admin
</code></pre><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat /etc/foo/password
</code></pre></div><pre><code>1f2d1e2e67df
</code></pre><p>Program di dalam container bertanggung jawab untuk membaca Secret
dari <em>file-file</em> yang ada.</p><p><strong>Secret yang di-<em>mount</em> Akan Diubah Secara Otomatis</strong></p><p>Ketika sebuah Secret yang sedang digunakan di dalam <em>volume</em> diubah,
maka <em>key</em> yang ada juga akan diubah. Kubelet akan melakukan mekanisme pengecekan secara periodik
apakah terdapat perubahan pada Secret yang telah di-<em>mount</em>. Meskipun demikian,
proses pengecekan ini dilakukan dengan menggunakan <em>cache</em> lokal untuk mendapatkan <em>value</em> saat ini
dari sebuah Secret. Tipe <em>cache</em> yang ada dapat diatur dengan menggunakan
(<em>field</em> <code>ConfigMapAndSecretChangeDetectionStrategy</code> pada
<a href=https://github.com/kubernetes/kubernetes/blob/release-1.20/staging/src/k8s.io/kubelet/config/v1beta1/types.go><em>struct</em> KubeletConfiguration</a>).
Mekanisme ini kemudian dapat diteruskan dengan mekanisme <em>watch</em>(<em>default</em>), ttl, atau melakukan pengalihan semua
<em>request</em> secara langsung pada kube-apiserver.
Sebagai hasilnya, <em>delay</em> total dari pertama kali Secret diubah hingga dilakukannya mekanisme
proyeksi <em>key</em> yang baru pada Pod berlangsung dalam jangka waktu sinkronisasi periodik kubelet +
<em>delay</em> propagasi <em>cache</em>, dimana <em>delay</em> propagasi <em>cache</em> bergantung pada jenis <em>cache</em> yang digunakan
(ini sama dengan <em>delay</em> propagasi <em>watch</em>, ttl dari <em>cache</em>, atau nol).</p><blockquote class="note callout"><div><strong>Catatan:</strong> Sebuah container menggunakan Secret sebagai
<a href=/id/docs/concepts/storage/volumes#using-subpath>subPath</a> dari <em>volume</em>
yang di-<em>mount</em> tidak akan menerima perubahan Secret.</div></blockquote><h3 id=menggunakan-secret-sebagai-variabel-environment>Menggunakan Secret sebagai Variabel <em>Environment</em></h3><p>Berikut merupakan langkah-langkah yang harus kamu terapkan,
untuk menggunakan secret sebagai <a class=glossary-tooltip title="Variabel lingkungan Container merupakan pasangan nama=nilai yang dapat digunakan untuk menyediakan informasi penting bagi Container yang dijalankan pada Pod." data-toggle=tooltip data-placement=top href=/docs/concepts/containers/container-environment-variables/ target=_blank aria-label="variabel _environment_">variabel _environment_</a>
pada sebuah Pod:</p><ol><li>Buatlah sebuah Secret, atau gunakan sebuah Secret yang sudah kamu buat sebelumnya. Beberapa Pod dapat merujuk pada sebuah Secret yang sama.</li><li>Modifikasi definisi Pod pada setiap container dimana kamu menginginkan container tersebut dapat mengonsumsi your Pod definition in each container that you wish to consume the value of a secret key to add an environment variabele for each secret key you wish to consume. The environment variabele that consumes the secret key should populate the secret's name and key in <code>env[].valueFrom.secretKeyRef</code>.</li><li>Modifikasi <em>image</em> dan/atau <em>command line</em> kamu agar program yang kamu miliki merujuk pada <em>value</em> yang sudah didefinisikan pada variabel <em>environment</em>.</li></ol><p>Berikut merupakan contoh dimana sebuah Pod menggunakan Secret sebagai variabel <em>environment</em>:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-env-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mycontainer<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SECRET_USERNAME<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SECRET_PASSWORD<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>password<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div><p><strong>Menggunakan Secret dari Variabel <em>Environment</em></strong></p><p>Di dalam sebuah container yang mengkonsumsi Secret pada sebuah variabel <em>environment</em>, <em>key</em> dari sebuah secret
akan ditampilkan sebagai variabel <em>environment</em> pada umumnya dengan <em>value</em> berupa informasi yang telah di-<em>decode</em>
ke dalam base64. Berikut merupakan hasil yang didapatkan apabila perintah-perintah di bawah ini
dijalankan dari dalam container yang didefinisikan di atas:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>echo</span> <span style=color:#b8860b>$SECRET_USERNAME</span>
</code></pre></div><pre><code>admin
</code></pre><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>echo</span> <span style=color:#b8860b>$SECRET_PASSWORD</span>
</code></pre></div><pre><code>1f2d1e2e67df
</code></pre><h3 id=menggunakan-imagepullsecrets>Menggunakan imagePullSecrets</h3><p>Sebuah <code>imagePullSecret</code> merupakan salah satu cara yang dapat digunakan untuk menempatkan secret
yang mengandung <em>password</em> dari registri Docker (atau registri <em>image</em> lainnya)
pada Kubelet, sehingga Kubelet dapat mengunduh <em>image</em> dan menempatkannya pada Pod.</p><p><strong>Memberikan spesifikasi manual dari sebuah imagePullSecret</strong></p><p>Penggunaan imagePullSecrets dideskripsikan di dalam <a href=/id/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod>dokumentasi <em>image</em></a></p><h3 id=mekanisme-yang-dapat-diterapkan-agar-imagepullsecrets-dapat-secara-otomatis-digunakan>Mekanisme yang Dapat Diterapkan agar imagePullSecrets dapat Secara Otomatis Digunakan</h3><p>Kamu dapat secara manual membuat sebuah imagePullSecret, serta merujuk imagePullSecret
yang sudah kamu buat dari sebuah serviceAccount. Semua Pod yang dibuat dengan menggunakan
serviceAccount tadi atau serviceAccount <em>default</em> akan menerima <em>field</em> imagePullSecret dari
serviceAccount yang digunakan.
Bacalah <a href=/id/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account>Cara menambahkan ImagePullSecrets pada sebuah <em>service account</em></a>
untuk informasi lebih detail soal proses yang dijalankan.</p><h3 id=mekanisme-mounting-otomatis-dari-secret-yang-sudah-dibuat>Mekanisme <em>Mounting</em> Otomatis dari Secret yang Sudah Dibuat</h3><p>Secret yang dibuat secara manual (misalnya, secret yang mengandung token yang dapat digunakan
untuk mengakses akun GitHub) dapat di-<em>mount</em> secara otomatis pada sebuah Pod berdasarkan <em>service account</em>
yang digunakan oleh Pod tadi.
Baca <a href=/docs/tasks/inject-data-application/podpreset/>Bagaimana Penggunaan PodPreset untuk Memasukkan Informasi ke Dalam Pod</a> untuk informasi lebih lanjut.</p><h2 id=detail>Detail</h2><h3 id=batasan-batasan>Batasan-Batasan</h3><p>Sumber dari <em>secret volume</em> akan divalidasi untuk menjamin rujukan pada
objek yang dispesifikasikan mengarah pada objek dengan <em>type</em> <code>Secret</code>.
Oleh karenanya, sebuah <em>secret</em> harus dibuat sebelum Pod yang merujuk pada <em>secret</em>
tersebut dibuat.</p><p>Sebuah objek API Secret berada di dalam sebuah <a class=glossary-tooltip title="Sebuah abstraksi yang digunakan oleh Kubernetes untuk mendukung multipel klaster virtual pada klaster fisik yang sama." data-toggle=tooltip data-placement=top href=/id/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=namespace>namespace</a>.
Objek-objek ini hanya dapat dirujuk oleh Pod-Pod yang ada pada namespace yang sama.</p><p>Secret memiliki batasi dalam hal ukuran maksimalnya yaitu hanya sampai 1MiB per objek.
Oleh karena itulah, pembuatan secret dalam ukuran yang sangat besar tidak dianjurkan
karena dapat menghabiskan sumber daya apiserver dan memori kubelet. Meskipun demikian,
pembuatan banyak secret dengan ukuran kecil juga dapat menhabiskan memori. Pembatasan
sumber daya yang diizinkan untuk pembuatan secret merupakan salah satu fitur tambahan
yang direncanakan kedepannya.</p><p>Kubelet hanya mendukung penggunaan secret oleh Pod apabila Pod tersebut
didapatkan melalui apiserver. Hal ini termasuk Pod yang dibuat dengan menggunakan
kubectl, atau secara tak langsung melalui <em>replication controller</em>. Hal ini tidak
termasuk Pod yang dibuat melalui <em>flag</em> <code>--manifest-url</code> yang ada pada kubelet,
maupun REST API yang disediakan (hal ini bukanlah merupakan mekanisme umum yang dilakukan
untuk membuat sebuah Pod).</p><p>Secret harus dibuat sebelum digunakan oleh Pod sebagai variabel <em>environment</em>,
kecuali apabila variabel <em>environment</em> ini dianggap opsional. Rujukan pada Secret
yang tidak dapat dipenuhi akan menyebabkan Pod gagal <em>start</em>.</p><p>Rujukan melalui <code>secretKeyRef</code> pada <em>key</em> yang tidak ada pada <em>named</em> Secret
akan akan menyebabkan Pod gagal <em>start</em>.</p><p>Secret yang digunakan untuk memenuhi variabel <em>environment</em> melalui <code>envFrom</code> yang
memiliki <em>key</em> yang dianggap memiliki penamaan yang tidak valid akan diabaikan.
Hal ini akan akan menyebabkan Pod gagal <em>start</em>. Selanjutnya akan terdapat <em>event</em>
dengan alasan <code>InvalidvariabeleNames</code> dan pesan yang berisikan <em>list</em> dari
<em>key</em> yang diabaikan akibat penamaan yang tidak valid. Contoh yang ada akan menunjukkan
sebuah pod yang merujuk pada secret <code>default/mysecret</code> yang mengandung dua buah <em>key</em>
yang tidak valid, yaitu 1badkey dan 2alsobad.</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get events
</code></pre></div><pre><code>LASTSEEN   FIRSTSEEN   COUNT     NAME            KIND      SUBOBJECT                         TYPE      REASON
0s         0s          1         dapi-test-pod   Pod                                         Warning   InvalidEnvironmentvariabeleNames   kubelet, 127.0.0.1      Keys [1badkey, 2alsobad] from the EnvFrom secret default/mysecret were skipped since they are considered invalid environment variabele names.
</code></pre><h3 id=interaksi-secret-dan-pod-lifetime>Interaksi Secret dan Pod Lifetime</h3><p>Ketika sebuah pod dibuat melalui API, tidak terdapat mekanisme pengecekan
yang digunakan untuk mengetahui apakah sebuah Secret yang dirujuk sudah dibuat
atau belum. Ketika sebuah Pod di-<em>schedule</em>, kubelet akan mencoba mengambil
informasi mengenai <em>value</em> dari secret tadi. Jika secret tidak dapat diambil
<em>value</em>-nya dengan alasan temporer karena hilangnya koneksi ke API server atau
secret yang dirujuk tidak ada, kubelet akan melakukan mekanisme <em>retry</em> secara periodik.
Kubelet juga akan memberikan laporan mengenai <em>event</em> yang terjadi pada Pod serta alasan
kenapa Pod tersebut belum di-<em>start</em>. Apabila Secret berhasil didapatkan, kubelet
akan membuat dan me-<em>mount</em> volume yang mengandung secret tersebut. Tidak akan ada
container dalam pod yang akan di-<em>start</em> hingga semua volume pod berhasil di-<em>mount</em>.</p><h2 id=contoh-contoh-penggunaan>Contoh-Contoh Penggunaan</h2><h3 id=contoh-penggunaan-pod-dengan-ssh-key>Contoh Penggunaan: Pod dengan <em>ssh key</em></h3><p>Buatlah sebuah kustomization.yaml dengan SecretGenerator yang mengandung beberapa <em>ssh key</em>:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic ssh-key-secret --from-file<span style=color:#666>=</span>ssh-privatekey<span style=color:#666>=</span>/path/to/.ssh/id_rsa --from-file<span style=color:#666>=</span>ssh-publickey<span style=color:#666>=</span>/path/to/.ssh/id_rsa.pub
</code></pre></div><pre><code>secret &quot;ssh-key-secret&quot; created
</code></pre><blockquote class="caution callout"><div><strong>Perhatian:</strong> Pikirkanlah terlebih dahulu sebelum kamu menggunakan <em>ssh key</em> milikmu sendiri: pengguna lain pada kluster tersebut bisa saja memiliki akses pada secret yang kamu definisikan.
Gunakanlah service account untuk membagi informasi yang kamu inginkan di dalam kluster tersebut, dengan demikian kamu dapat membatalkan service account tersebut apabila secret tersebut disalahgunakan.</div></blockquote><p>Sekarang, kita dapat membuat sebuah pod yang merujuk pada secret dengan <em>ssh key</em> yang sudah
dibuat tadi serta menggunakannya melalui sebuah volume yang di-<em>mount</em>:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test-pod<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>ssh-key-secret<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ssh-test-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mySshImage<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>Ketika sebuah perintah dijalankan di dalam container, bagian dari <em>key</em> tadi akan
terdapat pada:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>/etc/secret-volume/ssh-publickey
/etc/secret-volume/ssh-privatekey
</code></pre></div><p>container kemudian dapat menggunakan secret secara bebas untuk
membuat koneksi ssh.</p><h3 id=contoh-penggunaan-pod-dengan-kredensial-prod-test>Contoh Penggunaan: Pod dengan kredensial prod / test</h3><p>Contoh ini memberikan ilustrasi pod yang mengonsumsi secret yang mengandung
kredensial dari <em>environment</em> <em>production</em> atau <em>environment</em> <em>test</em>.</p><p>Buatlah suatu kustomization.yaml dengan SecretGenerator</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic prod-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>produser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span>Y4nys7f11
</code></pre></div><pre><code>secret &quot;prod-db-secret&quot; created
</code></pre><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic test-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>testuser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span>iluvtests
</code></pre></div><pre><code>secret &quot;test-db-secret&quot; created
</code></pre><blockquote class="note callout"><div><strong>Catatan:</strong><p>Karakter spesial seperti <code>$</code>, <code>\*</code>, dan <code>!</code> membutuhkan mekanisme <em>escaping</em>.
Jika password yang kamu gunakan memiliki karakter spesial, kamu dapat melakukan mekanisme <em>escape</em>
dengan karakter <code>\\</code> character. Sebagai contohnya, jika <em>password</em> kamu yang sebenarnya adalah
<code>S!B\*d$zDsb</code>, maka kamu harus memanggil perintah eksekusi dengan cara sebagai berikut:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic dev-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>devuser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span>S<span style=color:#b62;font-weight:700>\\</span>!B<span style=color:#b62;font-weight:700>\\\*</span>d<span style=color:#b62;font-weight:700>\\</span><span style=color:#b8860b>$zDsb</span>
</code></pre></div><p>Kamu tidak perlu melakukan mekanisme <em>escape</em> karakter apabila menggunakan opsi melalui <em>file</em> (<code>--from-file</code>).</p></div></blockquote><p>Kemudian buatlah Pod-Pod yang dibutuhkan:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ cat <span style=color:#b44>&lt;&lt;EOF &gt; pod.yaml
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: List
</span><span style=color:#b44>items:
</span><span style=color:#b44>- kind: Pod
</span><span style=color:#b44>  apiVersion: v1
</span><span style=color:#b44>  metadata:
</span><span style=color:#b44>    name: prod-db-client-pod
</span><span style=color:#b44>    labels:
</span><span style=color:#b44>      name: prod-db-client
</span><span style=color:#b44>  spec:
</span><span style=color:#b44>    volumes:
</span><span style=color:#b44>    - name: secret-volume
</span><span style=color:#b44>      secret:
</span><span style=color:#b44>        secretName: prod-db-secret
</span><span style=color:#b44>    containers:
</span><span style=color:#b44>    - name: db-client-container
</span><span style=color:#b44>      image: myClientImage
</span><span style=color:#b44>      volumeMounts:
</span><span style=color:#b44>      - name: secret-volume
</span><span style=color:#b44>        readOnly: true
</span><span style=color:#b44>        mountPath: &#34;/etc/secret-volume&#34;
</span><span style=color:#b44>- kind: Pod
</span><span style=color:#b44>  apiVersion: v1
</span><span style=color:#b44>  metadata:
</span><span style=color:#b44>    name: test-db-client-pod
</span><span style=color:#b44>    labels:
</span><span style=color:#b44>      name: test-db-client
</span><span style=color:#b44>  spec:
</span><span style=color:#b44>    volumes:
</span><span style=color:#b44>    - name: secret-volume
</span><span style=color:#b44>      secret:
</span><span style=color:#b44>        secretName: test-db-secret
</span><span style=color:#b44>    containers:
</span><span style=color:#b44>    - name: db-client-container
</span><span style=color:#b44>      image: myClientImage
</span><span style=color:#b44>      volumeMounts:
</span><span style=color:#b44>      - name: secret-volume
</span><span style=color:#b44>        readOnly: true
</span><span style=color:#b44>        mountPath: &#34;/etc/secret-volume&#34;
</span><span style=color:#b44>EOF</span>
</code></pre></div><p>Tambahkan Pod-Pod terkait pada <em>file</em> kustomization.yaml yang sama</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ cat <span style=color:#b44>&lt;&lt;EOF &gt;&gt; kustomization.yaml
</span><span style=color:#b44>resources:
</span><span style=color:#b44>- pod.yaml
</span><span style=color:#b44>EOF</span>
</code></pre></div><p>Terapkan semua perubahan pada objek-objek tadi ke Apiserver dengan menggunakan</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply --k .
</code></pre></div><p>Kedua container kemudian akan memiliki <em>file-file</em> berikut ini di dalam
<em>filesystem</em> keduanya dengan <em>value</em> sebagai berikut untuk masing-masing <em>environment</em>:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>/etc/secret-volume/username
/etc/secret-volume/password
</code></pre></div><p>Perhatikan bahwa <em>specs</em> untuk kedua pod berbeda hanya pada satu <em>field</em> saja;
hal ini bertujuan untuk memfasilitasi adanya kapabilitas yang berbeda dari templat
konfigurasi umum yang tersedia.</p><p>Kamu dapat mensimplifikasi spesifikasi dasar Pod dengan menggunakan dua buah <em>service account</em> yang berbeda:
misalnya saja salah satunya disebut sebagai <code>prod-user</code> dengan <code>prod-db-secret</code>, dan satunya lagi disebut
<code>test-user</code> dengan <code>test-db-secret</code>. Kemudian spesifikasi Pod tadi dapat diringkas menjadi:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>prod-db-client-pod<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>prod-db-client<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceAccount</span>:<span style=color:#bbb> </span>prod-db-client<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>db-client-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>myClientImage<span style=color:#bbb>
</span></code></pre></div><h3 id=contoh-penggunaan-dotfiles-pada-volume-secret>Contoh Penggunaan: <em>Dotfiles</em> pada volume secret</h3><p>Dengan tujuan membuat data yang ada 'tersembunyi' (misalnya, di dalam sebuah <em>file</em> dengan nama yang dimulai
dengan karakter titik), kamu dapat melakukannya dengan cara yang cukup sederhana, yaitu cukup dengan membuat
karakter awal <em>key</em> yang kamu inginkan dengan titik. Contohnya, ketika sebuah secret di bawah ini di-<em>mount</em>
pada sebuah volume:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dotfile-secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>.secret-file</span>:<span style=color:#bbb> </span>dmFsdWUtMg0KDQo=<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-dotfiles-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>dotfile-secret<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dotfile-test-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ls<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;-l&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>Volume <code>secret-volume</code> akan mengandung sebuah <em>file</em>, yang disebut sebagai <code>.secret-file</code>, serta
container <code>dotfile-test-container</code> akan memiliki <em>file</em> konfigurasinya pada <em>path</em>
<code>/etc/secret-volume/.secret-file</code>.</p><blockquote class="note callout"><div><strong>Catatan:</strong> <em>File-file</em> yang diawali dengan karakter titik akan "tersembunyi" dari keluaran perintah <code>ls -l</code>;
kamu harus menggunakan perintah <code>ls -la</code> untuk melihat <em>file-file</em> tadi dari sebuah direktori.</div></blockquote><h3 id=contoh-penggunaan-secret-yang-dapat-diakses-hanya-pada-salah-satu-container-di-dalam-pod>Contoh Penggunaan: Secret yang dapat diakses hanya pada salah satu container di dalam pod</h3><p>Misalkan terdapat sebuah program yang memiliki kebutuhan untuk menangani <em>request</em> HTTP,
melakukan logika bisnis yang kompleks, serta kemudian menandai beberapa <em>message</em> yang ada
dengan menggunakan HMAC. Karena program ini memiliki logika aplikasi yang cukup kompleks,
maka bisa jadi terdapat beberapa celah terjadinya eksploitasi <em>remote</em> <em>file</em> pada server,
yang nantinya bisa saja mengekspos <em>private key</em> yang ada pada <em>attacker</em>.</p><p>Hal ini dapat dipisah menjadi dua buah proses yang berbeda di dalam dua container:
sebuah container <em>frontend</em> yang menangani interaksi pengguna dan logika bisnis, tetapi
tidak memiliki kapabilitas untuk melihat <em>private key</em>; container lain memiliki kapabilitas
melihat <em>private key</em> yang ada dan memiliki fungsi untuk menandai <em>request</em> yang berasal
dari <em>frontend</em> (melalui jaringan <em>localhost</em>).</p><p>Dengan strategi ini, seorang <em>attacker</em> harus melakukan teknik tambahan
untuk memaksa aplikasi melakukan hal yang acak, yang kemudian menyebabkan
mekanisme pembacaan <em>file</em> menjadi lebih susah.</p><h2 id=best-practices><em>Best practices</em></h2><h3 id=klien-yang-menggunakan-api-secret>Klien yang menggunakan API secret</h3><p>Ketika men-<em>deploy</em> aplikasi yang berinteraksi dengan API secret, akses yang dilakukan
haruslah dibatasi menggunakan <a href=/docs/reference/access-authn-authz/authorization/><em>policy</em> autorisasi</a> seperti <a href=/docs/reference/access-authn-authz/rbac/>RBAC</a>.</p><p>Secret seringkali menyimpan <em>value</em> yang memiliki jangkauan spektrum
kepentingan, yang mungkin saja dapat menyebabkan terjadinya eskalasi baik
di dalam Kubernetes (misalnya saja token dari sebuah <em>service account</em>) maupun<br>sistem eksternal. Bahkan apabila setiap aplikasi secara individual memiliki
kapabilitas untuk memahami tingkatan yang dimilikinya untuk berinteraksi dengan secret tertentu,
aplikasi lain dalam namespace itu bisa saja menyebabkan asumsi tersebut menjadi tidak valid.</p><p>Karena alasan-alasan yang sudah disebutkan tadi <em>request</em> <code>watch</code> dan <code>list</code> untuk sebuah
secret di dalam suatu namespace merupakan kapabilitas yang sebisa mungkin harus dihindari,
karena menampilkan semua secret yang ada berimplikasi pada akses untuk melihat isi yang ada
pada secret yang ada. Kapabilitas untuk melakukan <em>request</em> <code>watch</code> dan <code>list</code> pada semua secret di kluster
hanya boleh dimiliki oleh komponen pada sistem level yang paling <em>previleged</em>.</p><p>Aplikasi yang membutuhkan akses ke API secret harus melakukan <em>request</em> <code>get</code> pada
secret yang dibutuhkan. Hal ini memungkinkan administrator untuk membatasi
akses pada semua secret dengan tetap memberikan <a href=/id/docs/reference/access-authn-authz/rbac/#referring-to-resources>akses pada instans secret tertentu</a>
yang dibutuhkan aplikasi.</p><p>Untuk meningkatkan performa dengan menggunakan iterasi <code>get</code>, klien dapat mendesain
sumber daya yang merujuk pada suatu secret dan kemudian melakukan <code>watch</code> pada secret tersebut,
serta melakukan <em>request</em> secret ketika terjadi perubahan pada rujukan tadi. Sebagai tambahan, <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/bulk_watch.md>API "bulk watch"</a>
yang dapat memberikan kapabilitas <code>watch</code> individual pada sumber daya melalui klien juga sudah direncanakan,
dan kemungkinan akan diimplementasikan dirilis Kubernetes selanjutnya.</p><h2 id=properti-keamanan>Properti Keamanan</h2><h3 id=proteksi>Proteksi</h3><p>Karena objek <code>secret</code> dapat dibuat secara independen dengan <code>pod</code> yang menggunakannya,
risiko tereksposnya secret di dalam workflow pembuatan, pemantauan, serta pengubahan pod.
Sistem yang ada juga dapat memberikan tindakan pencegahan ketika berinteraksi dengan <code>secret</code>,
misalnya saja tidak melakukan penulisan isi <code>secret</code> ke dalam disk apabila hal tersebut
memungkinkan.</p><p>Sebuah secret hanya diberikan pada node apabila pod yang ada di dalam node
membutuhkan secret tersebut. Kubelet menyimpan secret yang ada pada <code>tmpfs</code>
sehingga secret tidak ditulis pada disk. Setelah pod yang bergantung pada secret tersebut dihapus,
maka kubelet juga akan menghapus salinan lokal data secret.</p><p>Di dalam sebuah node bisa saja terdapat beberapa secret yang dibutuhkan
oleh pod yang ada di dalamnya. Meskipun demikian, hanya secret yang di-<em>request</em>
oleh sebuah pod saja yang dapat dilihat oleh container yang ada di dalamnya.
Dengan demikian, sebuah Pod tidak memiliki akses untuk melihat secret yang ada
pada pod yang lain.</p><p>Di dalam sebuah pod bisa jadi terdapat beberapa container.
Meskipun demikian, agar sebuah container bisa mengakses <em>volume secret</em>, container
tersebut haruslah mengirimkan <em>request</em> <code>volumeMounts</code> yang ada dapat diakses dari
container tersebut. Pengetahuan ini dapat digunakan untuk membentuk <a href=#contoh-penggunaan-secret-yang-dapat-diakses-hanya-pada-salah-satu-container-di-dalam-pod>partisi security
pada level pod</a>.</p><p>Pada sebagian besar distribusi yang dipelihara projek Kubernetes,
komunikasi antara pengguna dan apiserver serta apisserver dan kubelet dilindungi dengan menggunakan SSL/TLS.
Dengan demikian, secret dalam keadaan dilindungi ketika ditransmisi.</p><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.13 [beta]</code></div><p>Kamu dapat mengaktifkan <a href=/docs/tasks/administer-cluster/encrypt-data/>enkripsi pada rest</a>
untuk data secret, sehingga secret yang ada tidak akan ditulis ke dalam <a class=glossary-tooltip title="Penyimpanan key value konsisten yang digunakan sebagai penyimpanan data klaster Kubernetes." data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a>
dalam keadaan tidak terenkripsi.</p><h3 id=resiko>Resiko</h3><ul><li>Pada API server, data secret disimpan di dalam <a class=glossary-tooltip title="Penyimpanan key value konsisten yang digunakan sebagai penyimpanan data klaster Kubernetes." data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a>;
dengan demikian:<ul><li>Administrator harus mengaktifkan enkripsi pada rest untuk data kluster (membutuhkan versi v1.13 atau lebih)</li><li>Administrator harus membatasi akses etcd pada pengguna dengan kapabilitas admin</li><li>Administrator bisa saja menghapus data disk yang sudah tidak lagi digunakan oleh etcd</li><li>Jika etcd dijalankan di dalam kluster, administrator harus memastikan SSL/TLS
digunakan pada proses komunikasi peer-to-peer etcd.</li></ul></li><li>Jika kamu melakukan konfigurasi melalui sebuah <em>file</em> manifest (JSON or YAML)
yang menyimpan data secret dalam bentuk base64, membagi atau menyimpan secret ini
dalam repositori kode sumber sama artinya dengan memberikan informasi mengenai data secret.
Mekanisme <em>encoding</em> base64 bukanlah merupakan teknik enkripsi dan nilainya dianggap sama saja dengan <em>plain text</em>.</li><li>Aplikasi masih harus melindungi <em>value</em> dari secret setelah membaca nilainya dari suatu volume
dengan demikian risiko terjadinya <em>logging</em> secret secara tidak engaja dapat dihindari.</li><li>Seorang pengguna yang dapat membuat suatu pod yang menggunakan secret, juga dapat melihat <em>value</em> secret.
Bahkan apabila <em>policy</em> apiserver tidak memberikan kapabilitas untuk membaca objek secret, pengguna
dapat menjalankan pod yang mengekspos secret.</li><li>Saat ini, semua orang dengan akses <em>root</em> pada node dapat membaca secret <em>apapun</em> dari apiserver,<br>dengan cara meniru kubelet. Meskipun begitu, terdapat fitur yang direncanakan pada rilis selanjutnya yang memungkinkan pengiriman secret hanya dapat
mengirimkan secret pada node yang membutuhkan secret tersebut untuk membatasi adanya eksploitasi akses <em>root</em> pada node ini.</li></ul><h2 id=selanjutnya>Selanjutnya</h2></div><div class=td-content style=page-break-before:always><h1 id=pg-ab6d20f33ad930a67ee7ef57bff6c75e>7 - Mengatur Akses Klaster Menggunakan Berkas kubeconfig</h1><p>Gunakan berkas kubeconfig untuk mengatur informasi mengenai klaster, pengguna,
<em>namespace</em>, dan mekanisme autentikasi. Perintah <code>kubectl</code> menggunakan berkas
kubeconfig untuk mencari informasi yang dibutuhkan untuk memilih klaster dan
berkomunikasi dengan API server dari suatu klaster.</p><blockquote class="note callout"><div><strong>Catatan:</strong> Sebuah berkas yang digunakan untuk mengatur akses pada klaster disebut dengan
berkas kubeconfig. Ini cara yang umum digunakan untuk mereferensikan berkas
konfigurasi. Ini tidak berarti ada berkas dengan nama <code>kubeconfig</code>.</div></blockquote><p>Secara <em>default</em>, <code>kubectl</code> mencari berkas dengan nama <code>config</code> pada direktori
<code>$HOME/.kube</code>. Kamu bisa mengatur lokasi berkas kubeconfig dengan mengatur
nilai <code>KUBECONFIG</code> pada variabel <em>environment</em> atau dengan mengatur menggunakan
tanda <a href=/docs/reference/generated/kubectl/kubectl/><code>--kubeconfig</code></a>.</p><p>Instruksi langkah demi langkah untuk membuat dan menentukan berkas kubeconfig,
bisa mengacu pada [Mengatur Akses Pada Beberapa Klaster]
(/id/docs/tasks/access-application-cluster/configure-access-multiple-clusters).</p><h2 id=mendukung-beberapa-klaster-pengguna-dan-mekanisme-autentikasi>Mendukung beberapa klaster, pengguna, dan mekanisme autentikasi</h2><p>Misalkan kamu memiliki beberapa klaster, pengguna serta komponen dapat melakukan
autentikasi dengan berbagai cara. Sebagai contoh:</p><ul><li>Kubelet yang berjalan dapat melakukan autentikasi dengan menggunakan sertifikat</li><li>Pengguna bisa melakukan autentikasi dengan menggunakan token</li><li>Administrator bisa memiliki beberapa sertifikat yang diberikan kepada pengguna
individu.</li></ul><p>Dengan berkas kubeconfig, kamu bisa mengatur klaster, pengguna, dan <em>namespace</em>.
Kamu juga bisa menentukan konteks untuk mempercepat dan mempermudah perpindahan
antara klaster dan <em>namespace</em>.</p><h2 id=konteks>Konteks</h2><p>Sebuah elemen konteks pada berkas kubeconfig digunakan untuk mengelompokkan
parameter akses dengan nama yang mudah. Setiap konteks akan memiliki 3 parameter:
klaster, pengguna, dan <em>namespace</em>. Secara <em>default</em>, perintah <code>kubectl</code> menggunakan
parameter dari konteks yang aktif untuk berkomunikasi dengan klaster.</p><p>Untuk memilih konteks yang aktif, bisa menggunakan perintah berikut:</p><pre><code>kubectl config use-context
</code></pre><h2 id=variabel-environment-kubeconfig>Variabel <em>environment</em> KUBECONFIG</h2><p>Variabel <em>environment</em> <code>KUBECONFIG</code> berisikan beberapa berkas kubeconfig. Untuk
Linux dan Mac, beberapa berkas tersebut dipisahkan dengan tanda titik dua (:).
Untuk Windows, dipisahkan dengan menggunakan tanda titik koma (;). Variabel
<em>environment</em> <code>KUBECONFIG</code> tidak diwajibkan untuk ada. Jika variabel <em>environment</em>
<code>KUBECONFIG</code> tidak ada, maka <code>kubectl</code> akan menggunakan berkas kubeconfig pada
<code>$HOME/.kube/config</code>.</p><p>Jika variabel <em>environment</em> <code>KUBECONFIG</code> ternyata ada, maka <code>kubectl</code> akan menggunakan
konfigurasi yang merupakan hasil gabungan dari berkas-berkas yang terdapat pada
variabel <em>environment</em> <code>KUBECONFIG</code>.</p><h2 id=menggabungkan-berkas-berkas-kubeconfig>Menggabungkan berkas-berkas kubeconfig</h2><p>Untuk melihat konfigurasimu, gunakan perintah berikut ini:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config view
</code></pre></div><p>Seperti yang dijelaskan sebelumnya, hasil perintah diatas bisa berasal dari sebuah
berkas kubeconfig, atau bisa juga merupakan hasil gabungan dari beberapa berkas kubeconfig.</p><p>Berikut adalah aturan yang digunakan <code>kubectl</code> ketika menggabungkan beberapa berkas
kubeconfig:</p><ol><li><p>Jika menggunakan tanda <code>--kubeconfig</code>, maka akan menggunakan berkas yang ditentukan.
Tidak digabungkan. Hanya 1 tanda <code>--kubeconfig</code> yang diperbolehkan.</p><p>Sebaliknya, jika variabel <em>environment</em> <code>KUBECONFIG</code> digunakan, maka akan menggunakan
ini sebagai berkas-berkas yang akan digabungkan. Penggabungan berkas-berkas yang terdapat
pada variabel <em>environment</em> <code>KUBECONFIG</code> akan mengikuti aturan sebagai berikut:</p><ul><li>Mengabaikan berkas tanpa nama.</li><li>Mengeluarkan pesan kesalahan untuk berkas dengan isi yang tidak dapat dideserialisasi.</li><li>Berkas pertama yang menentukan nilai atau <em>key</em> pada <em>map</em> maka akan digunakan
pada <em>map</em> tersebut.</li><li>Tidak pernah mengubah nilai atau <em>key</em> dari suatu <em>map</em>.
Contoh: Pertahankan konteks pada berkas pertama yang mengatur <code>current-context</code>.
Contoh: Jika terdapat dua berkas yang menentukan nilai <code>red-user</code>, maka hanya gunakan
nilai <code>red-user</code> dari berkas pertama.
Meskipun berkas kedua tidak memiliki entri yang bertentangan pada <code>red-user</code>,
abaikan mereka.</li></ul><p>Beberapa contoh pengaturan variabel <em>environment</em> <code>KUBECONFIG</code>, bisa melihat pada
<a href=/id/docs/tasks/access-application-cluster/configure-access-multiple-clusters/#set-the-kubeconfig-environment-variable>pengaturan vaiabel <em>environment</em> KUBECONFIG</a>.</p><p>Sebaliknya, bisa menggunakan berkas kubeconfig <em>default</em>, <code>$HOME/.kube/config</code>,
tanpa melakukan penggabungan.</p></li><li><p>Konteks ditentukan oleh yang pertama sesuai dari pilihan berikut:</p><ol><li>Menggunakan tanda <code>--context</code> pada perintah</li><li>Menggunakan nilai <code>current-context</code> dari hasil gabungan berkas kubeconfig.</li></ol><p>Konteks yang kosong masih diperbolehkan pada tahap ini.</p></li><li><p>Menentukan klaster dan pengguna. Pada tahap ini, mungkin akan ada atau tidak ada konteks.
Menentukan klaster dan pengguna berdasarkan yang pertama sesuai dengan pilihan berikut,
yang mana akan dijalankan dua kali: sekali untuk pengguna dan sekali untuk klaster:</p><ol><li>Jika ada, maka gunakan tanda pada perintah: <code>--user</code> atau <code>--cluster</code>.</li><li>Jika konteks tidak kosong, maka pengguna dan klaster didapat dari konteks.</li></ol><p>Pengguna dan klaster masih diperbolehkan kosong pada tahap ini.</p></li><li><p>Menentukan informasi klaster sebenarnya yang akan digunakan. Pada tahap ini, mungkin
akan ada atau tidak ada informasi klaster. Membentuk informasi klaster berdasarkan urutan
berikut dan yang pertama sesuai akan digunakan:</p><ol><li>Jika ada, maka gunakan tanda pada perintah: <code>--server</code>, <code>--certificate-authority</code>, <code>--insecure-skip-tls-verify</code>.</li><li>Jika terdapat atribut informasi klaster dari hasil gabungan berkas kubeconfig,
maka gunakan itu.</li><li>Jika tidak terdapat informasi mengenai lokasi server, maka dianggap gagal.</li></ol></li><li><p>Menentukan informasi pengguna sebenarnya yang akan digunakan. Membentuk informasi
pengguna dengan aturan yang sama dengan pembentukan informasi klaster, namun hanya
diperbolehkan ada satu teknik autentikasi untuk setiap pengguna:</p><ol><li>Jika ada, gunakan tanda pada perintah: <code>--client-certificate</code>, <code>--client-key</code>, <code>--username</code>, <code>--password</code>, <code>--token</code>.</li><li>Menggunakan <em>field</em> <code>user</code> dari hasil gabungan berkas kubeconfig.</li><li>Jika terdapat dua teknik yang bertentangan, maka dianggap gagal.</li></ol></li><li><p>Untuk setiap informasi yang masih belum terisi, akan menggunakan nilai <code>default</code> dan
kemungkinan akan meminta informasi autentikasi.</p></li></ol><h2 id=referensi-berkas>Referensi berkas</h2><p>Referensi <em>file</em> dan <em>path</em> pada berkas kubeconfig adalah bernilai relatif terhadap
lokasi dari berkas kubeconfig.
Referensi <em>file</em> pada perintah adalah relatif terhadap direktori kerja saat ini.
Dalam <code>$HOME/.kube/config</code>, <em>relative path</em> akan disimpan secara relatif, dan
<em>absolute path</em> akan disimpan secara mutlak.</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li><a href=/id/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>Mengatur Akses Pada Beberapa Klaster</a></li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#config><code>kubectl config</code></a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-ed4ae5e4344d619bc6df6e1278efae74>8 - Prioritas dan Pemindahan Pod</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes 1.14 [stable]</code></div><p><a href=/docs/user-guide/pods>Pod</a> dapat memiliki <em>priority</em> (prioritas). Priority mengindikasikan lebih penting atau tidaknya sebuah Pod dibandingkan dengan Pod-pod lainnya. Jika sebuah Pod tidak dapat dijadwalkan (tertunda/<em>pending</em>), penjadwal akan mencoba untuk melakukan <em>preemption</em>/pemindahan (mengusir/<em>evict</em>) Pod-pod dengan prioritas lebih rendah agar penjadwalan Pod yang tertunda sebelumnya dapat dilakukan.</p><p>Pada Kubernetes 1.9 dan sesudahnya, Priority juga memengaruhi urutan penjadwalan Pod-pod dan urutan pengusiran Pod-pod dari Node pada kasus kehabisan sumber daya.</p><p>Priority dan Pemindahan Pod lulus menjadi <em>beta</em> pada Kubernetes 1.11 dan menjadi GA (<em>Generally Available</em>) pada Kubernetes 1.14. Mereka telah dihidupkan secara bawaan sejak versi 1.11.</p><p>Pada versi-versi Kubernetes di mana Priority dan pemindahan Pod masih berada pada tingkat fitur <em>alpha</em>, kamu harus menghidupkannya secara eksplisit. Untuk menggunakan fitur-fitur pada versi-versi lama Kubernetes, ikuti petunjuk di dokumentasi versi Kubernetes kamu, melalui arsip versi dokumentasi untuk versi Kubernetes kamu.</p><table><thead><tr><th>Versi Kubernetes</th><th style=text-align:center>Keadaan Priority and Pemindahan</th><th style=text-align:center>Dihidupkan secara Bawaan</th></tr></thead><tbody><tr><td>1.8</td><td style=text-align:center>alpha</td><td style=text-align:center>tidak</td></tr><tr><td>1.9</td><td style=text-align:center>alpha</td><td style=text-align:center>tidak</td></tr><tr><td>1.10</td><td style=text-align:center>alpha</td><td style=text-align:center>tidak</td></tr><tr><td>1.11</td><td style=text-align:center>beta</td><td style=text-align:center>ya</td></tr><tr><td>1.14</td><td style=text-align:center>stable</td><td style=text-align:center>ya</td></tr></tbody></table><blockquote class="warning callout"><div><strong>Peringatan:</strong> Pada sebuah klaster di mana tidak semua pengguna dipercaya, seorang pengguna yang berniat jahat dapat membuat Pod-pod dengan prioritas paling tinggi, membuat Pod-pod lainnya dipindahkan/tidak dapat dijadwalkan. Untuk mengatasi masalah ini, <a href=/id/docs/concepts/policy/resource-quotas/>ResourceQuota</a> ditambahkan untuk mendukung prioritas Pod. Seorang admin dapat membuat ResourceQuota untuk pengguna-pengguna pada tingkat prioritas tertentu, mencegah mereka untuk membuat Pod-pod pada prioritas tinggi. Fitur ini telah beta sejak Kubernetes 1.12.</div></blockquote><h2 id=bagaimana-cara-menggunakan-priority-dan-pemindahan-pod>Bagaimana cara menggunakan Priority dan pemindahan Pod</h2><p>Untuk menggunakan Priority dan pemindahan Pod pada Kubernetes 1.11 dan sesudahnya, ikuti langkah-langkah berikut:</p><ol><li><p>Tambahkan satu atau lebih <a href=#priorityclass>PriorityClass</a>.</p></li><li><p>Buat Pod-pod dengan <a href=#prioritas-pod><code>priorityClassName</code></a>
disetel menjadi salah satu dari PriorityClass yang ditambahkan.
Tentu saja kamu tidak perlu membuat Pod-pod tersebut secara langsung;
Biasanya kamu akan menambahkan <code>priorityClassName</code> pada
<code>template</code> Pod dari sebuah objek kumpulan seperti sebuah Deployment.</p></li></ol><p>Teruslah membaca untuk lebih banyak informasi mengenai langkah-langkah tersebut.</p><p>Jika kamu mencoba fitur ini dan memutuskan untuk mematikannya, kamu harus menghapus <em>command-line flag</em> PodPriority atau menyetelnya menjadi <code>false</code>, kemudian melakukan pengulangan kembali terhadap API Server dan Scheduler. Setelah fitur ini dimatikan, Pod-pod yang sudah ada tetap akan memiliki kolom priority mereka, tetapi pemindahan Pod akan dimatikan, dan kolom-kolom priority tersebut diabaikan. Jika fitur tersebut telah dimatikan, kamu tidak dapat menyetel kolom <code>priorityClassName</code> pada Pod-pod baru.</p><h2 id=cara-mematikan-pemindahan-pod>Cara mematikan pemindahan Pod</h2><blockquote class="note callout"><div><strong>Catatan:</strong> Pada Kubernetes 1.12 ke atas, Pod-pod yang penting mengandalkan oleh Schneduler agar dapat dijadwalkan saat klaster berada pada kondisi kekurangan sumber daya. Untuk alasan ini, tidak direkomendasikan untuk mematikan fitur pemindahan Pod.</div></blockquote><blockquote class="note callout"><div><strong>Catatan:</strong> Pada Kubernetes 1.15 ke atas, jika fitur <code>NonPreemptingPriority</code> diaktifkan, PriorityClass memiliki pilihan untuk menyetel <code>preemptionPolicy: Never</code>.
Hal ini akan mencegah Pod-pod dari PriorityClass tersebut untuk memicu pemindahan Pod-pod lainnya.</div></blockquote><p>Pada Kubernetes 1.11 dan sesudahnya, pemindahan Pod dikontrol oleh sebuah <em>flag</em> kube-scheduler yaitu <code>disablePreemption</code>, yang disetel menjadi <code>false</code> secara bawaan. Jika kamu ingin mematikan pemindahan Pod meskipun ada catatan di atas, kamu dapat menyetel <code>disablePreemption</code> menjadi <code>true</code>.</p><p>Opsi ini hanya tersedia pada (berkas) konfigurasi komponen saja, dan tidak tersedia pada cara lama melalui <em>command line options</em>. Berikut contoh konfigurasi komponen untuk mematikan pemindahan (<em>preemption</em>) Pod:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1alpha1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>algorithmSource</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>provider</span>:<span style=color:#bbb> </span>DefaultProvider<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>disablePreemption</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></code></pre></div><h2 id=priorityclass>PriorityClass</h2><p>Sebuah PriorityClass adalah sebuah objek tanpa Namespace yang mendefinisikan pemetaan dari sebuah nama kelas prioritas menjadi nilai <em>integer</em> dari prioritas tersebut. Nama tersebut dirinci pada kolom <code>name</code> dari <code>metadata</code> objek PriorityClass tersebut. Nilainya dirinci pada kolom <code>value</code> yang diperlukan. Semakin tinggi nilainya, maka semakin tinggi juga prioritasnya.</p><p>Sebuah objek PriorityClass dapat memiliki nilai <em>integer</em> 32-bit apa pun yang kurang dari atau sama dengan 1 miliar. Angka-angka yang lebih besar dicadangkan untuk Pod-pod pada sistem yang sangat penting yang secara normal sebaiknya tidak dipindahkan atau diusir. Seorang admin klaster sebaiknya membuat sebuah objek PriorityClass untuk setiap pemetaan seperti ini yang ia inginkan.</p><p>PriorityClass juga memiliki dua kolom opsional: <code>globalDefault</code> dan <code>description</code>. Kolom <code>globalDefault</code> mengindikasikan bahwa nilai PriorityClass ini sebaiknya digunakan tanpa sebuah <code>priorityClassName</code>. Hanya sebuah PriorityClass dengan <code>globalDefault</code> disetel menjadi <code>true</code> dapat berada pada sistem/klaster. Jika tidak ada PriorityClass dengan <code>globalDefault</code> yang telah disetel, prioritas Pod-pod tanpa <code>priorityClassName</code> adalah nol.</p><p>Kolom <code>description</code> adalah <em>string</em> yang sembarang. Kolom ini diperuntukkan untuk memberitahukan pengguna-pengguna klaster kapan mereka harus menggunakan PriorityClass ini.</p><h3 id=catatan-mengenai-podpriority-dan-klaster-klaster-yang-sudah-ada>Catatan mengenai PodPriority dan Klaster-klaster yang sudah ada</h3><ul><li><p>Jika kamu meningkatkan versi klaster kamu dan menghidupkan fitur ini, prioritas
Pod-pod kamu yang sudah ada akan secara efektif menjadi nol.</p></li><li><p>Penambahan dari sebuah PriorityClass dengan <code>globalDefault</code> yang disetel menjadi
<code>true</code> tidak mengubah prioritas-prioritas Pod-pod yang sudah ada. Nilai dari
PriorityClass semacam ini digunakan hanya untuk Pod-pod yang dibuat setelah
PriorityClass tersebut ditambahkan.</p></li><li><p>Jika kamu menghapus sebuah PriorityClass, Pod-pod yang sudah ada yang menggunakan
nama dari PriorityClass yang dihapus tersebut tidak akan berubah, tetapi kamu tidak
dapat membuat lebih banyak Pod yang menggunakan nama dari PriorityClass yang telah
dihapus tersebut.</p></li></ul><h3 id=contoh-priorityclass>Contoh PriorityClass</h3><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>scheduling.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>high-priority<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>1000000</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>globalDefault</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>description</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Kelas prioritas ini sebaiknya hanya digunakan untuk Pod-pod layanan XYZ saja.&#34;</span><span style=color:#bbb>
</span></code></pre></div><h3 id=non-preempting-priority-class>PriorityClass yang <em>Non-preempting</em> (alpha)</h3><p>Kubernetes 1.15 menambahkan kolom <code>PreemptionPolicy</code> sebagai sebuah fitur <em>alpha</em>. Fitur ini dimatikan secara bawaan pada 1.15, dan membutuhkan diaktifkannya <a href=/docs/reference/command-line-tools-reference/feature-gates/><em>feature gate</em></a> <code>NonPreemptingPriority</code>.</p><p>Pod-pod dengan <code>PreemptionPolicy: Never</code> akan ditaruh pada antrean penjadwalkan mendahului Pod-pod dengan prioritas rendah, tetapi mereka tidak dapat memicu pemindahan Pod-pod lainnya (disebut juga Pod yang <em>non-preempting</em>).
Sebuah Pod yang <em>non-preempting</em> yang sedang menunggu untuk dijadwalkan akan tetap berada pada antrean penjadwalan, hingga sumber daya yang cukup tersedia, dan ia dapat dijadwalkan. Pod yang <em>non-preempting</em>, seperti Pod-pod lainnya, tunduk kepada <em>back-off</em> dari Scheduler. Hal ini berarti bahwa jika Scheduler mencoba untuk menjadwalkan Pod-pod ini dan mereka tidak dapat dijadwalkan, mereka akan dicoba kembali dengan frekuensi (percobaan) yang lebih rendah, memungkinkan Pod-pod lain dengan prioritas yang lebih rendah untuk dijadwalkan sebelum mereka dijadwalkan.</p><p>Pod yang <em>non-preempting</em> tetap dapat dipicu untuk dipindahkan oleh Pod lainnya yang memiliki prioritas yang lebih tinggi.</p><p><code>PreemptionPolicy</code> secara bawaan nilainya <code>PreemptionLowerPriority</code>, yang memungkinkan Pod-pod dengan PriorityClass tersebut untuk memicu pemindahan Pod-pod dengan prioritas lebih rendah (sama seperti sifat bawaan). Jika <code>PreemptionPolicy</code> disetel menjadi <code>Never</code>, Pod-pod pada PriorityClass tersebut akan menjadi Pod yang <em>non-preempting</em>.</p><p>Sebuah contoh kasus misalnya pada beban kerja <em>data science</em>.
Seorang pengguna dapat memasukkan sebuah beban kerja yang mereka ingin prioritaskan di atas beban kerja lainnya, tetapi tidak ingin menghapus beban kerja yang sudah ada melalui pemicuan pemindahan Pod-pod yang sedang berjalan.
Beban kerja prioritas tinggi dengan <code>PreemptionPolicy: Never</code> akan dijadwalkan mendahului Pod-pod lainnya yang berada dalam antrean, segera setelah sumber daya klaster "secara alami" menjadi cukup.</p><h4 id=contoh-priorityclass-yang-non-preempting>Contoh PriorityClass yang <em>Non-preempting</em></h4><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>scheduling.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>high-priority-nonpreempting<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>1000000</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>preemptionPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>globalDefault</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>description</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Kelas prioritas ini tidak akan memicu pemindahan Pod-pod lainnya.&#34;</span><span style=color:#bbb>
</span></code></pre></div><h2 id=prioritas-pod>Prioritas Pod</h2><p>Setelah kamu memiliki satu atau lebih PriorityClass, kamu dapat membuat Pod-pod yang merinci satu dari nama-nama PriorityClass tersebut pada spesifikasi mereka. Admission Controller prioritas menggunakan kolom <code>priorityClassName</code> dan mengumpulkan nilai <em>integer</em> dari prioritasnya. Jika PriorityClass-nya tidak ditemukan, maka Pod tersebut akan ditolak.</p><p>YAML berikut adalah contoh sebuah konfigurasi Pod yang menggunakan PriorityClass yang telah dibuat pada contoh sebelumnya. Admission Controller prioritas akan memeriksa spesifikasi tersebut dan memetakan prioritas Pod tersebut menjadi nilai 1000000.</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>priorityClassName</span>:<span style=color:#bbb> </span>high-priority<span style=color:#bbb>
</span></code></pre></div><h3 id=efek-prioritas-pod-terhadap-urutan-penjadwalan>Efek prioritas Pod terhadap urutan penjadwalan</h3><p>Pada Kubernetes 1.9 dan sesudahnya, saat prioritas Pod dihidupkan, Scheduler mengurutkan Pod-pod yang tertunda berdasarkan prioritas mereka dan sebuah Pod yang tertunda diletakkan mendahului Pod-pod tertunda lainnya yang memiliki prioritas yang lebih rendah pada antrean penjadwalan. Sebagai hasilnya, Pod dengan prioritas lebih tinggi dapat dijadwalkan lebih awal daripada Pod-pod dengan prioritas yang lebih rendah jika syarat penjadwalan terpenuhi. Jika Pod ini tidak dapat dijadwalkan, Scheduler akan melewatkannya dan mencoba untuk menjadwalkan Pod-pod lain dengan prioritas yang lebih rendah.</p><h2 id=pemindahan-pod>Pemindahan Pod</h2><p>Saat Pod-pod dibuat, mereka masuk ke sebuah antrean dan menunggu untuk dijadwalkan. Scheduler memilih sebuah Pod dari antrean dan mencoba untuk menjadwalkannya pada sebuah Node. Jika tidak ditemukan Node yang memenuhi semua kebutuhan Pod tersebut, logika program pemindahan Pod dipicu untuk Pod yang tertunda tersebut. Kita akan menyebut Pod tertunda tersebut dengan P. Logika program pemindahan Pod mencoba untuk menemukan sebuah Node di mana penghapusan dari satu atau lebih Pod dengan prioritas yang lebih rendah daripada P dapat memungkinkan P untuk dijadwalkan pada Node tersebut. Jika Node tersebut ditemukan, satu atau lebih Pod dengan prioritas lebih rendah akan dipindahkan dari Node tersebut. Setelah Pod-pod tersebut dihapus, P dapat dijadwalkan pada Node tersebut.</p><h3 id=informasi-yang-diekspos-pengguna>Informasi yang diekspos pengguna</h3><p>Saat Pod P memicu pemindahan satu atau lebih Pod pada Node N, kolom <code>nominatedNodeName</code> pada status Pod P disetel menjadi nama dari node N. Kolom ini membantu Scheduler untuk melacak sumber daya yang dicadangkan untuk Pod P dan juga memberikan informasi mengenai pemindahan Pod pada klaster untuk pengguna-pengguna.</p><p>Harap catat bahwa Pod P tidak harus dijadwalkan pada "<em>nominated</em> Node" (Node yang dicalonkan) tersebut. Setelah Pod-pod yang terpilih telah dipindahkan, mereka akan mendapatkan periode penghentian secara sopan (<em>graceful</em>) mereka. Jika Node lain menjadi tersedia saat Scheduler sedang menunggu penghentian Pod-pod yang terpilih untuk dipindahkan, Scheduler akan menggunakan Node lain tersebut untuk menjadwalkan Pod P. Sebagai hasilnya <code>nominatedNodeName</code> dan <code>nodeName</code> dari spesifikasi Pod belum tentu selalu sama. Juga, jika Scheduler memindahkan Pod-pod pada Node N, tapi kemudian sebuah Pod lain dengan prioritas lebih tinggi daripada Pod P tiba, Scheduler boleh memberikan Node N kepada Pod dengan prioritas lebih tinggi tersebut. Pada kasus demikian, Scheduler menghapus <code>nominatedPodName</code> dari Pod P. Dengan melakukan ini, Scheduler membuat Pod P berhak untuk memicu pemindahan Pod-pod lain pada Node lain.</p><h3 id=batasan-batasan-pemindahan-pod>Batasan-batasan pemindahan Pod</h3><h4 id=penghentian-secara-sopan-dari-korban-korban-pemindahan-pod>Penghentian secara sopan dari korban-korban pemindahan Pod</h4><p>Saat Pod-pod dipindahkan, korban-korbannya mendapatkan <a href=/id/docs/concepts/workloads/pods/pod/#penghentian-pod>periode penghentian secara sopan</a>. Mereka memiliki waktu sebanyak itu untuk menyelesaikan pekerjaan merekan dan berhenti. Jika mereka tidak menyelesaikannya sebelum waktu tersebut, mereka akan dihentikan secara paksa. Periode penghentian secara sopan ini membuat sebuah jarak waktu antara saat di mana Scheduler memindahkan Pod-pod dengan waktu saat Pod yang tertunda tersebut (P) dapat dijadwalkan pada Node tersebut (N). Sementara itu, Scheduler akan terus menjadwalkan Pod-pod lain yang tertunda. Oleh karena itu, biasanya ada jarak waktu antara titik di mana Scheduler memindahkan korban-korban dan titik saat Pod P dijadwalkan. Untuk meminimalkan jarak waktu ini, kamu dapat menyetel periode penghentian secara sopan dari Pod-pod dengan prioritas lebih rendah menjadi nol atau sebuah angka yang kecil.</p><h4 id=poddisruptionbudget-didukung-tapi-tidak-dijamin>PodDisruptionBudget didukung, tapi tidak dijamin!</h4><p>Sebuah <a href=/id/docs/concepts/workloads/pods/disruptions/>Pod Disruption Budget (PDB)</a> memungkinkan pemilik-pemilik aplikasi untuk membatasi jumlah Pod-pod dari sebuah aplikasi yang direplikasi yang mati secara bersamaan dikarenakan disrupsi yang disengaja. Kubernetes 1.9 mendukung PDB saat memindahkan Pod-pod, tetapi penghormatan terhadap PDB ini bersifat "usaha terbaik" (<em>best-effort</em>). Scheduler akan mencoba mencari korban-korban yang PDB-nya tidak dilanggar oleh pemindahan, tetapi jika tidak ada korban yang ditemukan, pemindahan akan tetap terjadi, dan Pod-pod dengan prioritas lebih rendah akan dihapus/dipindahkan meskipun PDB mereka dilanggar.</p><h4 id=afinitas-antar-pod-pada-pod-pod-dengan-prioritas-lebih-rendah>Afinitas antar-Pod pada Pod-pod dengan prioritas lebih rendah</h4><p>Sebuah Node akan dipertimbangkan untuk pemindahan Pod hanya jika jawaban pertanyaan berikut adalah "ya": "Jika semua Pod-pod dengan prioritas lebih rendah dari Pod yang tertunda dipindahkan dari Node, dapatkan Pod yang tertunda tersebut dijadwalkan (secara sukses) ke Node tersebut?"</p><blockquote class="note callout"><div><strong>Catatan:</strong> Pemindahan Pod tidak harus memindahkan semua Pod-pod dengan prioritas lebih rendah. Jika Pod yang tertunda dapat dijadwalkan dengan memindahkan lebih sedikit daripada semua Pod-pod dengan prioritas yang lebih rendah, maka hanya sebagian dari Pod-pod dengan prioritas lebih rendah tersebut akan dipindahkan. Meskipun demikian, jawaban untuk pertanyaan sebelumnya haruslah "ya". Jika jawabannya adalah "tidak", maka Node tersebut tidak akan dipertimbangkan untuk pemindahan Pod.</div></blockquote><p>Jika sebuah Pod yang tertunda memiliki afinitas antar-Pod terhadap satu atau lebih dari Pod-pod dengan prioritas lebih rendah pada Node tersebut, maka aturan afinitas antar-Pod tersebut tidak dapat terpenuhi tanpa hadirnya Pod-pod dengan prioritas lebih rendah tersebut. Pada kasus ini, Scheduler tidak melakukan pemindahan terhadap Pod-pod manapun pada Node tersebut. Sebagai gantinya, ia mencari Node lainnya. Scheduler mungkin mendapatkan Node yang cocok atau tidak. Tidak ada jaminan bahwa Pod yang tertunda tersebut dapat dijadwalkan.</p><p>Solusi yang direkomendasikan untuk masalah ini adalah dengan cara membuat afinitas antar-Pod hanya terhadap Pod-pod dengan prioritas yang sama atau lebih tinggi.</p><h4 id=pemindahan-pod-antar-node>Pemindahan Pod antar Node</h4><p>Misalnya sebuah Node N sedang dipertimbangkan untuk pemindahan Pod sehingga sebuah Pod P yang tertunda dapat dijadwalkan pada N. P mungkin menjadi layak untuk N hanya jika sebuah Pod pada Node lain dipindahkan. Berikut sebuah contoh:</p><ul><li>Pod P dipertimbangkan untuk Node N.</li><li>Pod Q sedang berjalan pada Node lain pada Zona yang sama dengan Node N.</li><li>Pod P memiliki anti-afinitas yang berlaku pada seluruh Zona terhadap Pod Q (<code>topologyKey: topology.kubernetes.io/zone</code>).</li><li>Tidak ada kasus anti-afinitas lain antara Pod P dengan Pod-pod lainnya pada Zona tersebut.</li><li>Untuk dapat menjadwalkan Pod P pada Node N, Pod Q dapat dipindahkan, tetapi
Scheduler tidak melakukan pemindahan Pod antar Node. Jadi, Pod P akan
dianggap tidak dapat dijadwalkan pada Node N.</li></ul><p>Jika Pod Q dihapus dari Node-nya, pelanggaran terhadap anti-afinitas Pod tersebut akan hilang, dan Pod P dapat dijadwalkan pada Node N.</p><p>Kita mungkin mempertimbangkan untuk menambahkan pemindahan Pod antar Node pada versi-versi yang akan datang jika ada permintaan yang cukup dari pengguna, dan kami menemukan algoritma dengan kinerja yang layak.</p><h2 id=memecahkan-masalah-pada-prioritas-dan-pemindahan-pod>Memecahkan masalah pada Prioritas dan Pemindahan Pod</h2><p>Prioritas dan Pemindahan Pod adalah sebuah fitur besar yang berpotensi dapat mengganggu penjadwalan Pod jika fitur ini memiliki kesalahan (<em>bug</em>).</p><h3 id=masalah-yang-berpotensi-diakibatkan-oleh-prioritas-dan-pemindahan-pod>Masalah yang berpotensi diakibatkan oleh Prioritas dan Pemindahan Pod</h3><p>Berikut adalah beberapa masalah yang dapat diakibatkan oleh kesalahan-kesalahan pada implementasi fitur ini. Daftar ini tidak lengkap.</p><h4 id=pod-pod-dipindahkan-secara-tidak-perlu>Pod-pod dipindahkan secara tidak perlu</h4><p>Pemindahan Pod menghapus Pod-pod yang sudah ada dari sebuah klaster yang sedang mengalami kekurangan sumber daya untuk menyediakan ruangan untuk Pod-pod tertunda yang memiliki prioritas yang lebih tinggi. Jika seorang pengguna memberikan prioritas-prioritas tinggi untuk Pod-pod tertentu dengan tidak semestinya (karena kesalahan), Pod-pod prioritas tinggi yang tidak disengaja tersebut dapat mengakibatkan pemindahan Pod-pod pada klaster tersebut. Seperti disebutkan di atas, prioritas Pod dispesifikasikan dengan menyetel kolom <code>priorityClassName</code> dari <code>podSpec</code>. Nilai <em>integer</em> dari prioritas tersebut kemudian dipetakan dan diisi pada kolom <code>priority</code> dari <code>podSpec</code>.</p><p>Untuk menyelesaikan masalah tersebut, <code>priorityClassName</code> dari Pod-pod tersebut harus diubah untuk menggunakan kelas dengan prioritas yang lebih rendah, atau dibiarkan kosong saja. Kolom <code>priorityClassName</code> yang kosong dipetakan menjadi nol secara bawaan.</p><p>Saat sebuah Pod dipindahkan, akan ada <em>Event</em> yang direkam untuk Pod yang dipindahkan tersebut. Pemindahan seharusnya hanya terjadi saat sebuah klaster tidak memiliki sumber daya yang cukup untuk sebuah Pod. Pada kasus seperti ini, pemindahan terjadi hanya saat prioritas dari Pod yang tertunda tersebut lebih tinggi daripada Pod-pod korban. Pemindahan tidak boleh terjadi saat tidak ada Pod yang tertunda (<em>preemptor</em>), atau saat Pod-pod yang tertunda memiliki prioritas yang sama atau lebih rendah dari korban-korbannya. Jika pemindahan terjadi pada skenario demikian, mohon daftarkan sebuah Issue.</p><h4 id=pod-pod-dipindahkan-tetapi-preemptor-tidak-dijadwalkan>Pod-pod dipindahkan, tetapi <em>preemptor</em> tidak dijadwalkan</h4><p>Saat Pod-pod dijadwalkan, mereka menerima periode penghentian secara sopan mereka, yang secara bawaan bernilai 30 detik, tetapi dapat bernilai apa pun sesuai dengan yang disetel pada PodSpec. Jika Pod-pod korban tidak berhenti sebelum periode ini, mereka akan dihentikan secara paksa. Saat semua korban telah pergi, Pod <em>preemptor</em> dapat dijadwalkan.</p><p>Saat Pod <em>preemptor</em> sedang menunggu korban-korban dipindahkan, sebuah Pod dengan prioritas lebih tinggi boleh dibuat jika muat pada Node yang sama. Pada kasus ini, Scheduler akan menjadwalkan Pod dengan prioritas lebih tinggi tersebut alih-alih menjadwalkan Pod <em>preemptor</em>.</p><p>Dalam ketidakhadiran Pod dengan prioritas lebih tinggi tersebut, kita mengharapkan Pod <em>preemptor</em> dijadwalkan setelah periode penghentian secara sopan korban-korbannya telah berakhir.</p><h4 id=pod-pod-dengan-prioritas-lebih-tinggi-dipindahkan-karena-pod-pod-dengan-prioritas-lebih-rendah>Pod-pod dengan prioritas lebih tinggi dipindahkan karena Pod-pod dengan prioritas lebih rendah</h4><p>Saat Scheduler mencoba mencari Node-node yang dapat menjalankan sebuah Pod yang tertunda, dan tidak ada Node yang ditemukan, ia akan mencoba untuk memindahkan Pod-pod dengan prioritas lebih rendah dari salah satu Node untuk menyediakan ruangan untuk Pod yang tertunda tersebut. Jika sebuah Node dengan Pod-pod dengan prioritas lebih rendah tidak layak untuk menjalankan Pod yang tertunda tersebut, Scheduler mungkin memilih Node lain dengan Pod yang memiliki prioritas lebih tinggi (dibandingkan dengan Pod-pod pada Node lain tadi) untuk dipindahkan. Korban-korban tersebut harus tetap memiliki prioritas yang lebih rendah dari Pod <em>preemptor</em>.</p><p>Saat ada beberapa Node yang tersedia untuk pemindahan, Scheduler mencoba untuk memilih Node dengan kumpulan Pod yang memiliki prioritas paling rendah. Namun, jika Pod-pod tersebut memiliki PodDisruptionBudget yang akan dilanggar apabila mereka dipindahkan, maka Scheduler akan memilih Node lain dengan Pod-pod yang memiliki prioritas lebih tinggi.</p><p>Saat ada beberapa Node tersedia untuk pemindahan dan tidak ada satupun skenario di atas yang berlaku, kita mengharapkan Scheduler memilih Node dengan prioritas paling rendah. Apabila hal tersebut tidak terjadi, hal ini mungkin menunjukkan bahwa terdapat kesalahan pada Scheduler.</p><h2 id=interaksi-interaksi-prioritas-pod-dan-qos>Interaksi-interaksi prioritas Pod dan QoS</h2><p>Prioritas Pod dan <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/node/resource-qos.md>QoS</a> adalah dua fitur terpisah dengan interaksi yang sedikit dan tidak ada batasan bawaan terhadap penyetelan prioritas Pod berdasarkan kelas QoS-nya. Logika program pemindahan Scheduler tidak mempertimbangkan QoS saat memilih sasaran-sasaran pemindahan. Pemindahan mempertimbangkan prioritas Pod dan mencoba memilih kumpulan sasaran dengan prioritas terendah. Pod-pod dengan prioritas lebih tinggi dipertimbangkan untuk pemindahan hanya jika penghapusan Pod-pod dengan prioritas terendah tidak cukup untuk memungkinkan Scheduler untuk menjadwalkan Pod <em>preemptor</em>, atau jika Pod-pod dengan prioritas terendah tersebut dilindungi oleh <code>PodDisruptionBudget</code>.</p><p>Komponen satu-satunya yang mempertimbangkan baik QoS dan prioritas Pod adalah <a href=/docs/tasks/administer-cluster/out-of-resource/>pengusiran oleh Kubelet karena kehabisan sumber daya</a>.
Kubelet menggolongkan Pod-pod untuk pengusiran pertama-tama berdasarkan apakah penggunaan sumber daya mereka melebihi <code>requests</code> mereka atau tidak, kemudian berdasarkan Priority, dan kemudian berdasarkan penggunaan sumber daya yang terbatas tersebut relatif terhadap <code>requests</code> dari Pod-pod tersebut.
Lihat <a href=/docs/tasks/administer-cluster/out-of-resource/#mengusir-pod-pod-pengguna>Mengusir Pod-pod pengguna</a> untuk lebih detail. Pengusiran oleh Kubelet karena kehabisan sumber daya tidak mengusir Pod-pod yang memiliki penggunaan sumber daya yang tidak melebihi <code>requests</code> mereka. Jika sebuah Pod dengan prioritas lebih rendah tidak melebihi <code>requests</code>-nya, ia tidak akan diusir. Pod lain dengan prioritas lebih tinggi yang melebihi <code>requests</code>-nya boleh diusir.</p></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/id/docs/home/>Home</a>
<a class=text-white href=/id/community/>Komunitas</a>
<a class=text-white href=/id/case-studies/>Studi kasus</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 Para Pencipta Kubernetes | Dokumentasi didistribusikan di bawah <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 Linux Foundation &reg;. Hak cipta dilindungi. Linux Foundation telah mendaftarkan merek dagang dan pengunaannya. Perinciannya bisa dilihat pada <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>halaman penggunaan merek dagang</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/popper-1.14.3.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script><script src=/js/bootstrap-4.3.1.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script><script src=/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js integrity="sha256-QGFiUam25LaJ53ab4DQGYe+k1+u3P5V0BOlj4TW07VI=" crossorigin=anonymous></script></body></html>