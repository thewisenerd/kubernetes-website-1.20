<!doctype html><html lang=ru class=no-js><head><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-36037335-10"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','UA-36037335-10')</script><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/architecture/><link rel=alternate hreflang=zh href=https://kubernetes.io/zh/docs/concepts/architecture/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/architecture/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/architecture/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/architecture/><link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/concepts/architecture/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/architecture/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/architecture/><link rel=alternate hreflang=pt href=https://kubernetes.io/pt/docs/concepts/architecture/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/architecture/><link rel=alternate hreflang=vi href=https://kubernetes.io/vi/docs/concepts/architecture/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.82.0"><link rel=canonical type=text/html href=https://kubernetes.io/ru/docs/concepts/architecture/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Кластерная Архитектура | Kubernetes</title><meta property="og:title" content="Кластерная Архитектура"><meta property="og:description" content="Первоклассная оркестрация контейнеров"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/ru/docs/concepts/architecture/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Кластерная Архитектура"><meta itemprop=description content="Первоклассная оркестрация контейнеров"><meta name=twitter:card content="summary"><meta name=twitter:title content="Кластерная Архитектура"><meta name=twitter:description content="Первоклассная оркестрация контейнеров"><link rel=preload href=/scss/main.min.aeea2a074ae7ac3d467a0d6f52e45894b49452cbb3f0f410c268ec7280c5a653.css as=style><link href=/scss/main.min.aeea2a074ae7ac3d467a0d6f52e45894b49452cbb3f0f410c268ec7280c5a653.css rel=stylesheet integrity><script src=/js/jquery-3.3.1.min.js integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin=anonymous></script><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png"}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:url" content="https://kubernetes.io/ru/docs/concepts/architecture/"><meta property="og:title" content="Кластерная Архитектура"><meta name=twitter:title content="Кластерная Архитектура"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/script.js></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ru/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ru/docs/>Документация</span></a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ru/community/>Сообщество</span></a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ru/case-studies/>Примеры использования</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versions</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=https://kubernetes.io/ru/docs/concepts/architecture/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ru/docs/concepts/architecture/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ru/docs/concepts/architecture/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ru/docs/concepts/architecture/>v1.21</a>
<a class=dropdown-item href=https://v1-20.docs.kubernetes.io/ru/docs/concepts/architecture/>v1.20</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Русский</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/architecture/>English</a>
<a class=dropdown-item href=/zh/docs/concepts/architecture/>中文 Chinese</a>
<a class=dropdown-item href=/ko/docs/concepts/architecture/>한국어 Korean</a>
<a class=dropdown-item href=/ja/docs/concepts/architecture/>日本語 Japanese</a>
<a class=dropdown-item href=/fr/docs/concepts/architecture/>Français</a>
<a class=dropdown-item href=/it/docs/concepts/architecture/>Italiano</a>
<a class=dropdown-item href=/de/docs/concepts/architecture/>Deutsch</a>
<a class=dropdown-item href=/es/docs/concepts/architecture/>Español</a>
<a class=dropdown-item href=/pt/docs/concepts/architecture/>Português</a>
<a class=dropdown-item href=/id/docs/concepts/architecture/>Bahasa Indonesia</a>
<a class=dropdown-item href=/vi/docs/concepts/architecture/>Tiếng Việt</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"></div><div class="d-none d-xl-block col-xl-2 td-toc d-print-none"></div><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/ru/docs/concepts/architecture/>Return to the regular view of this page</a>.</p></div><h1 class=title>Кластерная Архитектура</h1><ul><li>1: <a href=#pg-9ef2890698e773b6c0d24fd2c20146f5>Узлы</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-9ef2890698e773b6c0d24fd2c20146f5>1 - Узлы</h1><p>Kubernetes запускает ваши приложения, помещая контейнеры в Поды для запуска на Узлах (<em>Nodes</em>).
В зависимости от кластера, узел может быть виртуальной или физической машиной. Каждый узел
содержит сервисы, необходимые для запуска
<a class=glossary-tooltip title="Самый маленький и простой объект в Kubernetes. Под — это набор запущенных контейнеров в кластере." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Подов>Подов</a>, управляемых
<a class=glossary-tooltip title="Уровень оркестрации контейнеров с API и интерфейсами для определения, развёртывания и управления жизненным циклом контейнеров." data-toggle=tooltip data-placement=top href="/ru/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label="плоскостью управления">плоскостью управления</a>.</p><p>Обычно у вас есть несколько узлов в кластере; однако в среде обучения или среде
с ограниченными ресурсами у вас может быть только один.</p><p><a href=/ru/docs/concepts/overview/components/##%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D1%8B-%D1%83%D0%B7%D0%BB%D0%B0>Компоненты</a> на узле включают
<a class=glossary-tooltip title="Агент, работающий на каждом узле в кластере. Он следит за тем, чтобы контейнеры были запущены в поде." data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>,
<a class=glossary-tooltip title="Среда выполнения контейнера — это программа, предназначенная для выполнения контейнеров." data-toggle=tooltip data-placement=top href=/docs/reference/generated/container-runtime target=_blank aria-label="среду выполнения контейнера">среду выполнения контейнера</a> и
<a class=glossary-tooltip title="kube-proxy — сетевой прокси, работающий на каждом узле в кластере." data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a>.</p><h2 id=управление>Управление</h2><p>Существует два основных способа добавления Узлов в <a class=glossary-tooltip title="Компонент панели управления, обслуживающий API Kubernetes." data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-apiserver/ target=_blank aria-label="API сервер">API сервер</a>:</p><ol><li>Kubelet на узле саморегистрируется в плоскости управления</li><li>Вы или другой пользователь вручную добавляете объект Узла</li></ol><p>После того, как вы создадите объект Узла или kubelet на узле самозарегистируется,
плоскость управления проверяет, является ли новый объект Узла валидным (правильным). Например, если вы
попробуете создать Узел при помощи следующего JSON манифеста:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Node&#34;</span>,
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;10.240.79.157&#34;</span>,
    <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;my-first-k8s-node&#34;</span>
    }
  }
}
</code></pre></div><p>Kubernetes создает внутри себя объект Узла (представление). Kubernetes проверяет,
что kubelet зарегистрировался на API сервере, который совпадает с значением поля <code>metadata.name</code> Узла.
Если узел здоров (если все необходимые сервисы запущены),
он имеет право на запуск Пода. В противном случае, этот узел игнорируется для любой активности кластера
до тех пор, пока он не станет здоровым.</p><blockquote class="note callout"><div><strong>Заметка:</strong><p>Kubernetes сохраняет объект для невалидного Узла и продолжает проверять, становится ли он здоровым.</p><p>Вы или <a class=glossary-tooltip title="Управляющий цикл который отслеживает общее состояние кластера через API-сервер и вносит изменения пытаясь приветси текушее состояние к желаемому состоянию." data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=контроллер>контроллер</a> должны явно удалить объект Узла, чтобы
остановить проверку доступности узла.</p></div></blockquote><p>Имя объекта Узла дожно быть валидным
<a href=/ru/docs/concepts/overview/working-with-objects/names#%D0%B8%D0%BC%D0%B5%D0%BD%D0%B0-%D0%BF%D0%BE%D0%B4%D0%B4%D0%BE%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2-dns>именем поддомена DNS</a>.</p><h3 id=саморегистрация-узлов>Саморегистрация Узлов</h3><p>Когда kubelet флаг <code>--register-node</code> имеет значение <em>true</em> (по умолчанию), то kubelet будет пытаться
зарегистрировать себя на API сервере. Это наиболее предпочтительная модель, используемая большиством дистрибутивов.</p><p>Для саморегистрации kubelet запускается со следующими опциями:</p><ul><li><p><code>--kubeconfig</code> - Путь к учетным данным для аутентификации на API сервере.</p></li><li><p><code>--cloud-provider</code> - Как общаться с <a class=glossary-tooltip title="Организация, которая предлагает платформу облачных вычислений." data-toggle=tooltip data-placement=top href=/docs/concepts/cluster-administration/cloud-providers target=_blank aria-label="облачным провайдером">облачным провайдером</a>, чтобы прочитать метаданные о себе.</p></li><li><p><code>--register-node</code> - Автоматически зарегистрироваться на API сервере.</p></li><li><p><code>--register-with-taints</code> - Зарегистрировать узел с приведенным списком <a class=glossary-tooltip title="A core object consisting of three required properties: key, value, and effect. Taints prevent the scheduling of pods on nodes or node groups." data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label="ограничений (taints)">ограничений (taints)</a> (разделенных запятыми <code>&lt;key>=&lt;value>:&lt;effect></code>).</p><p>Ничего не делает, если <code>register-node</code> - <em>false</em>.</p></li><li><p><code>--node-ip</code> - IP-адрес узла.</p></li><li><p><code>--node-labels</code> - <a class=glossary-tooltip title="Группирует объекты на основе произвольных критериев, по которым пользователи могут их идентифицировать." data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=Метки>Метки</a> для добавления при регистрации узла в кластере (смотрите ограничения для меток, установленные <a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>плагином согласования (admission plugin) NodeRestriction</a>).</p></li><li><p><code>--node-status-update-frequency</code> - Указывает, как часто kubelet отправляет статус узла мастеру.</p></li></ul><p>Когда <a href=/docs/reference/access-authn-authz/node/>режим авторизации Узла</a> и
<a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>плагин согласования NodeRestriction</a> включены,
kubelet'ы имеют право только создавать/изменять свой собственный ресурс Узла.</p><h3 id=ручное-администрирование-узла>Ручное администрирование узла</h3><p>Вы можете создавать и изменять объекты узла используя
<a class=glossary-tooltip title="A command line tool for communicating with a Kubernetes API server." data-toggle=tooltip data-placement=top href=/docs/user-guide/kubectl-overview/ target=_blank aria-label=kubectl>kubectl</a>.</p><p>Когда вы хотите создать объекты Узла вручную, установите kubelet флаг <code>--register-node=false</code>.</p><p>Вы можете изменять объекты Узла независимо от настройки <code>--register-node</code>.
Например, вы можете установить метки на существующем Узле или пометить его неназначаемым.</p><p>Вы можете использовать метки на Узлах в сочетании с селекторами узла на Подах для управления планированием.
Например, вы можете ограничить Под иметь право на запуск только на группе доступных узлов.</p><p>Маркировка узла как неназначаемого предотвращает размещение планировщиком новых подов на этом Узле,
но не влияет на существующие Поды на Узле. Это полезно в качестве
подготовительного шага перед перезагрузкой узла или другим обслуживанием.</p><p>Чтобы отметить Узел неназначемым, выполните:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl cordon <span style=color:#b8860b>$NODENAME</span>
</code></pre></div><blockquote class="note callout"><div><strong>Заметка:</strong> Поды, являющиеся частью <a class=glossary-tooltip title="Гарантирует, что копия Pod выполняется в наборе узлов кластера." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a> допускают
запуск на неназначаемом Узле. DaemonSets обычно обеспечивает локальные сервисы узла,
которые должны запускаться на Узле, даже если узел вытесняется для запуска приложений.</div></blockquote><h2 id=статус-узла>Статус Узла</h2><p>Статус узла содержит следующие данные:</p><ul><li><a href=#%D0%B0%D0%B4%D1%80%D0%B5%D1%81%D0%B0>Адреса (Addresses)</a></li><li><a href=#%D1%83%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D0%B5>Условия (Conditions)</a></li><li><a href=#%D0%B5%D0%BC%D0%BA%D0%BE%D1%81%D1%82%D1%8C>Емкость и Выделяемые ресурсы (Capacity and Allocatable)</a></li><li><a href=#%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D1%8F>Информация (Info)</a></li></ul><p>Вы можете использовать <code>kubectl</code> для просмотра статуса Узла и других деталей:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe node &lt;insert-node-name-here&gt;
</code></pre></div><p>Каждая секция из вывода команды описана ниже.</p><h3 id=адреса-addresses>Адреса (Addresses)</h3><p>Использование этих полей варьируется в зависимости от вашего облачного провайдера или конфигурации физических серверов (<em>bare metal</em>).</p><ul><li>HostName: Имя хоста, сообщаемое ядром узла. Может быть переопределено через kubelet <code>--hostname-override</code> параметр.</li><li>ExternalIP: Обычно, IP адрес узла, который является внешне маршрутизируемым (доступен за пределами кластера).</li><li>InternalIP: Обычно, IP адрес узла, который маршрутизируется только внутри кластера.</li></ul><h3 id=условие>Условия (Conditions)</h3><p>Поле <code>conditions</code> описывает статус всех <code>Running</code> узлов. Примеры условий включают в себя:</p><table><caption style=display:none>Условия узла и описание того, когда применяется каждое условие.</caption><thead><tr><th>Условие Узла</th><th>Описание</th></tr></thead><tbody><tr><td><code>Ready</code></td><td><code>True</code> если узел здоров и готов принять поды, <code>False</code> если узел нездоров и не принимает поды, и <code>Unknown</code> если контроллер узла не получал информацию от узла в течение последнего периода <code>node-monitor-grace-period</code> (по умолчанию 40 секунд)</td></tr><tr><td><code>DiskPressure</code></td><td><code>True</code> если присутствует давление на размер диска - то есть, если емкость диска мала; иначе <code>False</code></td></tr><tr><td><code>MemoryPressure</code></td><td><code>True</code> если существует давление на память узла - то есть, если памяти на узле мало; иначе <code>False</code></td></tr><tr><td><code>PIDPressure</code></td><td><code>True</code> если существует давление на процессы - то есть, если на узле слишком много процессов; иначе <code>False</code></td></tr><tr><td><code>NetworkUnavailable</code></td><td><code>True</code> если сеть для узла настроена некорректно, иначе <code>False</code></td></tr></tbody></table><blockquote class="note callout"><div><strong>Заметка:</strong> Если вы используете инструменты командной строки для вывода сведений об блокированном узле,
то Условие включает <code>SchedulingDisabled</code>. <code>SchedulingDisabled</code> не является Условием в Kubernetes API;
вместо этого блокированные узлы помечены как Неназначемые в их спецификации.</div></blockquote><p>Состояние узла представлено в виде JSON объекта. Например, следующая структура описывает здоровый узел:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=color:#b44>&#34;conditions&#34;</span><span>:</span> [
  {
    <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;Ready&#34;</span>,
    <span style=color:green;font-weight:700>&#34;status&#34;</span>: <span style=color:#b44>&#34;True&#34;</span>,
    <span style=color:green;font-weight:700>&#34;reason&#34;</span>: <span style=color:#b44>&#34;KubeletReady&#34;</span>,
    <span style=color:green;font-weight:700>&#34;message&#34;</span>: <span style=color:#b44>&#34;kubelet is posting ready status&#34;</span>,
    <span style=color:green;font-weight:700>&#34;lastHeartbeatTime&#34;</span>: <span style=color:#b44>&#34;2019-06-05T18:38:35Z&#34;</span>,
    <span style=color:green;font-weight:700>&#34;lastTransitionTime&#34;</span>: <span style=color:#b44>&#34;2019-06-05T11:41:27Z&#34;</span>
  }
]
</code></pre></div><p>Если значение параметра Status для условия Ready остается <code>Unknown</code> или <code>False</code>
дольше чем период <code>pod-eviction-timeout</code>(аргумент, переданный в
<a class=glossary-tooltip title="Компонент Control Plane запускает процессы контроллера." data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>), то все Поды
на узле планируются к удалению контроллером узла. По умолчанию таймаут выселения <strong>пять минут</strong>.
В некоторых случаях, когда узел недоступен, API сервер не может связаться с kubelet на узле.
Решение об удалении подов не может быть передано в kubelet до тех пор, пока связь с API сервером не будет восстановлена.
В то же время поды, которые запланированы к удалению, могут продолжать работать на отделенном узле.</p><p>Контроллер узла не будет принудительно удалять поды до тех пор, пока не будет подтверждено,
что они перестали работать в кластере. Вы можете видеть, что поды, которые могут работать на недоступном узле,
находятся в состоянии <code>Terminating</code> или <code>Unknown</code>. В тех случаях, когда Kubernetes не может сделать вывод
из основной инфраструктуры о том, что узел окончательно покинул кластер, администратору кластера может потребоваться
удалить объект узла вручную. Удаление объекта узла из Kubernetes приводит к удалению всех объектов Подов, запущенных
на узле, с API сервера и освобождает их имена.</p><p>Контроллер жизненного цикла узла автоматически создает
<a href=/docs/concepts/scheduling-eviction/taint-and-toleration/>ограничения (taints)</a>, которые представляют собой условия.
Планировщик учитывает ограничения Узла при назначении Пода на Узел.
Поды так же могут иметь допуски (tolerations), что позволяет им сопротивляться ограничениям Узла.</p><p>Смотрите раздел <a href=/docs/concepts/configuration/taint-and-toleration/#taint-nodes-by-condition>Ограничить Узлы по Условию</a>
для дополнительной информации.</p><h3 id=емкость>Емкость и Выделяемые ресурсы (Capacity and Allocatable)</h3><p>Описывает ресурсы, доступные на узле: CPU, память и максимальное количество подов,
которые могут быть запланированы на узле.</p><p>Поля в блоке capasity указывают общее количество ресурсов, которые есть на Узле.
Блок allocatable указывает количество ресурсовна Узле,
которые доступны для использования обычными Подами.</p><p>Вы можете прочитать больше о емкости и выделяемых ресурсах, изучая, как <a href=/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>зарезервировать вычислительные ресурсы</a> на Узле.</p><h3 id=информация-info>Информация (Info)</h3><p>Описывает общую информацию об узле, такую как версия ядра, версия Kubernetes (версии kubelet и kube-proxy), версия Docker (если используется) и название ОС.
Эта информация соберается Kubelet'ом на узле.</p><h3 id=контроллер-узла>Контроллер узла</h3><p><a class=glossary-tooltip title="Управляющий цикл который отслеживает общее состояние кластера через API-сервер и вносит изменения пытаясь приветси текушее состояние к желаемому состоянию." data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label="Контроллер ">Контроллер</a> узла является компонентом
плоскости управления Kubernetes, который управляет различными аспектами узлов.</p><p>Контроллер узла играет различные роли в жизни узла. Первая - назначение CIDR-блока узлу
при его регистрации (если включено назначение CIDR).</p><p>Вторая - поддержание в актуальном состоянии внутреннего списка узлов контроллера узла
согласно списку доступных машин облачного провайдера. При работе в облачной среде всякий раз,
когда узел неисправен, контроллер узла запрашивает облачного провайдера, доступна ли
виртуальная машина для этого узла. Если нет, то контроллер узла удаляет узел из
своего списка узлов.</p><p>Третья - это мониторинг работоспособности узлов. Контроллер узла
отвечает за обновление условия NodeReady для NodeStatus на
ConditionUnknown, когда узел становится недоступным (т.е. контроллер узла
по какой-то причине перестает получать сердцебиения (heartbeats) от узла,
например, из-за того, что узел упал), и затем позже выселяет все поды с узла
(используя мягкое (graceful) завершение) если узел продолжает быть недоступным.
(По умолчанию таймауты составляют 40 секунд, чтобы начать сообщать <code>ConditionUnknown</code>,
и 5 минут после, чтобы начать выселять поды.) Контроллер узла проверяет состояние каждого узла
каждые <code>--node-monitor-period</code> секунд.</p><h4 id=сердцебиения>Сердцебиения</h4><p>Сердцебиения, посылаемые узлами Kubernetes, помогают определить доступность узла.</p><p>Существует две формы сердцебиений: обновление <code>NodeStatus</code> и
<a href=/docs/reference/generated/kubernetes-api/v1.24/#lease-v1-coordination-k8s-io>Lease объект</a>.
Каждый узел имеет связанный с ним Lease объект в <code>kube-node-lease</code>
<a class=glossary-tooltip title="An abstraction used by Kubernetes to support multiple virtual clusters on the same physical cluster." data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=namespace>namespace</a>.
Lease - это легковестный ресурс, который улучшает производительность
сердцебиений узла при масштабировании кластера.</p><p>Kubelet отвечает за создание и обновление <code>NodeStatus</code> и Lease объекта.</p><ul><li>Kubelet обновляет <code>NodeStatus</code> либо когда происходит изменение статуса,
либо если в течение настронного интервала обновления не было. По умолчанию
интервал для обновлений <code>NodeStatus</code> составляет 5 минут (намного больше,
чем 40-секундный стандартный таймаут для недоступных узлов).</li><li>Kubelet созадет и затем обновляет свой Lease объект каждый 10 секунд
(интервал обновления по умолчанию). Lease обновления происходят независимо от
<code>NodeStatus</code> обновлений. Если обновление Lease завершается неудачно,
kubelet повторяет попытку с экспоненциальным откатом, начинающимся с 200 миллисекунд и ограниченным 7 секундами.</li></ul><h4 id=надежность>Надежность</h4><p>В большинстве случаев контроллер узла ограничивает скорость выселения
до <code>--node-eviction-rate</code> (по умолчанию 0,1) в секунду, что означает,
что он не выселяет поды с узлов быстрее чем c 1 узела в 10 секунд.</p><p>Поведение выселения узла изменяется, когда узел в текущей зоне доступности
становится нездоровым. Контроллер узла проверяет, какой процент узлов в зоне
нездоров (NodeReady условие в значении ConditionUnknown или ConditiononFalse)
в одно и то же время. Если доля нездоровых узлов не меньше
<code>--unhealthy-zone-threshold</code> (по умолчанию 0.55), то скорость выселения уменьшается:
если кластер небольшой (т.е. количество узлов меньше или равно
<code>--large-cluster-size-threshold</code> - по умолчанию, 50), то выселения прекращаются,
в противном случае скорость выселения снижается до
<code>--secondary-node-eviction-rate</code> (по умолчанию, 0.01) в секунду. Причина, по которой
эти политики реализуются для каждой зоны доступности, заключается в том,
что одна зона доступности может стать отделенной от мастера, в то время как другие
остаются подключенными. Если ваш кластер не охватывает несколько зон доступности
облачного провайдера, то существует только одна зона доступности (весь кластер).</p><p>Основная причина разнесения ваших узлов по зонам доступности заключается в том,
что приложения могут быть перенесены в здоровые зоны, когда одна из зон полностью
становится недоступной. Поэтому, если все узлы в зоне нездоровы, то контроллер узла
выселяет поды с нормальной скоростью <code>--node-eviction-rate</code>. Крайний случай - когда все зоны
полностью нездоровы (т.е. в кластере нет здоровых узлов). В таком случае
контроллер узла предполагает, что существует некоторая проблема с подключением к мастеру,
и останавеливает все выселения, пока какое-нибудь подключение не будет восстановлено.</p><p>Контроллер узла также отвечает за выселение подов, запущенных на узлах с
<code>NoExecute</code> ограничениями, за исключением тех подов, которые сопротивляются этим ограничениям.
Контроллер узла так же добавляет <a class=glossary-tooltip title="A core object consisting of three required properties: key, value, and effect. Taints prevent the scheduling of pods on nodes or node groups." data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=ограничения>ограничения</a>
соотвествующие проблемам узла, таким как узел недоступен или не готов. Это означает,
что планировщик не будет размещать поды на нездоровых узлах.</p><blockquote class="caution callout"><div><strong>Внимание:</strong> <code>kubectl cordon</code> помечает узел как 'неназначемый', что имеет побочный эфект от контроллера сервисов,
удаляющего узел из любых списков целей LoadBalancer узла, на которые он ранее имел право,
эффектино убирая входящий трафик балансировщика нагрузки с блокированного узла(ов).</div></blockquote><h3 id=емкость-узла>Емкость узла</h3><p>Объекты узла отслеживают информацию о емкости ресурсов узла (например,
объем доступной памяти и количество CPU).
Узлы, которые <a href=#%D1%81%D0%B0%D0%BC%D0%BE%D1%80%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80%D0%B0%D1%86%D0%B8%D1%8F-%D1%83%D0%B7%D0%BB%D0%BE%D0%B2>самостоятельно зарегистировались</a> сообщают
о свое емкости во время регистрации. Если вы <a href=#%D1%80%D1%83%D1%87%D0%BD%D0%BE%D0%B5-%D0%B0%D0%B4%D0%BC%D0%B8%D0%BD%D0%B8%D1%81%D1%82%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%83%D0%B7%D0%BB%D0%B0>вручную</a>
добавляете узел, то вам нужно задать информацию о емкости узла при его добавлении.</p><p><a class=glossary-tooltip title="Компонент плоскости управления, который отслеживает созданные поды без привязанного узла и выбирает узел, на котором они должны работать." data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=Планировщик>Планировщик</a> Kubernetes гарантирует,
что для всех Подов на Узле достаточно ресурсов. Планировщик проверяет,
что сумма requests от контейнеров на узле не превышает емкость узла.
Эта сумма requests включает все контейнеры, управляемые kubelet,
но исключает любые контейнеры, запущенные непосредственно средой выполнения контейнера,
а также исключает любые процессы, запущенные вне контроля kubelet.</p><blockquote class="note callout"><div><strong>Заметка:</strong> Если вы явно хотите зарезервировать ресурсы для процессов, не связанныз с Подами, смотрите раздел
<a href=/docs/tasks/administer-cluster/reserve-compute-resources/#system-reserved>зарезервировать ресурсы для системных демонов</a>.</div></blockquote><h2 id=топология-узла>Топология узла</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.16 [alpha]</code></div><p>Если вы включили <code>TopologyManager</code>
<a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>, то kubelet
может использовать подсказки топологии при принятии решений о выделении ресурсов.
Смотрите <a href=/docs/tasks/administer-cluster/topology-manager/>Контроль Политик Управления Топологией на Узле</a>
для дополнительной информации.</p><h2 id=что-дальше>Что дальше</h2><ul><li>Подробнее про<a href=/ru/docs/concepts/overview/components/#%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D1%8B-%D1%83%D0%B7%D0%BB%D0%B0>компоненты</a> из которых состоит узел.</li><li>Подробнее про <a href=/docs/reference/generated/kubernetes-api/v1.20/#node-v1-core>Определение API для Узла</a>.</li><li>Подробнее про <a href=https://git.k8s.io/community/contributors/design-proposals/architecture/architecture.md#the-kubernetes-node>Узлы</a>
of the architecture design document.</li><li>Подробнее про <a href=/docs/concepts/configuration/taint-and-toleration/>ограничения и допуски</a>.</li><li>Подробнее про <a href=/docs/tasks/administer-cluster/cluster-management/#cluster-autoscaling>автомаштабирование кластера</a>.</li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ru/docs/home/>Главная</a>
<a class=text-white href=/ru/community/>Сообщество</a>
<a class=text-white href=/ru/case-studies/>Примеры использования</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 Авторы Kubernetes | Документация распространяется под лицензией <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. Все права защищены. The Linux Foundation является зарегистрированной торговой маркой. Список торговых марок The Linux Foundation приведен на странице <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>использования торговых марок</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/popper-1.14.3.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script><script src=/js/bootstrap-4.3.1.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script><script src=/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js integrity="sha256-QGFiUam25LaJ53ab4DQGYe+k1+u3P5V0BOlj4TW07VI=" crossorigin=anonymous></script></body></html>